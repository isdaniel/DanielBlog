<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Asp.Net重要物件HttpApplication(一) 初始化建立IHttpMoudule (第5天)]]></title>
    <url>%2FIthelp-day5%2F</url>
    <content type="text"><![CDATA[Agenda 前言： 初始化HttpApplication (InitInternal) InitModules 管道模式 vs 經典模式 取得執行HttpHandler物件 小結 前言：附上Asp.net執行請求流程圖. 上一篇文章分享HttpApplicationFactory.GetApplicationInstance方法返回一個HttpApplication給HttpRuntime來呼叫使用. 今天開始介紹HttpApplication這個很重要的類別,它可謂是我們Asp.net中很複雜但重要的類別 Global.cs是繼承HttpApplication類別,但為什麼需要繼承這個類別呢? 讓我們繼續看下去. 查看原始碼好站 Reference Source此文的程式碼比較多我會在原始碼上邊上說明相對應編號方便大家觀看 初始化HttpApplication (InitInternal)在GetNormalApplicationInstance返回一個HttpApplication物件前會呼叫初始化HttpApplication.InitInternal方法 這個方法主要做下面幾件事情 初始化HttpModule，讀取Host config或appconfig 註冊的HttpMoudle,並調用Init方法，使用AOP編成方式註冊使用事件 提供一個Hock給繼承Application物件來初始化設定使用 判斷要走管道模式還是經典模式 建置Pipleline流程 建立許多實現IExecutionStep接口的物件並添加到目前HttpApplication物驗的_execSteps集合中.從這裡我們可以看到HttpApplication是以異步的方式處理請求 HttpModule是在InitInternal方法中被讀取執行. 我們可以透過 HttpContext.ApplicationInstance.Modules ，得知目前所有載入HttpModule. 下面是InitInternal原始碼(核心動作有寫中文註解) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384internal void InitInternal(HttpContext context, HttpApplicationState state, MethodInfo[] handlers)&#123; // Remember state _state = state; PerfCounters.IncrementCounter(AppPerfCounter.PIPELINES); try &#123; try &#123; _initContext = context; _initContext.ApplicationInstance = this; context.ConfigurationPath = context.Request.ApplicationPathObject; using (new DisposableHttpContextWrapper(context)) &#123; // 1.初始化HttpModule. if (HttpRuntime.UseIntegratedPipeline) &#123; try &#123; context.HideRequestResponse = true; _hideRequestResponse = true; InitIntegratedModules(); &#125; finally &#123; context.HideRequestResponse = false; _hideRequestResponse = false; &#125; &#125; else &#123; InitModules(); &#125; // Hookup event handlers via reflection if (handlers != null) HookupEventHandlersForApplicationAndModules(handlers); // Initialization of the derived class _context = context; if (HttpRuntime.UseIntegratedPipeline &amp;&amp; _context != null) &#123; _context.HideRequestResponse = true; &#125; _hideRequestResponse = true; try &#123; //2.提供一個Hock給繼承Application物件來初始化設定使用 Init(); &#125; catch (Exception e) &#123; RecordError(e); &#125; &#125; if (HttpRuntime.UseIntegratedPipeline &amp;&amp; _context != null) &#123; _context.HideRequestResponse = false; &#125; _hideRequestResponse = false; _context = null; _resumeStepsWaitCallback= new WaitCallback(this.ResumeStepsWaitCallback); //3. 判斷要走管道模式還是經典模式 if (HttpRuntime.UseIntegratedPipeline) &#123; _stepManager = new PipelineStepManager(this); &#125; else &#123; _stepManager = new ApplicationStepManager(this); &#125; //4. 建置Pipleline流程 _stepManager.BuildSteps(_resumeStepsWaitCallback); &#125; finally &#123; _initInternalCompleted = true; // Reset config path context.ConfigurationPath = null; // don't hold on to the context _initContext.ApplicationInstance = null; _initContext = null; &#125; &#125; catch &#123; // Protect against exception filters throw; &#125;&#125; InitModules這個方法讀取註冊的HttpModule並共同放在一起,在一起呼叫InitModulesCommon方法來呼叫所有Modules的Init方法 1234567891011121314151617181920212223private void InitModules() &#123; HttpModulesSection pconfig = RuntimeConfig.GetAppConfig().HttpModules; HttpModuleCollection moduleCollection = pconfig.CreateModules(); HttpModuleCollection dynamicModules = CreateDynamicModules(); moduleCollection.AppendCollection(dynamicModules); _moduleCollection = moduleCollection; InitModulesCommon();&#125;private void InitModulesCommon() &#123; int n = _moduleCollection.Count; for (int i = 0; i &lt; n; i++) &#123; _currentModuleCollectionKey = _moduleCollection.GetKey(i); _moduleCollection[i].Init(this); &#125; _currentModuleCollectionKey = null; InitAppLevelCulture();&#125; _moduleCollection[i].Init(this); 其中的this就是把HttpApplication物件本身傳入這也是為什麼我們繼承IHttpMoudel介面可以共同使用同一個HttpApplication物件 1234567public interface IHttpModule&#123; void Init(HttpApplication context); void Dispose();&#125; 上面呼叫的就是void Init(HttpApplication context)方法. 如果要取得目前所註冊HttpModule可透過HttpApplication.Modules屬性 管道模式 vs 經典模式下面兩張圖是管道模式和經典模式 經典模式 管道模式 圖片來源 除了執行流程不一樣跟一些差異外，他們最終還是為了要找到一個HttpHandler來執行. 取得執行HttpHandler物件如果有認真看原始碼的小夥伴,會發現HttpApplication的ProcessRequest目前是throw一個錯誤. 那他是怎麼找到使用HttpHandler物件並完成請求的呢? 123void IHttpHandler.ProcessRequest(HttpContext context) &#123; throw new HttpException(SR.GetString(SR.Sync_not_supported));&#125; 因為HttpRunTime是呼叫異步請求BeginProcessRequest方法. 這邊提一下 啟動吧!Asp.Net IsapiRunTime &amp; HttpRuntime會先判斷app物件是否實現IHttpAsyncHandler. HttpApplication有實現IHttpAsyncHandler介面.所以優先執行異步請求. 1234567891011if (app is IHttpAsyncHandler) &#123; // asynchronous handler IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)app; context.AsyncAppHandler = asyncHandler; asyncHandler.BeginProcessRequest(context, _handlerCompletionCallback, context);&#125;else &#123; // synchronous handler app.ProcessRequest(context); FinishRequest(context.WorkerRequest, context, null);&#125; 小結今天我們學到 HttpApplication去讀取所有註冊的HttpModule並呼叫他們的Init方法. 經典模式和管道模式除了執行流程不同最終目標還是找尋一個HttpHandler HttpRunTime是呼叫異步請求 很多文章都會提到10幾個事件（BeginRequest, EndRequest…..等） 下篇會介紹StepManager如何建立管道和如何呼叫事件並找尋HttpHandler來執行. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day5/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[掌控HttpApplication物件建立 - HttpApplicationFactory (第4天)]]></title>
    <url>%2FIthelp-day4%2F</url>
    <content type="text"><![CDATA[Agenda 前言： HttpApplication物件 取得使用 HttpApplication物件 (GetApplicationInstance) HttpApplicationFactory 初始化 (EnsureInited方法) Application_Start方法為什麼只會呼叫一次? (EnsureAppStartCalled) 返回一個 HttpApplication 物件 (GetNormalApplicationInstance) 小結 前言：附上Asp.net執行請求流程圖. 在前一篇我們說到HttpRunTime會透過GetApplicationInstance來取得一個IHttpHandler對象. 今天跟著原始碼來了解到底回傳一個什麼IHttpHandler物件給HttpRunTime使用. 查看原始碼好站 Reference Source HttpApplication物件HttpApplication是整個ASP.NET基礎的核心。一個HttpApplication物件在某個時刻只能處理一個請求,只有完成對某個請求處理後,該HttpApplication才能用於後續的請求的處理。 所以ASP.NET利用物件程序池機制來建立或者取得HttpApplication物件。具體來講,當第一個Http請求抵達的時候,ASP.NET會一次建立多個HttpApplication物件,並將其置於池中,選擇其中一個物件來處理該請求。 而如果程序池中沒有HttpApplication物件,Asp.net會建立新的HttpApplication物件處理請求 HttpApplication物件處理Http請求整個生命週期是一個相對複雜的過程,在該過程的不同階段會觸發相應的事件。我們可以註冊相應的事件(如同上一篇介紹事件表) 下圖就是模擬HttpApplication的ObjectPool樣子 取得使用 HttpApplication物件 (GetApplicationInstance)讓我們看看GetApplicationInstan方法做了什麼事情. 12345678910111213141516private static HttpApplicationFactory _theApplicationFactory = new HttpApplicationFactory();internal static IHttpHandler GetApplicationInstance(HttpContext context) &#123; if (_customApplication != null) return _customApplication; // Check to see if it's a debug auto-attach request if (context.Request.IsDebuggingRequest) return new HttpDebugHandler(); _theApplicationFactory.EnsureInited(); _theApplicationFactory.EnsureAppStartCalled(context); return _theApplicationFactory.GetNormalApplicationInstance(context);&#125; _theApplicationFactory是一個靜態物件 _theApplicationFactory呼叫三個方法EnsureInited,EnsureAppStartCalled,GetNormalApplicationInstance,讓我們一一來解析做了些什麼事情吧 HttpApplicationFactory 初始化 (EnsureInited方法)通過查找Init方法的代碼以及其中2行如下代碼裡的細節,我們可以得知,這2行代碼主要是從global.asax獲取內容,然後進行編譯。 HttpApplicationFactory.EnsureInited()方法檢查HttpApplicationFactory是否已經被初始化,如果沒有就呼叫HttpApplicationFactory.Init()進行初始化。 在Init()中,先獲取網站下global.asax文件完整路徑(透過GetApplicationFile方法),最後呼叫CompileApplication()方法對global.asax進行編譯. 在EnsureInited方法 12345678910111213141516171819202122232425262728293031private void EnsureInited() &#123; if (!_inited) &#123; lock (this) &#123; if (!_inited) &#123; Init(); _inited = true; &#125; &#125; &#125;&#125;private void CompileApplication() &#123; // Get the Application Type and AppState from the global file _theApplicationType = BuildManager.GetGlobalAsaxType(); BuildResultCompiledGlobalAsaxType result = BuildManager.GetGlobalAsaxBuildResult(); if (result != null) &#123; if (result.HasAppOrSessionObjects) &#123; GetAppStateByParsingGlobalAsax(); &#125; _fileDependencies = result.VirtualPathDependencies; &#125; if (_state == null) &#123; _state = new HttpApplicationState(); &#125; ReflectOnApplicationType();&#125; ReflectOnApplicationType方法取得目前特別事件方法,並添加到相對應的MethodInfo成員上 會透過以下三類方法名稱去取方法資訊 Application_OnStart or Application_Start Application_OnEnd or Application_End Session_OnEnd or Session_End 取得這些資訊會提供EnsureAppStartCalled去呼叫Application_OnStart方法 12345678910111213141516171819202122232425262728private void ReflectOnApplicationType() &#123; ArrayList handlers = new ArrayList(); MethodInfo[] methods; Debug.Trace("PipelineRuntime", "ReflectOnApplicationType"); // get this class methods methods = _theApplicationType.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static); foreach (MethodInfo m in methods) &#123; if (ReflectOnMethodInfoIfItLooksLikeEventHandler(m)) handlers.Add(m); &#125; // get base class private methods (GetMethods would not return those) Type baseType = _theApplicationType.BaseType; if (baseType != null &amp;&amp; baseType != typeof(HttpApplication)) &#123; methods = baseType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static); foreach (MethodInfo m in methods) &#123; if (m.IsPrivate &amp;&amp; ReflectOnMethodInfoIfItLooksLikeEventHandler(m)) handlers.Add(m); &#125; &#125; // remember as an array _eventHandlerMethods = new MethodInfo[handlers.Count]; for (int i = 0; i &lt; _eventHandlerMethods.Length; i++) _eventHandlerMethods[i] = (MethodInfo)handlers[i];&#125; Application_Start方法為什麼只會呼叫一次? (EnsureAppStartCalled)HttpApplicationFactory.EnsureAppStartCalled方法建立一個HttpApplication物件並觸發Application_OnStart事件(執行Global.asax中的Application_Start(object sender, EventArgs e)) 在處理完事件Application_OnStart後HttpApplication物件會立即被回收掉,因為系統初始化只需要一次 但是其中GetSpecialApplicationInstance裡會對IIS7做一些特殊的事情這裡就不多提 1234567891011121314151617181920212223242526272829303132private void EnsureAppStartCalled(HttpContext context) &#123; if (!_appOnStartCalled) &#123; lock (this) &#123; if (!_appOnStartCalled) &#123; using (new DisposableHttpContextWrapper(context)) &#123; WebBaseEvent.RaiseSystemEvent(this, WebEventCodes.ApplicationStart); FireApplicationOnStart(context); &#125; _appOnStartCalled = true; &#125; &#125; &#125;&#125;private void FireApplicationOnStart(HttpContext context) &#123; if (_onStartMethod != null) &#123; HttpApplication app = GetSpecialApplicationInstance(); app.ProcessSpecialRequest( context, _onStartMethod, _onStartParamCount, this, EventArgs.Empty, null); RecycleSpecialApplicationInstance(app); &#125;&#125; 在處理完事件Application_OnStart呼叫RecycleSpecialApplicationInstance回收HttpApplication物件 返回一個 HttpApplication 物件 (GetNormalApplicationInstance)方法中主要做. 判斷_freeList集合中是否有可用HttpApplication物件(物件程序池中),如果沒有就利用HttpRuntime.CreateNonPublicInstance(_theApplicationType)透過反射建立一個新的HttpApplication返回(呼叫完IHttpHandler.ProcessRequst方法後會將這個物件存入_freeList中),最後將 12345678910111213141516171819private HttpApplication GetNormalApplicationInstance(HttpContext context) &#123; HttpApplication app = null; if (!_freeList.TryTake(out app)) &#123; // If ran out of instances, create a new one app = (HttpApplication)HttpRuntime.CreateNonPublicInstance(_theApplicationType); using (new ApplicationImpersonationContext()) &#123; app.InitInternal(context, _state, _eventHandlerMethods); &#125; &#125; if (AppSettings.UseTaskFriendlySynchronizationContext) &#123; // When this HttpApplication instance is no longer in use, recycle it. app.ApplicationInstanceConsumersCounter = new CountdownTask(1); // representing required call to HttpApplication.ReleaseAppInstance app.ApplicationInstanceConsumersCounter.Task.ContinueWith((_, o) =&gt; RecycleApplicationInstance((HttpApplication)o), app, TaskContinuationOptions.ExecuteSynchronously); &#125; return app;&#125; 所以最終我們是返回一個HttpApplication物件來使用. 小結今天我們學到 IHttpHandler GetApplicationInstance(HttpContext context)其實是返回一個HttpApplication物件. 在EnsureAppStartCalled方法中呼叫FireApplicationOnStart方法動態建立一個HttpApplication物件,呼叫完Application_OnStart事件就回收掉並使用一個flag布林值代表已經呼叫過. 這個工廠會有一個 _freeList 集合來存取之前用過的HttpApplication物件,如果集合中沒有適合的HttpApplication物件就會使用反射返回一個新的HttpApplication並將他初始化． 所以HttpRuntime呼叫的是HttpApplication物件的ProcessRequest方法 下篇會跟大家介紹HttpApplication類別成員詳細資訊 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day4/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[啟動吧!Asp.Net IsapiRunTime & HttpRuntime (第3天)]]></title>
    <url>%2FIthelp-day3%2F</url>
    <content type="text"><![CDATA[Agenda 前言: IIS 與 Asp net (W3SVC服務) IISAPIRuntime介面 IsapiRunTime.ProcessRequest HttpRuntime.ProcessRequestNoDemand ProcessRequestInternal 小結 前言:上一篇我們介紹HttpModule &amp; HttpHandler對於 今天正式進入.Net CLR處理Http請求的世界. 先附上Asp.net執行請求流程圖. 現在開始講解藍色區塊. 查看原始碼好站 Reference Source IIS 與 Asp net (W3SVC服務)World Wide Web Publishing Service（簡稱W3SVC）是一個Window Service. W3SVC在SvcHost.exe這個應用程式上被執行. W3SVC主要功能 HTTP請求的監聽 工作執行緒的管理以及配置管理 當檢測到某個HTTP Request後，先根據一個註冊表判斷請求的副檔名是否是靜態資源(比如.html,.img,.txt,.xml…)如果是則直接將文件內容以HTTP Response的形式返回。 如果是動態資源（比如.aspx,asp,php等等），則通過副檔名從IIS的Script Map找到相應ISAPI.dll IISAPIRuntime介面前面說到透過W3SVC服務 System.Web.Hosting.IISAPIRuntime這個介面是一個基於COM的Interface,ASP.NET ISAPI可以通過COM的方式調用實現該Interface的Class物件的ProcessRequest方法，從非託管環境進入了託管的環境。 12345678910111213141516[ComImport, Guid("08a2c56f-7c16-41c1-a8be-432917a1a2d1"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]public interface IISAPIRuntime &#123; void StartProcessing(); void StopProcessing(); [return: MarshalAs(UnmanagedType.I4)] int ProcessRequest( [In] IntPtr ecb, [In, MarshalAs(UnmanagedType.I4)] int useProcessModel); void DoGCCollect();&#125; 所以IISAPIRuntime.ProcessRequest是我們探討原始碼起始點. IsapiRunTime.ProcessRequest一開始會先呼叫IsapiRunTime的ProcessRequest方法來執行此次請求. 在CreateWorkerRequest會依據不同IIS版本建立不同ISAPIWorkerRequest物件,之後在呼叫Initialize方法把Http請求內容初次填入這個對象. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int ProcessRequest(IntPtr ecb, int iWRType) &#123; IntPtr pHttpCompletion = IntPtr.Zero; if (iWRType == WORKER_REQUEST_TYPE_IN_PROC_VERSION_2) &#123; pHttpCompletion = ecb; ecb = UnsafeNativeMethods.GetEcb(pHttpCompletion); &#125; ISAPIWorkerRequest wr = null; try &#123; bool useOOP = (iWRType == WORKER_REQUEST_TYPE_OOP); wr = ISAPIWorkerRequest.CreateWorkerRequest(ecb, useOOP); wr.Initialize(); String wrPath = wr.GetAppPathTranslated(); String adPath = HttpRuntime.AppDomainAppPathInternal; if (adPath == null || StringUtil.EqualsIgnoreCase(wrPath, adPath)) &#123; HttpRuntime.ProcessRequestNoDemand(wr); return 0; &#125; else &#123; // need to restart app domain HttpRuntime.ShutdownAppDomain(ApplicationShutdownReason.PhysicalApplicationPathChanged, SR.GetString(SR.Hosting_Phys_Path_Changed, adPath, wrPath)); return 1; &#125; &#125; catch(Exception e) &#123; try &#123; WebBaseEvent.RaiseRuntimeError(e, this); &#125; catch &#123;&#125; if (wr != null &amp;&amp; wr.Ecb == IntPtr.Zero) &#123; if (pHttpCompletion != IntPtr.Zero) &#123; UnsafeNativeMethods.SetDoneWithSessionCalled(pHttpCompletion); &#125; if (e is ThreadAbortException) &#123; Thread.ResetAbort(); &#125; return 0; &#125; throw; &#125;&#125; 這段程式碼有幾個重點: 把Http請求內文封裝到WorkerRequest物件中,方便日後使用. wr.Initialize()初始化WorkerRequest物件 呼叫HttpRuntime.ProcessRequestNoDemand方法並把剛剛初始化的WorkerRequest物件當作參數傳入. 其中參數ecb(Execution Control Block)是一個Unmanaged Pointer ISAPIRuntime不能直接調用ASP.NET ISAPI,所以通過一個ecb物件指標,ecb實現ISAPI和ISAPIRutime之間溝通. HttpRuntime.ProcessRequestNoDemand先來看看剛剛呼叫的HttpRuntime.ProcessRequestNoDemand方法. 這裡需要注意兩個重點. 判斷目前執行程序池是否已經超過負荷,如果是會把wr物件指向null 12if (rq != null) wr = rq.GetRequestToExecute(wr); 如果wr!=null(代表還有資源可以執行請求)就呼叫ProcessRequestNow方法會繼續呼叫ProcessRequestInternal方法. 123456789101112131415161718internal static void ProcessRequestNoDemand(HttpWorkerRequest wr) &#123; RequestQueue rq = _theRuntime._requestQueue; wr.UpdateInitialCounters(); if (rq != null) // could be null before first request wr = rq.GetRequestToExecute(wr); if (wr != null) &#123; CalculateWaitTimeAndUpdatePerfCounter(wr); wr.ResetStartTime(); ProcessRequestNow(wr); &#125;&#125;internal static void ProcessRequestNow(HttpWorkerRequest wr) &#123; _theRuntime.ProcessRequestInternal(wr);&#125; ProcessRequestInternal在HttpRuntime很重要的方法之一是ProcessRequestInternal 下面程式碼，我把ProcessRequestInternal方法中註解移除且只貼出我覺得重要的程式碼 此方法有做幾個事情: 如果Server很忙碌回傳wr.SendStatus(503, &quot;Server Too Busy&quot;); 利用HttpWorkerRequest物件封裝我們常常使用HttpContext 透過HttpApplicationFactory.GetApplicationInstance返回一個IHttpHandler物件 如果返回的IHttpHandler物件支援異步請求優先執行,不然就執行同步請求. 上面第3,4點最為重要,因為我們就可以很清楚了解到為什麼最後都會找到一個繼承IHttpHandler介面的物件來執行ProcessRequest方法. 因為Asp.net在HttpRunTime程式碼中倚賴一個IHttpHandler介面抽象才造就具有彈性的系統架構. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void ProcessRequestInternal(HttpWorkerRequest wr) &#123; HttpContext context; try &#123; //封裝我們常常使用`HttpContext` context = new HttpContext(wr, false /* initResponseWriter */); &#125; catch &#123; try &#123; wr.SendStatus(400, "Bad Request"); wr.SendKnownResponseHeader(HttpWorkerRequest.HeaderContentType, "text/html; charset=utf-8"); byte[] body = Encoding.ASCII.GetBytes("&lt;html&gt;&lt;body&gt;Bad Request&lt;/body&gt;&lt;/html&gt;"); wr.SendResponseFromMemory(body, body.Length); wr.FlushResponse(true); wr.EndOfRequest(); return; &#125; finally &#123; Interlocked.Decrement(ref _activeRequestCount); &#125; &#125; try &#123; try &#123; EnsureFirstRequestInit(context); &#125; catch &#123; if (!context.Request.IsDebuggingRequest) &#123; throw; &#125; &#125; context.Response.InitResponseWriter(); IHttpHandler app = HttpApplicationFactory.GetApplicationInstance(context); if (app == null) throw new HttpException(SR.GetString(SR.Unable_create_app_object)); if (EtwTrace.IsTraceEnabled(EtwTraceLevel.Verbose, EtwTraceFlags.Infrastructure)) EtwTrace.Trace(EtwTraceType.ETW_TYPE_START_HANDLER, context.WorkerRequest, app.GetType().FullName, "Start"); //如果返回的IHttpHandler物件支援異步請求優先執行,不然就執行同步請求. if (app is IHttpAsyncHandler) &#123; // asynchronous handler IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)app; context.AsyncAppHandler = asyncHandler; asyncHandler.BeginProcessRequest(context, _handlerCompletionCallback, context); &#125; else &#123; // synchronous handler app.ProcessRequest(context); FinishRequest(context.WorkerRequest, context, null); &#125; &#125; catch (Exception e) &#123; context.Response.InitResponseWriter(); FinishRequest(wr, context, e); &#125;&#125; 下面此這個方法執行時兩個小重點. ProcessRequestInternal方法初始化我們常用HttpContext物件,把Http內容封裝到這個類別中. 如果返回IHttpHandler物件支援異步請求優先執行,不然就執行同步請求. 小結今天我們學到 ISAPIRunTime.ProcessRequest方法 建立一個WorkerRequest物件把Http內容封裝到裡面,並呼叫 HttpRuntime.ProcessRequestNoDemand方法. HttpRuntime.ProcessRequestNoDemand方法 檢查目前是否有資源可以處理請求 封裝HttpContext並初始化內容資料 利用HttpApplicationFactory.GetApplicationInstance取得IHttpHanlder物件 呼叫IHttpHanlder ProcessRequest方法 下篇我們會來好好介紹HttpApplicationFactory這個工廠到底如何返回IHttpHanlder物件. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day3/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net支柱 IHttpMoudle & IHttphandler (第2天)]]></title>
    <url>%2FIthelp-day2%2F</url>
    <content type="text"><![CDATA[Agenda 前言： IHttpHandler和HttpModule關係 Asp.net_Application_Event生命週期 Event事件名稱： 事件方法說明： IHttpHandler IHttpModule 自己建立一個 IHttpHandler Web.Config註冊上面撰寫的IHttpHandler 自己建立一個 IHttpModule 建立一個類別實現IHttpModule Web.Config註冊上面撰寫的IHttpModule 程式碼 建立一個類別實現IHttpHander ApplicationHost.config 設定擋 IIS預設設定Module在哪邊? IIS IISExpress 小結 參考資料： 前言：上一篇文章我們有說 Asp.net 有兩個核心組件 IHttpMoudle &amp; IHttphandler Asp.net 是一個pipeline的模型，理解這些管道除了可以讓我們節省許多不必要的資源浪費也可讓我們程式架構更加有條理. 就像我們在Asp.net MVC如果要寫權限驗證程式碼,雖然可以寫在Controller的Action中 但更好做法是我可以寫一個類別繼承AuthorizeAttribute並override OnAuthorization方法並掛上此標籤. 更了解這些原理可以讓我們寫程式事半功倍. IHttpHandler和HttpModule關係Http請求像是一個旅客身上帶著行李拿著票來搭火車. HttpHandler 是火車的終點站. HttpModule 是火車中途停靠的各站. Asp.net_Application_Event生命週期我們已經知道Asp.net是一個請求處理響應的管道而這個管道中微軟有提供許多點可以讓我們進行客製化的擴充程式撰寫 事件可藉由IHttpModule來擴充註冊 Event事件名稱：官網列出可用事件很多，下面列出我有用過的幾個事件和其功用. BeginRequest AuthorizeRequest PostResolveRequestCache MapRequestHandler AcquireRequestState PreRequestHandlerExecute PostRequestHandlerExecute EndRequest 事件方法說明： BeginRequest: 已經啟動要求。如果要在要求前執行某個動作 (例如, 在每頁頁首顯示廣告橫幅), 請同步處理這個事件。 AuthorizeRequest: 您可以在內部使用這個事件, 以實作授權機制 (例如, 將存取控制清單 (ACL) 儲存在資料庫, 而非存入檔案系統)。您也可以覆寫這個事件, 但無此必要。 PostResolveRequestCache：當 ASP.NET 略過目前事件處理常式的執行並允許快取模組從快取中服務要求時發生。 MapRequestHandler：ASP.NET 基礎結構會使用事件來判斷目前要求的要求處理常式。 如需詳細資訊 AcquireRequestState: 工作階段狀態是擷取自狀態儲存區。如果要建置自已的狀態管理模組, 則可以同步處理這個事件, 以便從狀態儲存區擷取「工作階段」狀態。 PreRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之前產生。 在介於PreRequestHandlerExecute和PostRequestHandlerExecute事件之間會執行HttpHandler程式碼. PostRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之後產生。 EndRequest: 要求已完成。您可能想要建置偵錯模組, 以便收集要求的全部資訊, 然後再將資訊寫入網頁中。 IHttpHandler和IHttpModule關係如 Implementing HTTPHandler and HTTPModule in ASP.NET 文章提到 每個請求一定會通過所有被註冊的IHttpModule,而最終會執行一個IHttpHandler後進行返回. 我們常聽到的Asp.net Webform，MVC都是經過管道Module並執行相對應的Handler. 所以HttpHanlder 和 HttpMoudule 搭配使用達到更強大的功能. IHttpHandlerMSDN說明 您可以撰寫自訂的 HTTP 處理常式來處理特定的預先定義的任何 Common Language Specification (CLS) 標準的語言中的 HTTP 要求的類型。 可執行程式碼中定義HttpHandler類別，而不是傳統的 ASP 或 ASP.NET Web 網頁，這些特定的要求回應。 HTTP 處理常式提供您一種低層級的要求和回應服務的 IIS Web 伺服器互動，以及大部分 ISAPI 擴充程式類似，但使用簡單的程式設計模型提供的功能。 IHttpHandler是一個可以讓我們實現的介面裡面包含： 屬性: 1public bool IsReusable &#123; get; &#125; 取得值，指出另一個要求是否可以使用 IHttpHandler 執行個體。 方法: 1public void ProcessRequest(HttpContext context) 以實作 IHttpHandler 介面的自訂 HttpHandler 來啟用 HTTP Web 要求的處理。 IHttpModuleMSDN說明 Modules are called before and after the handler executes. Modules enable developers to intercept, participate in, or modify each individual request. Modules implement the IHttpModule interface, which is located in the System.Web namespace. 處理常式 (Handler) 在執行前後，會呼叫模組 (Module)。 模組可以讓開發人員攔截、參與或修改每個要求。 更印證了 如果把Http請求當作火車那 IHttpHandler是火車的終點 IHttpModule是沿路經過的站點 要查看有哪寫IHttpModule或IHttpHandler被註冊可以看applicationhost.config檔案 路徑：C:\Users[user]\Documents\IISExpress\config\applicationhost.config 自己建立一個 IHttpHandler在前面有說到每個Http請求的最終是為了給一個HttpHander來執行處理. 像我們常看到的 ASP.NET page (*.aspx) Web service (*.asmx) Generic Web (*.ashx) 甚至是MVC (MvcHandler)都是實現於IHttpHander介面 這邊介紹如果要如何建立自己HttpHander. Web.Config註冊上面撰寫的IHttpHandler我們要在Web.Config中設定我們撰寫的HttpHandler 這是一個範例: 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="HttpHandler_HttpModule.MyHttpHandler"/&gt; &lt;/handlers&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 把handlers加入在system.webServer結點中. 裡面有幾個Attribute verb：請求動作 GET,POST,PUT...如果是*代表全部請請動作都合用. path：請求那些副檔名會執行此HttpHandler type：註冊的HttpHandler類型. 其中最要注意的是type Attribute. 1&lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="(namespace).(classname)"/&gt; 最後我們就可以請求 http://xxxx/Mypage.cspx 來試試看我們的結果. 我們將請求*.cspx副檔名的所有請求都當作要透過CLR來執行. 自己建立一個 IHttpModule每個被註冊的HttpModule是Http請求必經之路. Asp.net MVC 是透過System.Web.Routing.UrlRoutingModule 這個HttpModule來完成切入的. 使用IHttpModule須完成幾個步驟: 建立一個類別實現IHttpModule Web.Config註冊上面撰寫的IHttpModule 建立一個類別實現IHttpModule這個範例會在頁面上顯示 IIS Pipeline Event的執行順序. public void Init(HttpApplication context) 把 HttpApplication 中的event做擴充. 1234567891011121314151617181920212223242526272829303132333435public class MyHttpModule:IHttpModule&#123; public void Init(HttpApplication context) &#123; context.BeginRequest += (sender, args) =&gt; ShowStep(sender, "BeginRequest"); context.AuthorizeRequest += (sender, args) =&gt; ShowStep(sender, "AuthorizeRequest"); context.PostResolveRequestCache += (sender, args) =&gt; ShowStep(sender, "PostResolveRequestCache"); context.MapRequestHandler += (sender, args) =&gt; ShowStep(sender, "MapRequestHandler"); context.AcquireRequestState += (sender, args) =&gt; ShowStep(sender, "AcquireRequestState"); context.PreRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PreRequestHandlerExecute"); //這中間執行IHttpHandler. context.PostRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PostRequestHandlerExecute"); context.EndRequest += (sender, args) =&gt; ShowStep(sender, "EndRequest"); context.PreSendRequestHeaders += (sender, args) =&gt; ShowStep(sender, "PreSendRequestHeaders"); &#125; private void ShowStep(object app,string eventName) &#123; var http = (HttpApplication)app; http.Response.Write($"Step &#123;eventName&#125;&lt;br/&gt;"); &#125; public void Dispose() &#123; &#125;&#125; Web.Config註冊上面撰寫的IHttpModule註冊方法和IHttpHander很類似,一樣在system.webServer節點下加入modules 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;modules&gt; &lt;add name="MyHttpModule" type="HttpHandler_HttpModule.MyHttpModule"/&gt; &lt;/modules&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 程式碼使用IHttpHandler須完成幾個步驟: 建立一個類別實現IHttpHander Web.Config註冊上面撰寫的IHttpHandler 建立一個類別實現IHttpHander繼承完IHttpHandler我們會實現兩個方法. ProcessRequest(HttpContext context) 執行此次請求動作. bool IsReusable { get; } 是否要將此次請求加入快取中重用. 123456789101112public class MyHttpHandler : IHttpHandler&#123; public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = "text/html"; context.Response.Write("==================&lt;br/&gt;"); context.Response.Write("Hello World&lt;br/&gt;"); context.Response.Write("==================&lt;br/&gt;"); &#125; public bool IsReusable &#123; get; &#125;&#125; ApplicationHost.config 設定擋前面有說到aspnet_isapi.dll會去判斷此次請求要怎麼處理,她會去讀取handlers註冊節點的對應表來判斷是否要透過CLR處理此次請求. IIS預設設定Module在哪邊?她是透過 ApplicationHost.config 來抓取，HttpHandler 和 HttpModule設定. 這邊分為兩個部分: IISIIS可借由HandlerMappings和Module來設置 HandlerMappings 可以看到有許多預設要處理的附檔名(.aspx,.svc)在裡面都可以看到. Module IIS預設幫忙載入許多Moudle我們自己客製化的Module也可以在這邊設定 IISExpress基本上IISExpress 全域 config 會放在這個路徑 C:\Users\%USERPROFILE%\Documents\IISExpress\config 如果VS版本高於2015以上執行Web專案時，會在每個專案上建立一個.vs資料夾並把ApplicationHost.config複製一份放到下面影片的路徑中 範例原始碼下載 小結今天我們學到 自己建立一個Httpmodule 自己建立一個Httphandler ApplicationHost.config設定擋和Httpmodule &amp; Httphandler關係且如何設定. 今天先丟一個問題給大家那，為什麼Asp.net可以依賴IHttphandler介面來完成請求這是怎麼實現的? 下篇我們會來回答上面的答案. 參考資料： HTTP Handlers and HTTP Modules Overview#Features) Implementing HTTPHandler and HTTPModule in ASP.NET 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day2/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(開賽)Http 請求 Asp.net IIS伺服器架構 (第1天)]]></title>
    <url>%2FIthelp-day1%2F</url>
    <content type="text"><![CDATA[Agenda 開賽前言： 為什麼想要選擇此主題 閱讀時建議事項 文章收穫 進入主題 瀏覽器請求IIS流程 如何辨別是否為靜態檔案? .Net CLR Httpmodule &amp; Httphandler 核心模組 W3WP應用程式 小結 開賽前言：三十篇文章架構基本遵循: 前言:前情提要，閱讀此文建議使用工具或知識. 標出大主題(大字體+錨點)之後在細項列出要說明的細節 小結：每篇都有一個小結快速總結今天重點 為什麼想要選擇此主題選擇這個主題主要原因是 沒有人整理一套較完整的Asp.net執行原始碼解析文章(從Http請求IIS Server,進入CLR前置動作),asp.net mvc原始碼解析 台灣大部分的文章都是分享如何使用，很少文章有介紹如何運作． 利用微軟開原後站在巨人肩膀上可以看更遠，理解MVC框架如何去設計具有一定的彈性. 了解核心運作流程，更好改善或擴充現有專案架構（讓系統變得更有條理） 閱讀時建議事項我在文章中會盡量寫出我看到精華部分,但此系列文可能對於MVC新手不太容易閱讀,因為MVC框架中運用到許多設計模式和OOP觀念(當初我在閱讀上也花了不少功夫) 個人覺得OOP有很重要一個點是盡量用物件和物件關聯，資料狀態轉移來了解程式碼. 簡白來說就是物件關聯和關係 文章收穫我希望大家在閱讀完所有文章後可以獲得 Http對於IIS Server請求如何導向Asp.net MVC執行 Asp.net MVC原始碼有基本了解和知道哪幾個重要類別,了解後能依照系統需要替換改寫. Asp.net MVC用到很多設計技巧(因為這是一個較大框架),希望大家能更了解設計模式如何運用在實戰中 閱讀第一個框架原始碼會花不少時間,了解一個大框架後在去看其他框架閱讀時間會越來越少 進入主題Asp.net基於.NET Framework框架所提供，開發Web應用程式的類別庫，封裝在System.Web.dll檔案中，提供使用者開發網頁，ASP.NET運行在安裝了.NET Framework的IIS(Internet Information Services)伺服器上 微軟大大近幾年也投入Open Source行列讓我們可以更方便來窺探，Asp.net運作原理. 這個連結 Reference Source 可以查看微軟核心的DLL程式碼(這個網站是我們第一階段追code的好朋友) Asp.net程式基本上是由IIS進行託管，介紹Asp.net MVC原始碼之前我們需要先了解Asp.net和IIS關係. 瀏覽器請求IIS流程Web基於Http協定，它是一個無狀態協定，每次請求都是新的且不會紀錄之前請求的東西下圖我畫出一個對於IIS請求基本會跑的流程圖. 基本分為兩個區塊 粉紅色是IIS Server領域 會有一個Http.sys的程式在監聽所有Http請求並交由W3WP.exe並透過aspnet_isapi來此次請求是否為靜態檔案. 藍色是.Net CLR領域由幾塊核心程式完成請求 ISAPIRunTime HttpRuntime HttpApplicationFactory HttpApplication 之後會陸續介紹他們. 請求靜態檔案透過路徑找尋靜態檔案並回傳. 請求非靜態檔案透過.Net CLR執行返回結果. 如何辨別是否為靜態檔案?如何辨別是否為靜態檔案,就需要談談HttpHandler的註冊表(後面有文章會說到) 基本上如果是請求Html,css,js…都會直接回傳不會在經過.Net CLR .Net CLR Httpmodule &amp; Httphandler 核心模組Asp.net所有應用程式都離不開兩個核心模組Httpmodule &amp; Httphandler且最終會找到一個繼承於IHttpHanlder物件來處理請求. 在網路上看到一個很好地比喻HttpModule &amp; HttpHandler Http請求像是一個旅客身上帶著行李拿著票來搭火車. HttpHandler 是火車的終點站. HttpModule 是火車中途停靠的各站. 這個比喻可以很清楚知道每個請求透過CLR就是要找到一個HttpHandler來執行. 圖片參考連結 W3WP應用程式當IIS在執行處理Http請求時工作管理員有一個w3wp應用程式在監聽. 此應用程式會依照aspnet_isapi模組來判斷此次請求是否走入.net CLR 小結今天我們了解到 瀏覽器請求IIS基本流程 Asp.net核心模組Httpmodule &amp; Httphandler IIS有一個Http.sys程式在監聽所有Http請求 IIS透過一個w3wp.exe初步過濾判斷如何執行此請求. 瀏覽器發出Http請求給IIS,IIS透過Http.sys來監聽請求並交給w3wp.exe這個應用程式來判斷是否要交由.net託管處理此次請求. 下篇我們會來詳細講述Httpmodule &amp; Httphandler 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day1/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net HttpHandler vs HttpModule 詳細解說.]]></title>
    <url>%2FHttpHandler-HttpModule%2F</url>
    <content type="text"><![CDATA[前言：Asp.net 是一個pipeline的模型 我覺得.Net Web工程師對於這個模型和IHttpHanlder,IHttpModule 要有基本的概念和理解. 理解這些管道除了可以讓我們節省許多不必要的資源浪費也可讓我們程式架構更加有條理. 就像我們在Asp.net MVC如果要寫權限驗證程式碼,雖然可以寫在Controller的Action中 但更好做法是我可以寫一個類別繼承AuthorizeAttribute並override OnAuthorization方法並掛上此標籤. 所以更了解這些原理可以讓我們寫程式事半功倍. Asp.net Application Event 生命週期前面我們知道Asp.net是一個請求處理響應的管道而這個管道中微軟有提供許多點可以讓我們進行客製化的擴充程式撰寫 事件可藉由IHttpModule來擴充註冊 Event事件名稱：官網列出可用事件很多，下面列出我有用過的幾個事件和其功用. BeginRequest AuthorizeRequest PostResolveRequestCache MapRequestHandler AcquireRequestState PreRequestHandlerExecute PostRequestHandlerExecute EndRequest 事件方法說明： BeginRequest: 已經啟動要求。如果要在要求前執行某個動作 (例如, 在每頁頁首顯示廣告橫幅), 請同步處理這個事件。 AuthorizeRequest: 您可以在內部使用這個事件, 以實作授權機制 (例如, 將存取控制清單 (ACL) 儲存在資料庫, 而非存入檔案系統)。您也可以覆寫這個事件, 但無此必要。 PostResolveRequestCache：當 ASP.NET 略過目前事件處理常式的執行並允許快取模組從快取中服務要求時發生。 MapRequestHandler：ASP.NET 基礎結構會使用事件來判斷目前要求的要求處理常式。 如需詳細資訊 AcquireRequestState: 工作階段狀態是擷取自狀態儲存區。如果要建置自已的狀態管理模組, 則可以同步處理這個事件, 以便從狀態儲存區擷取「工作階段」狀態。 PreRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之前產生。 在介於PreRequestHandlerExecute和PostRequestHandlerExecute事件之間會執行HttpHandler程式碼. PostRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之後產生。 EndRequest: 要求已完成。您可能想要建置偵錯模組, 以便收集要求的全部資訊, 然後再將資訊寫入網頁中。 IHttpHandler 和 IHttpModule 關係用一句話簡述IHttpHandler和IHttpModule 如果把Http請求當作火車那 IHttpHandler是火車的終點 IHttpModule是沿路經過的站點 IHttpHandler和IHttpModule關係如 Implementing HTTPHandler and HTTPModule in ASP.NET 文章提到 每個請求一定會通過所有被註冊的IHttpModule,而最終會執行一個IHttpHandler後進行返回. 我們常聽到的Asp.net Webform，MVC都是經過管道Module並執行相對應的Handler. 所以HttpHanlder 和 HttpMoudule 搭配使用達到更強大的功能. IHttpHandlerMSDN說明 您可以撰寫自訂的 HTTP 處理常式來處理特定的預先定義的任何 Common Language Specification (CLS) 標準的語言中的 HTTP 要求的類型。 可執行程式碼中定義HttpHandler類別，而不是傳統的 ASP 或 ASP.NET Web 網頁，這些特定的要求回應。 HTTP 處理常式提供您一種低層級的要求和回應服務的 IIS Web 伺服器互動，以及大部分 ISAPI 擴充程式類似，但使用簡單的程式設計模型提供的功能。 IHttpHandler是一個可以讓我們實現的介面裡面包含： 屬性: 1public bool IsReusable &#123; get; &#125; 取得值，指出另一個要求是否可以使用 IHttpHandler 執行個體。 方法: 1public void ProcessRequest(HttpContext context) 以實作 IHttpHandler 介面的自訂 HttpHandler 來啟用 HTTP Web 要求的處理。 IHttpModuleMSDN說明 Modules are called before and after the handler executes. Modules enable developers to intercept, participate in, or modify each individual request. Modules implement the IHttpModule interface, which is located in the System.Web namespace. 處理常式 (Handler) 在執行前後，會呼叫模組 (Module)。 模組可以讓開發人員攔截、參與或修改每個要求。 更印證了 如果把Http請求當作火車那 IHttpHandler是火車的終點 IHttpModule是沿路經過的站點 要查看有哪寫IHttpModule或IHttpHandler被註冊可以看applicationhost.config檔案 路徑：C:\Users[user]\Documents\IISExpress\config\applicationhost.config 自己建立一個 IHttpHandler在前面有說到每個Http請求的最終是為了給一個HttpHander來執行處理. 像我們常看到的 ASP.NET page (*.aspx) Web service (*.asmx) Generic Web (*.ashx) 甚至是MVC (MvcHandler)都是實現於IHttpHander介面 這邊介紹如果要如何建立自己HttpHander. 程式碼使用IHttpHandler須完成幾個步驟: 建立一個類別實現IHttpHander Web.Config註冊上面撰寫的IHttpHandler 建立一個類別實現IHttpHander繼承完IHttpHandler我們會實現兩個方法. ProcessRequest(HttpContext context) 執行此次請求動作. bool IsReusable { get; } 是否要將此次請求加入快取中重用. 123456789101112public class MyHttpHandler : IHttpHandler&#123; public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = "text/html"; context.Response.Write("==================&lt;br/&gt;"); context.Response.Write("Hello World&lt;br/&gt;"); context.Response.Write("==================&lt;br/&gt;"); &#125; public bool IsReusable &#123; get; &#125;&#125; Web.Config註冊上面撰寫的IHttpHandler我們要在Web.Config中設定我們撰寫的HttpHandler 這是一個範例: 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="HttpHandler_HttpModule.MyHttpHandler"/&gt; &lt;/handlers&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 把handlers加入在system.webServer結點中. 裡面有幾個Attribute verb：請求動作 GET,POST,PUT...如果是*代表全部請請動作都合用. path：請求那些副檔名會執行此HttpHandler type：註冊的HttpHandler類型. 其中最要注意的是type Attribute. 1&lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="(namespace).(classname)"/&gt; 最後我們就可以請求 http://xxxx/Mypage.cspx 來試試看我們的結果. 自己建立一個 IHttpModule每個被註冊的HttpModule是Http請求必經之路. Asp.net MVC 是透過System.Web.Routing.UrlRoutingModule 這個HttpModule來完成切入的. 使用IHttpModule須完成幾個步驟: 建立一個類別實現IHttpModule Web.Config註冊上面撰寫的IHttpModule 建立一個類別實現IHttpModule這個範例會在頁面上顯示 IIS Pipeline Event的執行順序. public void Init(HttpApplication context) 把 HttpApplication 中的event做擴充. 1234567891011121314151617181920212223242526272829303132333435public class MyHttpModule:IHttpModule&#123; public void Init(HttpApplication context) &#123; context.BeginRequest += (sender, args) =&gt; ShowStep(sender, "BeginRequest"); context.AuthorizeRequest += (sender, args) =&gt; ShowStep(sender, "AuthorizeRequest"); context.PostResolveRequestCache += (sender, args) =&gt; ShowStep(sender, "PostResolveRequestCache"); context.MapRequestHandler += (sender, args) =&gt; ShowStep(sender, "MapRequestHandler"); context.AcquireRequestState += (sender, args) =&gt; ShowStep(sender, "AcquireRequestState"); context.PreRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PreRequestHandlerExecute"); //這中間執行IHttpHandler. context.PostRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PostRequestHandlerExecute"); context.EndRequest += (sender, args) =&gt; ShowStep(sender, "EndRequest"); context.PreSendRequestHeaders += (sender, args) =&gt; ShowStep(sender, "PreSendRequestHeaders"); &#125; private void ShowStep(object app,string eventName) &#123; var http = (HttpApplication)app; http.Response.Write($"Step &#123;eventName&#125;&lt;br/&gt;"); &#125; public void Dispose() &#123; &#125;&#125; Web.Config註冊上面撰寫的IHttpModule註冊方法和IHttpHander很類似,一樣在system.webServer節點下加入modules 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;modules&gt; &lt;add name="MyHttpModule" type="HttpHandler_HttpModule.MyHttpModule"/&gt; &lt;/modules&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 範例原始碼下載 參考資料： https://docs.microsoft.com/en-us/previous-versions/aspnet/bb398986(v=vs.100)#Features https://support.microsoft.com/zh-tw/help/307985/info-asp-net-http-modules-and-http-handlers-overview https://www.codeproject.com/Articles/335968/Implementing-HTTPHandler-and-HTTPModule-in-ASP-NET 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/HttpHandler-HttpModule/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Asp.net</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>IHttpHanlder</tag>
        <tag>IHttpModule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[為什麼 Float和Double會有誤差 (浮點數儲存原理)]]></title>
    <url>%2FfloatVSDouble%2F</url>
    <content type="text"><![CDATA[前言：大家都知道float和double會有誤差 但原因是什麼呢? 今天就跟大家分享Float和Double會誤差的原因 一. 浮點數介紹 一開始先對於float和double做身家調查 浮點類型的範圍 類型 最小值 最大值 float 1.175494351 E – 38 3.402823466 E + 38 double 2.2250738585072014 E – 308 1.7976931348623158 E + 308 浮點類型 類型 有效數字 位元組數 float 6 – 7 4 double 15 – 16 8 二. 浮點數產生以float來說可以儲存4 byte = 32 bit 是說最多可以存32個 0 or 1 但 float 和 int都是 32 bit 使用方式卻完全不一樣 浮點數計算方式是由 IEEE 754 進位浮點數算術標準創立 他把浮點數分成三部分 Sign(符號), Exponent(指數), Mantissa(尾數) 來表示他的值** 表示方式 1111 1111 1111 1111 1111 1111 1111 1111 Sign(符號) 第1個 bit ​ (紅色) 0 = 正數 1 = 負數 Exponent(指數) 第2個 ~ 第9個 bit (藍色) 總共8 bit 最大值 255 (二進至值) 127 為中間值原點 Mantissa(尾數) 第10個 ~ 第32個 bit (棕色) 計算之後的尾數 到目前因該是有看沒有懂XD 等等帶個範例大家就會比較清楚了 三. 實例解說 後面看到 X 代表等待計算的值 12.5f 為例子 如何計算出 32 bit 如何儲存這個值? 判斷是正數還是負數決定Sign(符號) 因為12.5f是正數 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 計算Exponent(指數)​​ 將12.5f轉成二進制 12.5f = 1100.1 將數值底數變成 1&lt;底數&lt;2 1100.1​ = 1.1001 * 2 ^ 3 2^3 二的三次方就是 指數​要加的值 127 + 3 = 130 (1000 0010) *1011 1111 1XXX XXXX XXXX XXXX XXXX XXXX *0000 0001 1XXX XXXX XXXX XXXX XXXX XXXX *———————————————————————– *1100 0001 0XXX XXXX XXXX XXXX XXXX XXXX Mantissa(尾數)​ 計算​ 最後將 1.1001 小數點後的值 .1001追加到(指數​)後面 ​1100 0001 0000 0000 0000 0000 0000 0000 ​​ + 0000 0000 0100 1000 0000 0000 0000 0000 ​ ————————————————————— 0100 0001 0100 1000 0000 0000 0000 0000 所以我們可以得出 12.5f 在 32bit 中是 0100 0001 0100 1000 0000 0000 0000 0000 這裡有個工具 Float (IEEE754 Single precision 32-bit) 可以方便我們來驗算值是否正確 他很貼心幫我們列出 Sign(符號), Exponent(指數), Mantissa(尾數) 位置給我們對應 四,為什麼會不精準現在我們知道計算 Exponent(指數)​​ 需要將值轉成二進制 ,但如果是12.53f 轉成二進制會變成這樣1100.100000111100111....... 極限值就會和原本的值出現誤差 如圖 我們可以看到 12.53f 其實會變成 1.252999973297119140625E1 這就是float不準確的原因 float介紹完了 double和float概念一樣只是儲存空間更大而已^^ 小結因為為了節省空間浮點數 使用特別儲存方式來節省空間,有一好沒兩好這樣就少了精準度 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/floatVSDouble/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>float</tag>
        <tag>double</tag>
        <tag>number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gaps and Islands problem (SQL) 連續範圍]]></title>
    <url>%2FSQL-Gaps-and-Islands-problem%2F</url>
    <content type="text"><![CDATA[前言：SO 發現蠻多人有遇到 Gaps and Islands problem count of last continuous inserted records based on date 之前有跟大家分享過 解決連續範圍的思路 [SQL連續範圍] 數字，日期連續範圍 今天針對發問者實際例子來一步步 解決問題… 提問出處:count of last continuous inserted records based on date 問題說明:提問者希望可以獲得最近一次連續日期的次數 例如: user_id | point | DateTime 1 | 10 | 18-08-2018 17:15 2 | 10 | 01-08-2018 17:15 1 | 10 | 21-08-2018 17:15 1 | 10 | 22-08-2018 17:15 2 | 10 | 26-08-2018 17:15 1 | 10 | 25-08-2018 17:15 2 | 10 | 27-08-2018 17:15 1 | 10 | 26-08-2018 17:15 1 | 10 | 27-08-2018 17:15 有6筆資料是user_id = 1 希望取得user_id = 1最後一次連續日期數量是3 因為 這三筆是最近連續日期 27-08-2018 26-08-2018 25-08-2018 解決思路整理:連續資料有個特性就是一組(連續範圍數值) - (基於某個條件順序產稱的數值) 結果是一樣的 user_id 分群 並加上編號 因為要基於日期找尋連續日期,所以使用一個小技巧 先找尋每個 user_id最小天數 (最大天數也可) ,之後使用datediff函數取得差一天數來當數值 我會使用sql-server來解說(因為支援window function) XD 範例說明:基於某個條件順序產稱的數值 :先在子查詢中取得每個user_id最小日期,以便後面使用datediff函數取得間隔天數(產生編號) 1MIN(DateTime) over(partition by user_id order by DateTime ) 連續範圍數值 : 我使用 Row_number 和 Window function 依照每個使用者給編號. 1Row_number() over(partition by user_id order by DateTime) 之後使用diffdate函數 並將兩值相減取得 1234567891011SELECT DateTime,datediff(day, MIN(DateTime) over(partition by user_id order by DateTime ),DateTime) - Row_number() over(partition by user_id order by DateTime)rnFROM Table1Where user_id = 1 | DateTime | rn ||----------------------|----|| 2018-08-18T17:15:00Z | -1 || 2018-08-21T17:15:00Z | 1 || 2018-08-22T17:15:00Z | 1 || 2018-08-25T17:15:00Z | 3 || 2018-08-26T17:15:00Z | 3 || 2018-08-27T17:15:00Z | 3 | 我們可以看到連續日期的分組已經出來了 有了這個連續編號 我們就可以直接取得我們要的結果了 123456789;with cte as ( SELECT DateTime,datediff(day, MIN(DateTime) over(partition by user_id order by DateTime ),DateTime) - Row_number() over(partition by user_id order by DateTime)rn FROM Table1 Where user_id = 1 )SELECT TOP 1 count(*) cntFROM ctegroup by rnORDER BY MAX(DateTime) desc 因為只要取得最近一筆連續日期資料 我們可以 ORDER BY MAX(DateTime)且使用TOP 1來取得最新一筆的連續數量 SQLFiddle 小結:使用window function後, 語法整個變得很簡單.(有興趣可以進SO連結看沒有使用window function的解法 露露長) 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/SQL-Gaps-and-Islands-problem/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MSSQL</tag>
        <tag>MySQL</tag>
        <tag>Postgresql</tag>
        <tag>SQL-Gaps-and-Islands-problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[State Pattern(狀態者模式)]]></title>
    <url>%2FStatusPattern%2F</url>
    <content type="text"><![CDATA[前言：狀態者模式 優勢在可將複雜的物件狀態條件,以物件方式來減少條件式的判斷程式 可由物件自身的狀態，決定之後的動作行為. 狀態者模式 說明：需求簡易流程如下 這是一個簡單的訂單流程圖 我們可看到從建立訂單開始-&gt;最後判斷成功或取消訂單 看似簡單但需要寫一定程度的判斷條件式,而且也要做一定程度的逆向流程防呆. 這裡先貼上 未使用狀態者模式的程式碼: PaymentContext.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class PaymentContext&#123; Product _Item &#123; get; set; &#125; PayStatus _status &#123; get; set; &#125; public PaymentContext(Product p) &#123; _Item = p; _status = PayStatus.Init; &#125; /// &lt;summary&gt; /// 設置狀態 /// &lt;/summary&gt; /// &lt;param name="status"&gt;&lt;/param&gt; public string SetStatus(PayStatus status) &#123; string result = $"修改成功&#123;status.ToString()&#125;"; switch (_status) &#123; case PayStatus.Init: if (status == PayStatus.Init) result = "請勿重新建立訂單"; else _status = status; break; case PayStatus.Success: result = "訂單成功請勿修改"; break; case PayStatus.Cancel: result = "訂單取消請勿修改"; break; case PayStatus.Processing: if (status == PayStatus.Init) result = "請勿重新建立訂單"; else _status = status; break; &#125; return result; &#125; /// &lt;summary&gt; /// 跑流程 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string RunProcess() &#123; switch (_status) &#123; case PayStatus.Init: _status = PayStatus.Processing; return "交易建立中..."; case PayStatus.Success: return "交易完成"; case PayStatus.Cancel: return "交易取消完成"; case PayStatus.Processing: if (_Item.Price &gt; 300) &#123; _status = PayStatus.Cancel; return "物件超過300元 交易取消中"; &#125; _status = PayStatus.Success; return "交易中請稍後"; &#125; return "不在狀態內"; &#125;&#125; 裡面有SetStatus 和 RunProcess 方法 RunProcess 方法 就是將商品一個往下一個流程推進 SetStatus 方法 可以改變商品狀態 上面類別中的程式碼 目前有點小複雜但還算簡單,但等日後需求越來越多 後人一直把程式碼寫入Switch case 或if ... else 中就會導致程式碼越來越複雜 這個情境我們可以嘗試使用 State Pattern(狀態者模式) 幫助我們將每個自身狀態封裝到物件裡面,由每個狀態來決定後面動作 我們可發現 每個流程都可以使用 RunningProcee 和 SetSatus 這兩個動作 就可開出一個抽象類別,裡面有這兩個抽象方法,給之後的狀態子類去實現. 1234567public abstract class PaymentSatusBase&#123; protected PaymentGate _gate; public abstract string Running(Product p); public abstract string SetSatus(PayStatus s);&#125; PaymentGate 是給外部呼叫端使用的類別,我們可比較上面之前PaymentContext類別可看到if....else 全部不見了, 因為狀態封裝到各個類別中了 1234567891011121314151617181920212223242526272829303132public class PaymentGate&#123; Product _product; internal PaymentSatusBase CurrnetProceess &#123; get; set; &#125; // 這裡擁有下個流程的引用 public PaymentGate(Product p) &#123; _product = p; CurrnetProceess = new InitSatus(this); &#125; internal PayStatus CurrnetStatus &#123; get; set; &#125; /// &lt;summary&gt; /// 設置狀態 /// &lt;/summary&gt; /// &lt;param name="status"&gt;&lt;/param&gt; public string SetStatus(PayStatus status) &#123; return CurrnetProceess.SetSatus(status); &#125; /// &lt;summary&gt; /// 跑流程 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string RunProcess() &#123; return CurrnetProceess.Running(_product); &#125;&#125; 如何新建一個流程物件? 首先我們需要先取得當前使用者使用的 PaymentGate引用並傳入建構子當作參數 實現Running和SetStatus方法,並將此狀態的邏輯寫上 執行完後需要更改下個流程,可以將值賦予給CurrnetProceess 屬性 1234567891011121314151617181920212223242526272829public class ProcessSatus : PaymentSatusBase&#123; public ProcessSatus(PaymentGate g) &#123; _gate = g; &#125; public override string Running(Product p) &#123; string result = "交易中請稍後"; if (p.Price &gt; 300) &#123; result = "物件超過300元 交易取消中"; _gate.CurrnetProceess = new CancelSatus(_gate); &#125; else _gate.CurrnetProceess = new SuccessSatus(_gate); return result; &#125; public override string SetSatus(PayStatus s) &#123; string result = string.Empty; if (s == PayStatus.Init) result = "請勿重新建立訂單"; return result; &#125;&#125; 說明:以流程進行中為例子. 他會判斷商品使用超過300元,來決定下個流程 所以我們就把這個邏輯寫在此類中. 另外後面幾個流程比照辦理一一搬入類別中 12345678910111213141516171819202122232425262728293031323334353637383940public class CancelSatus : PaymentSatusBase&#123; public CancelSatus(PaymentGate g) &#123; _gate = g; &#125; public override string Running(Product p) &#123; return "交易取消完成"; &#125; public override string SetSatus(PayStatus s) &#123; string result = string.Empty; if (s == PayStatus.Init) result = "訂單取消請勿修改"; return result; &#125;&#125;public class SuccessSatus : PaymentSatusBase&#123; public SuccessSatus(PaymentGate g) &#123; _gate = g; &#125; public override string Running(Product p) &#123; return "交易完成"; &#125; public override string SetSatus(PayStatus s) &#123; string result = string.Empty; if (s == PayStatus.Init) result = "訂單成功請勿修改"; return result; &#125;&#125; 最後外部程式使用如下 12345678910Product p = new Product();p.Name = "電腦";p.Price = 300000;PaymentGate context = new PaymentGate(p);Console.WriteLine(context.RunProcess());Console.WriteLine(context.RunProcess());Console.WriteLine(context.RunProcess());context.SetStatus(PayStatus.Init);Console.WriteLine(context.RunProcess()); 程式碼放在github上 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/StatusPattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>StatePattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[發布自己的Nuget專案]]></title>
    <url>%2FDeploy-OwnNuget%2F</url>
    <content type="text"><![CDATA[前言：前陣子在被面試官說：我有電子發票開源專案，是否有上到Nuget上 我回答:沒有. 我就突然想到我也可以把我的專案放到Nuget上讓更多人方便使用 我就查詢資料去了解整個上板流程,並打成文章跟大家分享 下載Nuget Commandline Tool下載Nuget Commandline Tool 之後你會取得 nuget.exe 這個檔案 把它放到你要打包Nuget的專案資料夾中 之後打開cmd 並在專案資料夾打上 nuget spce 之後在你資料夾中會出現 xxxx.nuspec的XML檔案,這個檔案是描述你要打包的專案 123456789101112131415161718&lt;code class="language-xml"&gt;&lt;?xml version="1.0"?&gt;&lt;package &gt; &lt;metadata&gt; &lt;id&gt;&lt;/id&gt; &lt;version&gt;&lt;/version&gt; &lt;title&gt;&lt;/title&gt; &lt;authors&gt;&lt;/authors&gt; &lt;owners&gt;&lt;/owners&gt; &lt;licenseUrl&gt;&lt;/licenseUrl&gt; &lt;projectUrl&gt;&lt;/projectUrl&gt; &lt;iconUrl&gt;&lt;/iconUrl&gt; &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt; &lt;description&gt;This is a AOP framework&lt;/description&gt; &lt;releaseNotes&gt;Summary of changes made in this release of the package.&lt;/releaseNotes&gt; &lt;copyright&gt;Copyright 2018&lt;/copyright&gt; &lt;tags&gt;c# AOP&lt;/tags&gt; &lt;/metadata&gt;&lt;/package&gt; 必填欄位 ID：不區分大小寫的套件識別碼，在整個 nuget.org 或套件所在的任何組件庫中都必須是唯一的。 識別碼可能不包含對 URL 而言無效的空格或字元，而且通常會遵循 .NET 命名空間規則。 如需指導方針，請參閱選擇唯一的套件識別碼。 Version：套件版本，遵循 major.minor.patch 模式。 版本號碼可以包含預先發行版本的後置詞，如套件版本控制中所述。 Description：UI 顯示中的套件詳細描述。 Authors：以逗號分隔的套件作者清單，與 nuget.org 上的設定檔名稱相符。這些名稱會顯示在 nuget.org 的 NuGet 組件庫中，並用來交互參照相同作者的其他套件。 打包Nuget填完資料後就可以回到commandline 並打另一個指令nuget pack將專案打包成 xxx.nupkg 檔案 以提供上傳 之後申辦一個Nuget帳號,並產生一個API Key 產生完後在上面的選單選擇 Upload 按鈕 之後按下Browse按鈕並上傳你的 xxxx.nupkg檔案,上傳完畢後就按下Submit按鈕 將此專案提交上去 上傳完畢後Nuget他會審核你的專案,等審核完後大家就可以下載使用你的專案摟^^ 石頭已經打包專案這兩個是我已經發布的專案 AwesomeProxy.Net ElectronicInvoice_TW Note如果要查nuget指令可以打 nuget ? 參考連結：.nuspec 參考 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Deploy-OwnNuget/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Nuget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(AutoMapper)反射自動註冊AutoMapper Profile]]></title>
    <url>%2FAutoMapperInit%2F</url>
    <content type="text"><![CDATA[前言：AutoMapper 幫我我們方便管理物件跟物件之間屬性值格式轉換 模型轉換這裡有兩個類別 UserInfoModel 當作我們從DB撈取出來 模型資料 123456public class UserInfoModel&#123; public int RowId &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; UserInfoViewModel 是呈現在UI或其他地方的模型 其中 Detail欄位由 UserInfoModel的 Name和 Age屬性組成的 1234public class UserInfoViewModel&#123; public string Detail &#123; get; set; &#125;&#125; 這時我們就會引用 AutoMapper 幫我們統一管理轉換模型上的問題 建立一個Profile設置UserInfoModel對於 UserInfoViewModel之前的欄位轉換 123456789public class UserInfoProfile : Profile&#123; public UserInfoProfile() &#123; CreateMap&lt;UserInfoModel, UserInfoViewModel&gt;() .ForMember(t =&gt; t.Detail, s =&gt; s.MapFrom(_ =&gt; $"DetailInfo:&#123;_.Name&#125; &#123;_.Age&#125;")); &#125;&#125; 而我們在註冊時會呼叫 AddProfile方法 1Mapper.Initialize(x =&gt; x.AddProfile&lt;UserInfoProfile&gt;()); 但每次新加Profile這邊都需要設置新的Profile，我們就會想有沒有方法可以讓他自動註冊？ 我們可以使用反射來完成 反射自動註冊AutoMapper Profile此程式我使用我的 ExtenionTool 1234567var profiles = Assembly.GetExecutingAssembly() .GetInstancesByAssembly&lt;Profile&gt;();foreach (var profile in profiles)&#123; Mapper.Initialize(x =&gt; x.AddProfile(profile));&#125; 上面程式碼很簡單清晰，呼叫 取得目前組件所有的 Profile物件實體並且加到Profile中，我們將上面程式碼在初始化執行一次 1234567public static IEnumerable&lt;TResult&gt; GetInstancesByAssembly&lt;TResult&gt;(this Assembly ass)&#123; return ass.GetTypes() .Where(x =&gt; typeof(TResult).IsAssignableFrom(x) &amp;&amp; x.IsNormalClass()) .Select(x =&gt; Activator.CreateInstance(x)) .Cast&lt;TResult&gt;();&#125; 核心程式使用Linq 動態取得你所需的類型並使用反射創建 之後我們就可以不用在手動把Profile加至AutoMapper容器中了 Source Code 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/AutoMapperInit/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Automapper</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediatorPattern(中介者模式)]]></title>
    <url>%2FMediator-Pattern%2F</url>
    <content type="text"><![CDATA[說明系統模塊存在很多複雜的耦合問題，很適合使用中介者模式來解耦合 在現實中如果組織有一定規模可能構通如下圖那般複雜 如果有一個人或組織負責幫大家協助溝通，就可解決上面複雜問題 這就是我們這次的核心中介者 中介者模式有幾個角色 AbstractMediator (抽像中介者)：定義中介者和各個同事者之間的通信的介面 ConcreteMediator (中介者)：知道每個同事物件，實現抽像中介者，負責協調和各個具體的同事的交互關係 AbstractColleague (抽象同事者)：定義同事者和中介者通信的接口 ConcreteColleague (同事者)：實現自己的業務，並且實現抽象方法，跟中介者進行通信 中介者模式特點是 中介者知道所有同事者物件，但同事者互相不知道對方存在需透過中介者傳遞訊息 如何傳遞和通知各個同事者由中介者內部決定 在裡面第二點是很重要的目標，把傳遞訊息的邏輯封裝在中介者裡面 程式碼1234567891011121314public class ProductManager&#123; public DBAdmin DbAdmin &#123; get; set; &#125; public Programer Programer &#123; get; set; &#125; internal void Send(string message, OriginReqBase req) &#123; //如果是DBAdmin傳遞訊息由Programer執行,反之 if (req.GetType() == typeof(DBAdmin)) Programer.DoProcess(message); else if(req.GetType() == typeof(Programer)) DbAdmin.DoProcess(message); &#125;&#125; 傳遞通知或訊息邏輯寫在Send方法裡面. 本次範例依照傳入的型別,如果是DBAdmin傳遞訊息由Programer執行,反之 1234567891011121314public abstract class OriginReqBase&#123; protected ProductManager _productManager; protected OriginReqBase(ProductManager productManager) &#123; _productManager = productManager; &#125; public virtual void Requirement(string message) &#123; _productManager.Send(message, this); &#125;&#125; OriginReqBase(抽象同事者) 因為每個角色 (ConcreteColleague) 都需要知道中介者存在，所以把參數設定在建構子上。 Requirement方法通知 PM 中介者將資料傳遞出去 12345678910111213141516171819202122232425public class Programer : OriginReqBase&#123; public void DoProcess(string message) &#123; Console.WriteLine($"Programer: &#123;message&#125;"); &#125; public Programer(ProductManager productManager) : base(productManager) &#123; &#125;&#125;public class DBAdmin : OriginReqBase&#123; public void DoProcess(string message) &#123; Console.WriteLine($"DBA:&#123;message&#125;"); &#125; public DBAdmin(ProductManager productManager) : base(productManager) &#123; &#125;&#125; DoProcess 方法 PM 中介者呼叫使用 1234567891011ProductManager pm = new ProductManager();DBAdmin DBA1 = new DBAdmin(pm); //DBA知道PM存在Programer RD1 = new Programer(pm); //RD知道PM存在pm.Programer = RD1; //PM知道DBApm.DbAdmin = DBA1; //PM知道RD//現在DBA和RD只需要傳訊息就可將訊息轉到需要知道的人RD1.Requirement("DB modify Requestment.");DBA1.Requirement("DB Process doing."); 有三大重點 DBA和RD(同事者) 知道PM(中介者)存在 PM(中介者)知道DBA和RD(同事者)存在 ㄋDBA和RD不用知道對方存在但卻可以互相傳遞訊息(因為PM已經幫助我們解耦合了) UML圖 (有標示相對應的角色關係) 我看來這個解耦合核心思想跟容器有點像，因為需要做溝通或通知時我們統一只需要轉交給中介者會幫助我們處理溝通事宜 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Mediator-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>MediatorPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己Blog系列(三) Hexo next theme 介紹]]></title>
    <url>%2Fhexo-blog-theme%2F</url>
    <content type="text"><![CDATA[前言：為何我會選用Hxeo來當作Blog框架? 有下面幾個原因: 因為建立於本地端，所以可以更方便離線進行編輯 使用 Markdown 語法撰寫Blog，更方便、通用、容易上手 搭配線上CICD工具部署於 Github 上，完全零成本 中文文件資源多 支援多樣不同樣板，可隨心所欲切換風格 開源社群活躍 基於NodeJs擁有豐富的差件 建立自己的Hexo安裝 Node.js首先先安裝 Node.js 官網下載安裝 安裝完後使用CMD node -v \npm -v 查看是否安裝成功. 安裝 Hexo-cli使用 npm 來安裝 hexo (須先安裝 Node.js) npm install hexo-cli -g 因為我們之前就有建立一個Code Blog Repository. 我們使用CMD 的 CD 命令進入此資料夾目錄中 在使用hexo cli幫助我們快速建立Blog相關檔案 hexo init blog # 初始化 blog npm install # 安裝相關套件 如果要把Hexo deploy到Github上面，需要先安裝 npm install hexo-deployer-git –save Hexo config.yml 設定說明Hexo 是使用yml檔案格式來當設定檔. hexo init blog # 初始化 blog 資料夾檔案結構如下圖： 當在Blog Code Repository 中建立完Hexo資料檔後會有一個_config.yml檔案,就是Hexo的設定檔案. 解說 config.yml 設定檔預設頁面：title: 石頭的coding之路 #網站標題 subtitle: description: 好點子沒價值，有價值的是把好點子實現 #網站描述 keywords: author: Daniel Shih #您的名字 language: zh-tw #語系 timezone: #時差 # Header menu: Home: / Archives: /archives About: /about.html Tags: /tags Categories: /categories 路由設定：# URL url: https://isdaniel.github.io/ #網站的網址 root: / #網站的根目錄 permalink: :year/:month/:day/:title/ permalink_defaults: 資料檔設定：# Directory source_dir: source #原始檔案資料夾，這個資料夾用於存放您的內容 預設值 source public_dir: public #使用Hexo g 產生靜態檔案資料夾名稱 tag_dir: tags #標籤資料夾名稱 archive_dir: archives #彙整資料夾名稱 category_dir: categories #分類資料夾名稱 code_dir: downloads/code i18n_dir: :lang #語言資料夾名稱 skip_render: 文章設定new_post_name: :title.md #新文章的檔案名稱 default_layout: post #預設佈局資料夾 titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: 配置index2 generatorindex2_generator: per_page: 10 order_by: -date include: - category Web exclude: - tag Hexo Hexo 時間格式# Date / Time format ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD #日期格式 time_format: HH:mm:ss #時間格式 Hexo 主題設定# Extensions theme: next #使用主題名稱, 設為 false 表示關閉主題功能 發佈資料設定# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git #發佈使用版控類別 使用git repo: https://github.com/isdaniel/isdaniel.github.io.git #發佈到哪個Repository branch: master #發佈使用的分支 社群資料設定：# Social Accounts instagram_url: https://www.instagram.com/dn_shih/ github_url: https://github.com/isdaniel email_url: dog830228@gmail.com 設定檔可以參考我的_config.yml檔案 或是也可以參考官網 Hexo推薦Theme [Next]Hexo有眾多Theme可以選擇，我們要切換使用的Theme只需要做幾個步驟. 在網路上尋到想要使用的Hexo Theme. 把資料檔放在/themes/資料夾目錄下. 這次想要跟大家介紹我使用的Next Theme，我會使用原因如下 擁有眾多開源者貢獻 畫面乾淨又整潔 在Hexo使用Next 我們把上面的Next Theme clone一份下來.https://github.com/theme-next/hexo-theme-next.git 在/themes/ 建立一個 next 資料夾並把Next Theme所有檔案copy進去. 修改Hexo _config.yml檔案，把theme改成next Hexo推薦插件下面是我推薦大家使用的Hexo插件，使用說明我就不一一跟大家解釋了網路上很多分享文. theme-next-reading-progress 閱讀進度. hexo-symbols-count-time 閱讀次數 hexo-generator-index2 頁面分類 hexo-related-popular-posts 熱門文章 hexo-addlink 在文章最末添加永久鏈接及版權聲明 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/hexo-blog-theme/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Blog</tag>
        <tag>Github</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle [CONNECT BY]]]></title>
    <url>%2FOracle-CONNECT-BY%2F</url>
    <content type="text"><![CDATA[之前有介紹 (SQL Server) CTE RECURSIVE (遞迴)製作月曆 在Oracle 有提供一個精簡的語法產生階層資料 CONNECT BY CONNECT BY 有幾個常用Key Word. LEVEL目前在樹節點第幾階層 START WITH 設定哪筆做為起始點開始樹 PRIOR用於指定父資料欄位 製造出的階層樹，概念如下 [圖來自Oracle] 範例一建立連續數字 1~10 &lt;code class=&quot;language-sql&quot;&gt;SELECT X + LEVEL FROM ( SELECT 0 X FROM DUAL ) CONNECT BY LEVEL &lt;= 10 此範例使用 LEVEL 在 CONNECT BY 上當條件 建立列值到LEVEL 大於等於 10 sqlfiddle 範例二建立日曆表 &lt;code class=&quot;language-sql&quot;&gt;SELECT startDt + LEVEL - 1 FROM ( SELECT sysdate endDt, (sysdate -10) startDt FROM DUAL )t1 CONNECT BY startDt - endDt + LEVEL &lt;= 0 一開始有兩個欄位 StartDt 起始時間(10天前) EndDt 最後時間(現在時間) 期望建立一個結果集從10天前日期到現在，一樣是使用LEVEL在當Offset的時間 範例三CONNECT BY 最強大的地方是在於建立階層表 樣本資料： CREATE TABLE HierarchyDemo ( PartNo INT, NAME VARCHAR2(16), ParentPartNo INT ); INSERT INTO HierarchyDemo VALUES(1,&apos;Boss&apos;,0); INSERT INTO HierarchyDemo VALUES(2,&apos;Jack&apos;,1); INSERT INTO HierarchyDemo VALUES(3,&apos;TOM&apos;,2); INSERT INTO HierarchyDemo VALUES(4,&apos;AMY&apos;,3); INSERT INTO HierarchyDemo VALUES(5,&apos;Daniel&apos;,2); SQL腳本： SELECT t1.*,LEVEL FROM HierarchyDemo t1 START WITH ParentPartNo = 0 CONNECT BY PRIOR PartNo = ParentPartNo START WITH ParentPartNo = 0 設置為起始點，開始找尋建立子階級 PRIOR PartNo 代表下一次由PartNo當作根結點 找尋 PartNo = ParentPartNo 的列 最後變成下圖 | PARTNO | NAME | PARENTPARTNO | LEVEL | |--------|--------|--------------|-------| | 1 | Boss | 0 | 1 | | 2 | Jack | 1 | 2 | | 3 | TOM | 2 | 3 | | 4 | AMY | 3 | 4 | | 5 | Daniel | 2 | 3 | 參考資料：Oracle Hierarchical Queries 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Oracle-CONNECT-BY/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autofac + Interceptors(AOP) 動態代理]]></title>
    <url>%2FAutofac-AOP%2F</url>
    <content type="text"><![CDATA[Autofac 是個IOC容器 不懂IOC 參考 我之前寫的IOC(控制反轉)，DI(依賴注入) 深入淺出~~ 小弟之前有一個開源框架【C#】 AOP輕型框架 AwesomeProxy.Net 介紹使用 裡面簡單介紹 AOP核心概念和如何實作! Autofac 有寫一個 Autofac.Extras.DynamicProxy 把AOP和IOC容器融合的框架 在Autofac使用AOP 需要實現下面幾個步驟 本次範例我們從資料庫中撈取時間資料出來，並使用Thread.Sleep(5000)作出延遲，判斷時間是否前後一致。 第一步（定義攔截器）：我們撰寫一個快取的攔截器繼承IInterceptor 介面，並實現Intercep方法 其中 IInvocation參數有許多有用的資料 Arguments：傳入方法中的參數 InvocationTarget ：被代理物件 MethodInvocationTarget：被代理物件的呼叫方法資訊 Proxy：代理物件 Method：代理的呼叫方法資訊 ReturnValue：呼叫方法的回傳值 這幾個欄位是我們比較常用的資訊 public class TimeInterceptor : IInterceptor { private ITimeService _timeService; public TimeInterceptor(ITimeService s) { _timeService = s; } public void Intercept(IInvocation invocation) { var time = CallContext.GetData(&quot;time&quot;)?.ToString(); if (time == null) { //如果沒有快取 執行呼叫Service invocation.Proceed(); CallContext.SetData(&quot;time&quot;, invocation.ReturnValue); } else { //如果有快取直接取值 invocation.ReturnValue = time; } } } 他使用到 TimeService 模擬從資料庫中撈取資料出來 public interface ITimeService { string GetTime(); } public class TimeService : ITimeService { public string GetTime() { return DateTime.Now.ToString(&quot;MM/dd/yyyy hh:mm:ss&quot;); } } 第二步（標記攔截器）：使用Intercept標籤並帶入要攔截類別型態． [Intercept(typeof(TimeInterceptor))] public class Person : IPerson { public string SaySomething() { return DateTime.Now.ToLongTimeString(); } } public interface IPerson { string SaySomething(); } 第三步（註冊攔截器到容器中）：這邊有兩個小細節 如果是註冊介面使用EnableInterfaceInterceptors，註冊一般類別使用EnableClassInterceptors 註冊攔截器入容器 因為這個範例使用所以我們要呼叫EnableInterfaceInterceptors var builder = new ContainerBuilder(); builder.RegisterType&lt;TimeInterceptor&gt;(); //註冊攔截器 builder.RegisterType&lt;Person&gt;() .As&lt;IPerson&gt;() .EnableInterfaceInterceptors(); //註冊時間Service builder.RegisterType&lt;TimeService&gt;().As&lt;ITimeService&gt;(); return builder.Build(); 原始碼連結 小結Autofac + DynamicProxy 有一個很大優勢，是可以把要注入的抽象動作一起注入攔截器中 例如本次範例我們將ITimeService使用建構子注入法，注入至TimeInterceptor攔截器中 讓系統和寫法擁有更多更多的彈性 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Autofac-AOP/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IOC</tag>
        <tag>Autofac</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[樣板模式(TemplatePattern)]]></title>
    <url>%2FTemplate-Pattern%2F</url>
    <content type="text"><![CDATA[前言：如果目前場景遇到一定流程階段，但流程內容依照邏輯或情境不同也有所不一樣. 這時可以考慮使用樣板模式(TemplatePattern) 生活舉例：因為十二年國教，所以基本上每個人都有上學的經驗 每天上學最少要經歷下面過程(我做一些簡化) 到學校=&gt;上午上課=&gt;吃午餐=&gt;下午上課=&gt;放學回家 可以看到不管是國小、國中、高中 至少都有上述的過程 但每個過程內容可能會依照年級階段不同，也有所不一樣 例如： 吃中餐：高中可能是吃便當，但國小是吃營養午餐，雖然都是吃飯但內容不一樣。 上午上課：都是教數學，但高中教微積分，國小教加減乘除。 重點:流程雖一樣但細部邏輯交由學校去實施實現 常見例子：我們常見的測試框架 MSTest,NUnit..... 都有樣板模式的思想。 一般來說測試框架都有生命週期，只是每個框架命名不一樣但核心原理差不多 SetUpClass (每個測試類別只都執行一次) SetUpUnitTest (每次執行測試方法時都執行一次) UnitTest (執行測試方法) 如下圖 (圖片來自網路上) 程式碼範例：此範例使用Console來模擬單元測試框架流程： 建立一個 UnitFlowBase 抽像類別，裡面有三個方法 SetUpClass (每個測試類別只都執行一次) SetUpUnitTest (每次執行測試方法時都執行一次) UnitTest (執行測試方法) 此抽象類別提供3個Hock讓子類實做細節。 UnitFlowBase只提供框架 public abstract class UnitFlowBase { protected UnitFlowBase() { SetUpClass(); } protected virtual void SetUpClass() { } protected virtual void SetUpUnitTest() { } protected abstract bool Execute(); public void UnitTest() { SetUpUnitTest(); Console.WriteLine(Execute() ? &quot;Assert Successful.&quot; : &quot;Assert Fail.&quot;); } } 建立另一個類別UnitCounter 實現那三個方法 特別是Execute方法 我顯示目前 ClassCount 跟 MethodCount 執行次數 public class UnitCounter : UnitFlowBase { private int _classCounter = 0; private int _methodCounter = 0; protected override void SetUpClass() { _classCounter++; } protected override void SetUpUnitTest() { _methodCounter++; } protected override bool Execute() { Console.WriteLine($&quot;ClassCounter : {_classCounter}&quot;); Console.WriteLine($&quot;MethodCounter: { _methodCounter}&quot;); return true; } } 呼叫實我們建立一個UnitCounter類別，但執行三次UnitTest方法 class Program { static void Main(string[] args) { UnitCounter unitMock = new UnitCounter(); unitMock.UnitTest(); unitMock.UnitTest(); unitMock.UnitTest(); Console.ReadKey(); } } 執行結果如下圖： 雖然執行3次 UnitTest 方法 但 ClassCounter 值卻一直是1而 MethodCounter 會依照執行幾次就加幾次. 小結:日後測試程式只需關注我們需要如何實現邏輯細解（重寫三個方法），核心流程順序就交由UnitFlowBase決定。 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Template-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>TemplatePattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autofac (IOC)容器介紹]]></title>
    <url>%2FAutofac-introduce%2F</url>
    <content type="text"><![CDATA[前言：市面上有許多IoC容器 Ninject,Unity…. 雖然容器眾多但要解決的問題和概念是一樣 今天使用Autofac 介紹一下IoC容器 不了解 IoC 概念可參考 我之前寫 IOC(控制反轉)，DI(依賴注入) 深入淺出~~ Autofac是一個 Ioc 容器眼尖的讀者會發現我把Ioc跟容器這兩個字使用兩個不同顏色 原因是Autofac這個框架其實做到兩個概念. IoC(Inversion of Control) 管理物件的容器 Autofac框架幫我們實現可以管理物件生命週期並提供依賴注入相對應的物件中 為何使用Autofac在我們專案中?我們先來看看在專案中常使用的撰寫方式,我們需要讀取使用者資料 透過UserDao來幫我們完成. public UserService { private UserDao _userDao = new UserDao(); public UserModel GetUserById(string Id){ return _userDao.GetUserById(Id); } } _userDao物件跟依賴UserService，導致兩個狀況 UserDao物件掌控於 UserService,假如有其他類別也使用UserDao物件各自掌控UserDao物件,這導致許多不必要的資源浪費. 日後要替換讀取 GetUserById方式(從db改讀成其他地方 如API) 需要異動全部有建立UserDao的類別 我們可以使用IoC容器解決上面兩個問題 使用Autofac 容器一般容器有多種注入方式：建構子注入，屬性注入，參數注入 按照以下四個步驟 簡單使用Autofac 建立ContainerBuilder物件 註冊型別(可限制創建物件生命週期) 建立IContainer 取得我們需要的物件. 此範例使用建構子注入方式 //1.建立ContainerBuilder物件 ContainerBuilder builder = new ContainerBuilder(); //2.註冊型別(可限制創建物件生命週期) builder.RegisterType&lt;UserDao&gt;().As&lt;IUser&gt;(); //3.建立IContainer IContainer container = builder.Build(); //4.使用IContainer取得我們需要的物件. IUser user = container.Resolve&lt;IUser&gt;(); 我們新建一個IUser來給UserDao繼承當作解耦合點(介面可利於日後替換使用) public interface IUser{ UserModel GetUserById(string Id); } public UserService { private IUser _userDao; public UserService(IUser userdao){ _userDao = userdao; } public UserModel GetUserById(string Id){ return _userDao.GetUserById(Id); } } 可能還感受不到IoC容器威力，因為目前依賴的複雜度還沒有太大 目前模組依賴關係 如下UML圖 模組複雜程度像下圖 如果沒有容器幫我們做物件控制管理,想想就覺得可怕 ** 上圖是我Inovce SDK框架的UML圖 其中我們可以發現 ApiBase這個抽象類別 依賴於 IConfig介面(日後可能依賴更多其他物件或介面) ContainerBuilder builder = new ContainerBuilder(); builder.RegisterType&lt;AppsettingConfig&gt;().As&lt;IConfig&gt;().InstancePerRequest(); builder.RegisterGeneric(typeof(ApiBase&lt;&gt;)).PropertiesAutowired(); builder.RegisterType&lt;InvoiceApiFactory&gt;().InstancePerRequest(); 如果使用Autofac我們可不用擔心這些 只需要將被依賴的物件,介面註冊到容器中，剩下配對注入動作容器都會幫我們達成 已上面的例子來說：我只需要用 InvoiceApiFactory產生繼承ApiBase&lt;&gt;物件，使用IConfig將會被容器自動注入其中。 Autofac 常用三種注射方式. Constructor injection Property injection Method injection constructor injection Property injection Method injection 小結：系統越來越複雜越能表現IoC容器的優勢，如果系統沒那麼複雜其實也不一定要使用他﹐看情境如何 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Autofac-introduce/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IOC</tag>
        <tag>Autofac</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[橋接模式(BridgePattern)]]></title>
    <url>%2FBridge-Pattern%2F</url>
    <content type="text"><![CDATA[前言：目的：如果有兩大類模組是多對多的組合，如本次Smaple Code. Nick和Addidas 包包都有紅、藍、黃….或其他顏色 就可能呈現下面6種組合 Nick(紅) Nick(藍) Nick(黃) Addidas(紅) Addidas(藍) Addidas(黃) 如果此建立類別的話 可能情況如下面的UNL圖 類別數量 = 顏色數量 * 包包品牌數量 這樣會有兩個問題 隨著品牌和顏色增多，包包類別數量急速增長 (X = m*n)個 顏色我們可看做一個抽象 不應當和包包合在一起 其中的第二點我覺得最重要 這時候就很適合帶入我們的主角BridgePattern 範例介紹關係變成下圖UML 我們可以看到BagBsae去引用ColorBase 可以看到我們所需的子類別變成五個而已,重點是類別關係變得更有條理了，顏色和包包分開可調整性更大。 OOP有一個很重要的設計觀念 盡量用組合取代繼承，因為繼承耦合性遠大於組合！ 因為子類別繼承父類別，子類別無條件都擁有protect已上的方法或成員資料.這就會造成一個耦合性(使用繼承須看情況)，而A類別對於B類別進行組合就可達到繼承效果但不造成像繼承般的強耦合. 我們的背包一樣可擁有多種顏色，但耦合度跟類別關係變得更清晰了。 程式碼解說建立 BagBase 類別並將 ColorBase 當建構傳入(因為Bag需要上顏色) public abstract class BagBase { protected ColorBase color{ get; set; } public BagBase(ColorBase color) { this.color = color; } public abstract void GetBag(); } public abstract class ColorBase { public abstract string Color(); } 這邊我只介紹一種顏色和包包來當作範例,因為其他概念都一樣 public class AdidasBag : BagBase { public AdidasBag(ColorBase color) : base(color) { } public override void GetBag() { Console.WriteLine($&quot;It is Addidas Bag,Color is {color.Color()}&quot;); } } class ColorBlue : ColorBase { public override string Color() { return &quot;Blue&quot;; } } 建立 AdidasBag類別重載GetBag方法 ColorBlue類別重載Color方法 因為BagBase要傳入顏色GetBag就可幫包包上色. 使用如下外面看起來很合理乾淨. class Program { static void Main(string[] args) { AdidasBag nick = new AdidasBag(new ColorBlue()); nick.GetBag(); Console.ReadKey(); } } 實際案例前陣子在做一個Unity2D遊戲，遇到一組遊戲邏輯 一個人物要移動有分兩種移動方式 自動移動 玩家手動點擊移動 因為是2D遊戲 有 上下左右 四個方位移動,四個方位配上兩個移動方式,人物會有不一樣的移動邏輯. 這邊我貼上部分程式碼 建立一個 RoadActionBase裡面有三個必要屬性需要給 上下左右 實現 ArrowType 2D人物移動箭頭方向 OffSetPos 移動距離 PlayerDirction 這是一個Unity2D座標屬性 public abstract class RoadActionBase{ protected int _level; public RoadActionBase() { _level = SenceParamter.RoadCount; } public abstract ArrowType ArrowType { get; } public abstract int OffSetPos { get; } public abstract Vector2 PlayerDirction { get; } } UpRoadAction類別對於往上時的狀態做給值 public class UpRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Up; } } public override int OffSetPos { get { return -_level; } } public override Vector2 PlayerDirction { get { return Vector2.up; } } } DownRoadAction類別對於往下時的狀態做給值 public class DownRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Down; } } public override int OffSetPos { get { return _level; } } public override Vector2 PlayerDirction { get { return Vector2.down; } } } RightRoadAction類別對於往右時的狀態做給值 public class RightRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Right; } } public override int OffSetPos { get { return 1; } } public override Vector2 PlayerDirction { get { return Vector2.right; } } } LeftRoadAction類別對於往左時的狀態做給值 public class LeftRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Left; } } public override int OffSetPos { get { return -1; } } public override Vector2 PlayerDirction { get { return Vector2.left; } } } 建立一個 MoveBase 並將 RoadActionBase當作建構子傳入(內部邏輯有寫注解). 重點在於一個 IsWalkNext方法 提供Hock給子類別做實現,因為手動和自動移動邏輯不一樣. /// &lt;summary&gt; /// 橋接模式 /// &lt;/summary&gt; public abstract class MoveBase { protected PlayerController _player; protected int _level; protected float _Scape; public RoadActionBase RoadAction { get; protected set; } public MoveBase(RoadActionBase roadAction) { _player = PlayerController.Instance; _level = SenceParamter.RoadCount; _Scape = SenceParamter.Scape + SenceParamter.RoadHeigh; RoadAction = roadAction; } public virtual void Move(RoadContext currentRoad, RoadContext nextRoad) { //取得下一個位置 Vector2 nextPos = nextRoad.transform.localPosition; if (IsWalkNext(currentRoad, nextRoad, _player.targetPos, nextPos)) { //將下一個資料塞給當前玩家 _player.targetPos = nextPos; _player.RoadContext = nextRoad; _player.moveDirction = RoadAction.PlayerDirction; currentRoad.SetIsWalk(true); //加入等待轉換的地方 ReloadRoadController.Instance.AddRoadContext(currentRoad); } } protected abstract bool IsWalkNext(RoadContext currentRoad, RoadContext nextRoad, Vector3 targetPos, Vector3 nextPos); } TouchMove 類別重載 IsWalkNext實現自己的邏輯 public class TouchMove : MoveBase { public TouchMove(RoadActionBase roadAction) : base(roadAction) { } /// &lt;summary&gt; /// 判斷是否可以 前往下一個目標 /// &lt;/summary&gt; /// &lt;param name=&quot;currentRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetPos&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextPos&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override bool IsWalkNext(RoadContext currentRoad, RoadContext nextRoad, Vector3 targetPos, Vector3 nextPos) { ArrowType arrowType = RoadAction.ArrowType; //1.下一個道路要可以進去 //2.當前道路要可以出來 //3.必須為四周的道路 return arrowType.CanWalk(currentRoad.CanWalkOut) &amp;&amp; arrowType.CanWalk(nextRoad.CanWalkIn) &amp;&amp; CanMoveNextPos(targetPos, nextPos); } private bool CanMoveNextPos(Vector3 targetPos, Vector3 nextPos) { return ((int)Vector2.Distance(targetPos, nextPos)) % ((int)_Scape) == 0; } } AutoMove 類別重載 IsWalkNext實現自己的邏輯 public class AutoMove : MoveBase { public AutoMove(RoadActionBase roadAction) : base(roadAction) { } /// &lt;summary&gt; /// 判斷是否可以 前往下一個目標 /// &lt;/summary&gt; /// &lt;param name=&quot;currentRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetPos&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextPos&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override bool IsWalkNext(RoadContext currentRoad, RoadContext nextRoad, Vector3 targetPos, Vector3 nextPos) { //1.下一個道路要可以進去 //2.當前道路要可以出來 //3.必須為四周的道路 //4.步數必須大於0 return currentRoad.CurrentArrow.CanWalk(nextRoad.CanWalkIn) &amp;&amp; currentRoad.CurrentArrow.CanWalk(currentRoad.CanWalkOut) &amp;&amp; CanMoveNextPos(targetPos, nextPos) &amp;&amp; !nextRoad.IsChangeState &amp;&amp; GameModel.Step &gt;0; } private bool CanMoveNextPos(Vector3 targetPos, Vector3 nextPos) { return ((int)Vector2.Distance(targetPos, nextPos)) % ((int)_Scape) == 0; } } 上面程式碼最主要是跟大家分享移動方式和方位的關係,上下左右值和方位式固定,將此配上不同的移動方式有不一樣的邏輯. SourceCode 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Bridge-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>BridgePattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沒有Source Code 如何修改程式??]]></title>
    <url>%2FNoSourceCode-ModifyCode%2F</url>
    <content type="text"><![CDATA[前言：某些專案因為歷史久遠沒有Source Code,但有個需求需要異動裡面的程式該怎麼辦?? 難道只能整個反組譯,查看程式碼翻一份做新的嗎? 不~~其實有辦法直接對於DLL進行修改 只需使用 Reflexil 搭配 ILSpy 或其他支援的反組譯​軟體 Reflexil 是一個組譯編輯器插件目前支援 Reflector, ILSpy 和 Telerik’s JustDecompile. 下載連結 Reflexil **Release 2.2 搭配 ILSpy version 3.2 前置動作，安裝Reflexil 下載下載 reflexil.for.ILSpy.2.2.bin.zip，不用下載AIO 作者有說 ILSpy version 3.2 (ILSpy 4 is not currently compatible with Reflexil, given the use of System.Reflection.Metadata, deprecating Mono.Cecil usage) ILSpy 4當前版本 ILSpy.2.2 並不支援 ILSpy 3.2 下載 下載完後就把全部的DLL放在同一個資料夾下,並開啟 ILSpy.exe 按下上方的齒輪UI 就可獲得下方藍色的Reflexil 修改框框. 組件修改需求目前組件 有個ClassA 類別,裡面有一個prop1屬性 型態是string, 我們希望在這新增另一個屬性 使用滑鼠右鍵點擊類別ClassA,我們可以看到很多方式可以注入新的程式碼 在這我們選擇inject property. 我們需要修改的是 Item Name (使用屬性的名稱) Property Type(使用屬性類別) 選擇完後按下OK,我們就會發現prop2新屬性會出現在ClassA中. 新增完後不代表已經將修改儲存!! 我們需要點選組件，之後再按下Save AS 把本次修改儲存 日後我們就可以使用新的屬性在我們程式中了!! 小結此插件還可以新增,插入許多東西時屬非常強大,有興趣的玩家可再自行深入琢磨. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/NoSourceCode-ModifyCode/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Reflection</tag>
        <tag>Decompile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(SQL Server)Dynamic pivot 動態樞紐分析]]></title>
    <url>%2FDynamic-pivot%2F</url>
    <content type="text"><![CDATA[前言：之前有和大家分享使用CASE WHEN 搭配聚合函數實現樞紐分析 但今天如果我們要轉換成行的列希望是動態依照目前資料庫的欄位要處理呢? 我們可以使用Dynamic pivot Dynamic pivot核心概念其實是把我們要使用的pivot SQL`語法動態產生出來 程式碼CREATE TABLE T( userName VARCHAR(100), Price int, Dt DATE ); INSERT INTO T VALUES (&apos;Tom&apos;,100,&apos;2017-01-01&apos;); INSERT INTO T VALUES (&apos;Amy&apos;,200,&apos;2017-01-02&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,1311,&apos;2017-01-03&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,122,&apos;2017-03-01&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,111,&apos;2017-04-01&apos;); INSERT INTO T VALUES (&apos;Amy&apos;,232,&apos;2017-05-01&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,2312,&apos;2017-05-02&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,23,&apos;2017-05-03&apos;); DECLARE @cols AS NVARCHAR(MAX), @query AS NVARCHAR(MAX); SET @SQL = STUFF((SELECT distinct &apos;,SUM(CASE WHEN Dt = &apos;&apos;&apos;+ CAST(Dt AS VARCHAR(10)) +&apos;&apos;&apos; THEN Price ELSE 0 END) AS &apos; + QUOTENAME(Dt) FROM T FOR XML PATH(&apos;&apos;), TYPE).value(&apos;.&apos;, &apos;NVARCHAR(MAX)&apos;) ,1,1,&apos;&apos;); SET @query = &apos;SELECT userName,&apos;+@cols+&apos; FROM T GROUP BY userName&apos; ; EXECUTE sp_executesql @query 因為範例我們使用 SQL SERVER 所以使用 FOR XML PATH 語法將我們 CASE WHEN pivot SQL 語法產生並把他附值給 @cols 變數 SET @cols = STUFF((SELECT distinct &apos;,SUM(CASE WHEN Dt = &apos;&apos;&apos;+ CAST(Dt AS VARCHAR(10)) +&apos;&apos;&apos; THEN Price ELSE 0 END) AS &apos; + QUOTENAME(Dt) FROM T FOR XML PATH(&apos;&apos;), TYPE).value(&apos;.&apos;, &apos;NVARCHAR(MAX)&apos;) ,1,1,&apos;&apos;) 因為Dt行會有重複的值,所以 distinct 來過濾 會產生如下的SQL語法 ,SUM(CASE WHEN Dt = &apos;2017-01-01&apos; THEN Price ELSE 0 END) AS [2017-01-01],SUM(CASE WHEN Dt = &apos;2017-01-02&apos; THEN Price ELSE 0 END) AS [2017-01-02],SUM(CASE WHEN Dt = &apos;2017-01-03&apos; THEN Price ELSE 0 END) AS [2017-01-03],SUM(CASE WHEN Dt = &apos;2017-03-01&apos; THEN Price ELSE 0 END) AS [2017-03-01],SUM(CASE WHEN Dt = &apos;2017-04-01&apos; THEN Price ELSE 0 END) AS [2017-04-01],SUM(CASE WHEN Dt = &apos;2017-05-01&apos; THEN Price ELSE 0 END) AS [2017-05-01],SUM(CASE WHEN Dt = &apos;2017-05-02&apos; THEN Price ELSE 0 END) AS [2017-05-02],SUM(CASE WHEN Dt = &apos;2017-05-03&apos; THEN Price ELSE 0 END) AS [2017-05-03] 在使用 STUFF 將第一個 , 給移除掉 sqlfiddle 最後在把要使用的表和前面組的Pivot query串起來. SET @cols = STUFF((SELECT distinct &apos;,SUM(CASE WHEN Dt = &apos;&apos;&apos;+ CAST(Dt AS VARCHAR(10)) +&apos;&apos;&apos; THEN Price ELSE 0 END) AS &apos; + QUOTENAME(Dt) FROM T FOR XML PATH(&apos;&apos;), TYPE).value(&apos;.&apos;, &apos;NVARCHAR(MAX)&apos;) ,1,1,&apos;&apos;); SET @query = &apos;SELECT userName,&apos;+@cols+&apos; FROM T GROUP BY userName&apos; ; SELECT @query; 最後產生： SELECT userName, SUM(CASE WHEN Dt = &apos;2017-01-01&apos; THEN Price ELSE 0 END) AS [2017-01-01], SUM(CASE WHEN Dt = &apos;2017-01-02&apos; THEN Price ELSE 0 END) AS [2017-01-02], SUM(CASE WHEN Dt = &apos;2017-01-03&apos; THEN Price ELSE 0 END) AS [2017-01-03], SUM(CASE WHEN Dt = &apos;2017-03-01&apos; THEN Price ELSE 0 END) AS [2017-03-01], SUM(CASE WHEN Dt = &apos;2017-04-01&apos; THEN Price ELSE 0 END) AS [2017-04-01], SUM(CASE WHEN Dt = &apos;2017-05-01&apos; THEN Price ELSE 0 END) AS [2017-05-01], SUM(CASE WHEN Dt = &apos;2017-05-02&apos; THEN Price ELSE 0 END) AS [2017-05-02], SUM(CASE WHEN Dt = &apos;2017-05-03&apos; THEN Price ELSE 0 END) AS [2017-05-03] FROM T GROUP BY userName 有了上面CASE WHEN pivot SQL 語法,最後只需把剩下要用到Table sql語句給組出來在使用 EXECUTE sp_executesql 動態呼叫SQL語法 sqlfiddle 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Dynamic-pivot/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Dynamic-Pivot</tag>
        <tag>Pivot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ (三) Fanout 交換器]]></title>
    <url>%2FRabbitMQ-Fanout%2F</url>
    <content type="text"><![CDATA[前言：本篇範例使用Fanout 交換器 實現RabbitMQ 在RabbitMQ中有很重要兩個角色，Producer和Consumer，下面這個範例使用c# console來實現 Producer一開始我們宣告一個 ConnectionFactory 並設置RabbitMQ Server連接參數 UserName 使用者帳號 Password 使用者密碼 HostName 連接FQDN或IP RabbitMQ預設密碼是 guest //建立連接工廠 ConnectionFactory factory = new ConnectionFactory { UserName = &quot;guest&quot;, Password = &quot;guest&quot;, HostName = &quot;localhost&quot; }; 呼叫factory.CreateConnection 建立連接RabbitMQ連接物件，並呼叫 CreateModel方法建立一個channel Model using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { //建立一個Queue channel.QueueDeclare(queueName, false, false, false, null); //建立一個Exchange channel.ExchangeDeclare(exchangeName, ExchangeType.Fanout, false, false, null); channel.QueueBind(queueName,exchangeName,routeKey); Console.WriteLine(&quot;\nRabbitMQ連接成功,如需離開請按下Escape鍵&quot;); string input = string.Empty; do { input = Console.ReadLine(); var sendBytes = Encoding.UTF8.GetBytes(input); //發布訊息到RabbitMQ Server channel.BasicPublish(exchangeName, routeKey, null, sendBytes); } while (Console.ReadKey().Key != ConsoleKey.Escape); } 最後在使用 channel.BasicPublish方法 將訊息推送給指定交換器，因為是走tcp所以將訊息轉換成二進制流 Consumer前面建立連接都大同小異 ConnectionFactory factory = new ConnectionFactory { UserName = &quot;guest&quot;, Password = &quot;guest&quot;, HostName = &quot;localhost&quot; }; string exchangeName = &quot;exchangeFanout&quot;; string queueName = &quot;FanoutQueue&quot;; string routeKey = string.Empty; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { channel.QueueBind(queueName, exchangeName, routeKey); //綁定一個消費者 EventingBasicConsumer consumer = new EventingBasicConsumer(channel); //接收到消息事件 consumer.Received += (ch, ea) =&gt; { var message = Encoding.UTF8.GetString(ea.Body); Console.WriteLine($&quot;Queue:{queueName}收到資料： {message}&quot;); channel.BasicAck(ea.DeliveryTag, false); }; channel.BasicConsume(queueName, true, consumer); Console.ReadKey(); } 值得一提的是 EventingBasicConsumer這個類別有一個建構子函數，把 channel 物件傳入產生一個消費者 EventingBasicConsumer consumer = new EventingBasicConsumer(channel); 在呼叫 EventingBasicConsumer.Received綁定接收訊息事件， 第一個參數是channel物件本身 第二個參數是 Message(訊息) 資訊 裡面有一個Body欄位可取得 傳送的二進制流資料 Demo為了簡單演示範例 我讓使用者輸入一個數字來跑迴圈，Producer 會把數字傳給Exchange並平均分配給所有consumer 本次有兩個 consumer 等待接收資訊，我們可以看到Fanout交換器不用指定RouteKey且把訊息平均分配到consumer上 程式碼: using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { //建立一個Queue channel.QueueDeclare(queueName, false, false, false, null); //建立一個Exchange channel.ExchangeDeclare(exchangeName, ExchangeType.Fanout, false, false, null); channel.QueueBind(queueName,exchangeName,routeKey); Console.WriteLine(&quot;\nRabbitMQ連接成功,如需離開請按下Escape鍵&quot;); Console.WriteLine(&quot;請輸入要傳輸的次數&quot;); string input = Console.ReadLine(); int times = 0; int.TryParse(input, out times); for (int i = 1; i &lt;= times; i++) { var sendBytes = Encoding.UTF8.GetBytes(i.ToString()); //發布訊息到RabbitMQ Server channel.BasicPublish(exchangeName, routeKey, null, sendBytes); } Console.WriteLine(); } 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/RabbitMQ-Fanout/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>RabbitMQ</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己Blog系列(二) github Setting]]></title>
    <url>%2Fhexo-github-setting%2F</url>
    <content type="text"><![CDATA[在Github這邊要先建立兩個Repository Blog Code Blog Hosting Blog Code這個Repository是利用Hexo cli樣板來撰寫Blog. 像我目前使用的MyBlog 建立完自己的Code Repository後. 將他clone到自己電腦上面. 執行下面幾個步驟 打開此Repository資料夾 打開CMD並進入此資料夾 利用NodeJS NPM 打 npm install hexo -g 就會開始下載 執行完第三步後再打Hexo init指令,安裝看建立Hexo將檔案. Blog Hosting在建立另一個Repository來當html blog靜態託管使用. 就像石頭使用isdaniel.github.io 執行下面幾個步驟 建立一個Repository 名子要取為 [username].github.io，其中的[username]是您Github帳號. 進入此Repository中，並進入Setting 確認是否已經成功將此Repository Hosting在你的Github page上如果成功呈現此圖 我們可以嘗試在這個Hosting Repository建立一個index.html 在上面打Hello would並commit push 在訪問https://[username].github.io/應該就可以看到Hello Would文字. 建立自己Blog系列(一) 介紹 Github (hosting) + Hexo (Blog) + Appveyor(CICD) 建立自己Blog系列(三) Hexo next theme 介紹 建立自己Blog系列(四) Appveyor 介紹 yaml. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/hexo-github-setting/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Blog</tag>
        <tag>Github</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己Blog系列(一) 介紹 Github (hosting) + Hexo (Blog) + Appveyor(CICD)]]></title>
    <url>%2Fgithub-hexo-appveyor%2F</url>
    <content type="text"><![CDATA[前文：網路上已經有許多Blog託管平台 例如:Google Blog，痞客邦….為何我還要自己寫這篇跟大家分享? 因為上面提供的平台固然好用，但我並無法100%的去修改我想要的樣式或版面. 如果我想要有100%彈性修改我的Blog我就必須建立自己的網站. 但要給別人Hosting需要另外花一筆費用… 就有本次系列文 Github (hosting) + Hexo (Blog) + Appveyor(CICD)． 這個搭配有幾個優點： 完全免費 使用MarkDown撰寫Blog就是爽. 練習使用CICD線上工具. 撰寫發布流程大概如下圖 流程解說： 使用Hexo樣板撰寫MarkDown Blog 寫完後commit和push至Github Blog Code Repository Appveyor(CI)線上工具會偵測到我們有code commit並執行後續Blog佈版動作 使用Hexo-cli將MarkDown build成html靜態檔案(因為github page只能Hosting靜態頁面) Appveyor(CI) commit並push到hosting Repository. 此流程的優點是只需在Code Repository上撰寫完Blog並commit就可以自動發佈到github page上. GitHub (Hosting)GitHub並創建一個名為username.github.io Repository，其中username是您在GitHub上的用戶名（或組織名稱）。 例如我的Github帳戶是isdaniel 就建立一個Repository 叫isdaniel.github.io 只要裡面有版控Html靜態頁面Github page 就可幫我們進行託管. https://isdaniel.github.io/ 這個網站的進入點在此Repository的index.html頁面. Note : GitHub有個設定，就是每個專案的gh-pages分支可以通過user-domain /項目名來訪問。 詳細資料 Hexo (Blog)Hexo 是一個快速、簡單且強大的網誌框架。Hexo 使用 Markdown（或其他渲染引擎）解析您的文章，並在幾秒鐘內，透過漂亮的主題產生靜態檔案 透過Hexo-cli可以簡單速建立一個blog page,而且Hexo社群活躍且文件支援中文. Hexo提供豐富的插件程式來給使用者,甚至您如果懂Js css Html也可建立自己的Blog樣式或自行擴充. Appveyor(CICD)appveyor是一個支援Winodws&amp;Linux相關的持續部屬服務 目前免費使用，可透過Github綁定Repository快速建立一套屬於自己的CICD流程. 小結這篇跟大家簡單介紹一下會使用到的工具和撰寫blog佈署流程. 日後會有其他篇文章來詳細說明細節. 建立自己Blog系列(二) github Setting 建立自己Blog系列(三) Hexo next theme 介紹 建立自己Blog系列(四) Appveyor 介紹 yaml. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/github-hexo-appveyor/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Blog</tag>
        <tag>Github</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#)委託delegate,Func,Action 解說系列(三)]]></title>
    <url>%2Fc-func-3%2F</url>
    <content type="text"><![CDATA[前文：在Func和Action泛型委託中 有 In , Out 兩個關鍵字 那到底是神麼意思呢? 讓我們一起看下去…. //Action delegate public delegate void Action&lt;in T&gt;(T obj); //fun delegate public delegate TResult Func&lt;in T, out TResult&gt;(T arg); 上面程式碼我列出Action和Func 委派方法各其中一個重載 我們可以發現到泛型中有關鍵字 in 和 out 這是代表神麼意思呢? 讓我們繼續看下去….. 解說：分享前先探討一個問題 泛型是否可以父類別指向子類別 public interface IGeneric&lt;T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //無法執行父類只向子類別 因為泛型預設是Invariance b = a; Console.ReadKey(); } } 上面範例程式很清楚知道無法編譯，那我要怎麼處理和解決的？ 第一種解法 使用 AS : public interface IGeneric&lt;T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //使用AS來轉型 b = a as IGeneric&lt;object&gt;; Console.ReadKey(); } } 第二種解法 在interface的泛型中使用 Out (今天要介紹的主角) //這裡使用out將T 解釋為Covariance public interface IGeneric&lt;out T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //在上面的泛型用out b = a; Console.ReadKey(); } } 三個重要名詞 Covariance，Contravariance，InvarianceMSDN中有解釋 此關鍵字 泛型中的共變數和反變數 Covariance(共變數) ： MSDN說明：可讓您使用比原本指定更多衍生的類型。您可以將 IEnumerable (在 Visual Basic 中為 IEnumerable(Of Derived)) 的執行個體指派給 IEnumerable 類型的變數簡單說明：泛型支援父類指向子類別 [泛型中使用out ] (支援泛型介面或泛型委派)如下面的範例: 因IGeneric&lt;out T&gt;所以下面a付值給b就不需轉型 //這裡使用out將T 解釋為Covariance public interface IGeneric&lt;out T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //在上面的泛型用out b = a; Console.ReadKey(); } } Contravariance(反變數) MSDN說明：可讓您使用比原本所指定更泛型 (較少衍生) 的類型。您可以將 IEnumerable (在 Visual Basic 中為 IEnumerable(Of Base)) 的執行個體指派給IEnumerable 類型的變數。 簡單說明：可將父類物件引用賦予給子類別 [泛型中有in]如下範例： 因IComparer&lt;in T&gt; 所以子類可以取得父類的引用 //這裡使用in將T 解釋為Contravariance public interface IGeneric&lt;in T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public abstract class Shape { public virtual double Area { get { return 0; } } } public class Square : Shape { private double r; public Square(double radius) { r = radius; } public double Radius { get { return r; } } public override double Area { get { return r * r; } } } public class Circle : Shape { private double r; public Circle(double radius) { r = radius; } public double Radius { get { return r; } } public override double Area { get { return Math.PI * r * r; } } } public class ShapeAreaComparer : IComparer&lt;Shape&gt; { int IComparer&lt;Shape&gt;.Compare(Shape a, Shape b) { if (a == null) return b == null ? 0 : -1; return b == null ? 1 : a.Area.CompareTo(b.Area); } } class Program { static void Main(string[] args) { //泛型[形狀類別(基類)] IGeneric&lt;Shape&gt; b = new Base&lt;Shape&gt;(); //泛型[圓形類別(子類)] IGeneric&lt;Circle&gt; a = new Base&lt;Circle&gt;(); //子類可以取得父類引用 a = b; Console.ReadKey(); } } Invariance 只能該類別指向該類別一般泛型預設就是這個 總結：Func 泛型委派的最後一個泛型類型參數會指定委派簽章中的傳回值類型 Covariance (共變數) (out 關鍵字) 泛型支援父類指向子類別 Contravariant (反變數) (in 關鍵字) 泛型子類可以取得父類的引用 Invariance 一般泛型預設就是這個 泛型中的共變數和反變數.aspx) out (generic modifier) (C# Reference) 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/c-func-3/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Delegate</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Func</tag>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#) 委託delegate,Func,Action 解說系列(二)]]></title>
    <url>%2Fc-func-2%2F</url>
    <content type="text"><![CDATA[前文：這個文章和大家分享解說 Func&lt;&gt;和Action&lt;&gt; 最後帶著大家來實現自己的Linq Where 先來看 Func&lt;&gt; ，Action&lt;&gt;原始定義 我們發現Func&lt;&gt; ，Action&lt;&gt; 其實本質就是委託 ，雖然有十幾個重載 但大同小異 public delegate TResult Func&lt;out TResult&gt;(); public delegate void Action&lt;in T&gt;(T obj); Func固定最後一個泛型參數為方法回傳值，其餘是傳入參數 public delegate TResult Func&lt;in T, out TResult&gt;(T arg); 解說Func：宣告一個Func&lt;Person,string&gt;委託 _thunkCheckAge_thunkCheckAge委託指向CheckAge方法執行_thunkCheckAge委託 (執行CheckAge方法) public class Person { public int Age { get; set; } public string Name { get; set; } } /// &lt;summary&gt; /// 年紀超過10歲算老人 /// &lt;/summary&gt; /// &lt;param name=&quot;person&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string CheckAge(Person person) { string result = &quot;年紀剛剛好&quot;; if (person.Age &gt;= 10) { result = &quot;老人&quot;; } return result; } static void Main(string[] args) { //Init一個Person物件 Person p = new Person() { Age = 10, Name = &quot;tom&quot; }; #region Func //宣告一個Func&lt;Person,string&gt;委託 _thunkCheckAge Func&lt;Person, string&gt; _thunkCheckAge; //_thunkCheckAge委託指向CheckAge方法 _thunkCheckAge = new Func&lt;Person, string&gt;(CheckAge); //執行_thunkCheckAge委託 (執行CheckAge方法) string result = _thunkCheckAge(p); //最後將結果顯示出來 Console.WriteLine(result); #endregion Console.ReadKey(); } 解說 Action：Action這個委託是Void，傳入參數型態是由泛型來決定 public delegate void Action&lt;in T&gt;(T obj); 宣告一個Action&lt;Person&gt;委託的 _thunkPerson物件將CallPersonInfo方法 賦予給_thunkPerson執行_thunkPerson (就是執行CallPersonInfo方法) public class Person { public int Age { get; set; } public string Name { get; set; } } static void Main(string[] args) { //宣告_thunkPerson為Action&lt;Person&gt;委託 //此Action傳入參數是Person由泛型來決定 Action&lt;Person&gt; _thunkPerson; //Init一個Person物件 Person p = new Person() { Age = 10, Name = &quot;tom&quot; }; //將CallPersonInfo方法 賦予給_thunkPerson _thunkPerson = new Action&lt;Person&gt;(CallPersonInfo); //執行_thunkPerson (就是執行CallPersonInfo方法) _thunkPerson(p); Console.ReadKey(); } public static void CallPersonInfo(Person person) { Console.WriteLine($&quot;Age:{person.Age} Name:{person.Name}&quot;); } 小總結：Action和Func差別是 Action是void不回傳值得委託 Func是有回傳值得委託 有了以上的基礎，我們就來實現我們自己的Linq Where 和 Linq Select 先來分析 Where 方法簽章 public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate) 分析：如果我要找一個大於10歲的人,撰寫一般Linq Where 如下在where中塞選此集合的條件，那我要怎麼自己實現呢？ 重點在於[執行塞選條件]這個動作 List&lt;Person&gt; pList = new List&lt;Person&gt;() { new Person() { Age=100,Name=&quot;daniel&quot;}, new Person() { Age=20,Name=&quot;Tom&quot; }, new Person() { Age = 10,Name = &quot;Amy&quot;}, new Person() { Age=5,Name = &quot;rjo&quot;} }; pList.Where(per =&gt; per.Age &gt; 10); 以下是實現自己的Where語法 有沒有很簡單! 重點在if(where(item)) 判斷物件是否符合條件，如符合就回傳此物件 public static class LinqExtension { /// &lt;summary&gt; /// 自訂一個Where /// &lt;/summary&gt; /// &lt;typeparam name=&quot;TSource&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;where&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IEnumerable&lt;TSource&gt; MyWhere&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source ,Func&lt;TSource, bool&gt; where) { foreach (var item in source) { if (where(item)) { yield return item; } } } } 總結：委託把不確定的動作，轉移給呼叫端來撰寫。 而不是寫死在程式中 上面的MyWhere挖了一個洞，關於判斷是否符合條件，給呼叫端實現 雖然在裡面一樣是一個一個判斷是否符合條件，符合再返回，但利用委託和泛型就可以對於任何條件和任何型別來做比較 大大提升了程式效率 原始碼範例 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/c-func-2/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Delegate</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Func</tag>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#)委託delegate,Func,Action 解說系列(一)]]></title>
    <url>%2Fc-func-1%2F</url>
    <content type="text"><![CDATA[前文：成為.Net高手Delegate 是必備武器之一 今天小弟和大家分享我所認知的Delegate 一開始我們先來看看Delegate到底是不是類別 範例解說：宣告一個 voidDelegate 委託 12345678public delegate void voidDelegate();static void Main(string[] args)&#123; Console.WriteLine($"delegate is class? &#123;typeof(voidDelegate).IsClass&#125;"); Console.ReadKey();&#125; 執行結果:Yes 委託是一個特別的類別 但委託物件方式很特別 他在宣告時必須傳入[建構子參數] 而建構子參數是[方法] 我們宣告一個委託 傳入兩個Int參數 回傳Int public delegate int calcInt(int arg1,int arg2); 使用如下 new 一個 calcInt 並傳入建構子參數 add方法 之後就可以把calcint當作方法來使用 123456789calcInt calcint = new calcInt(add);var result1 = calcint(5,5);Console.WriteLine(result1);//方法static int add(int a, int b)&#123; return a + b;&#125; 或是 使用.net提供的 語法糖 如下 1234calcInt calcint1 = (a,b) =&gt; &#123; return a + b; &#125;;var result2 = calcint1(5, 5);Console.WriteLine(result2);(a,b) =&gt; &#123; return a + b; &#125;; 編譯器會動態幫我們產生一個方法。 委託就這樣嗎?! 進階的用法第一 : 宣告一個類別[計算者]，建構子參數是一個泛行List在類別中宣告Calc委託，在Excute方法中我們直接回傳執行Calc結果 123456789101112131415public class Calculator&lt;T&gt; where T : struct&#123; public delegate T Calc(IList&lt;T&gt; list); IList&lt;T&gt; _container; public Calculator(IList&lt;T&gt; container) &#123; _container = container; &#125; public T Excute(Calc C) &#123; return C(_container); &#125;&#125; 使用方法如下：宣告一個物件Calculator傳入建構子參數List 重點:我們可以在Client端決定如何使用此方法 12345678910111213141516List&lt;int&gt; i_List = new List&lt;int&gt;()&#123; 1,3,5,7,9&#125;;Calculator&lt;int&gt; calculator = new Calculator&lt;int&gt;(i_List);int i_add = calculator.Excute((list) =&gt; list.Sum());int i_multi = calculator.Excute((list) =&gt;&#123; int totle = 1; foreach (var i in list) &#123; totle *= i; &#125; return totle;&#125;);Console.WriteLine($"add:&#123;i_add&#125; multi:&#123;i_multi&#125;"); 總結:如上面程式碼 我們可在Client中決定對List集合做操作(加,減,乘,除) ，而不是一開始就寫死在類別中，降低了類別方法和Client的耦合 Delegate可以把方法實作的權利移交給Clinet端 原始碼範例 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/c-func-1/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Delegate</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Func</tag>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#)裝飾者模式(Decorator Pattern)]]></title>
    <url>%2FDecorator-Pattern%2F</url>
    <content type="text"><![CDATA[裝飾者模式是一個很精美且優雅的模式 本篇範例 文字內容-&gt;AES加密-&gt;Zip檔附加密碼-&gt;輸出儲存 情境有個需求要做 文字內容-&gt;壓縮zip(附上密碼)-&gt;輸出儲存又改成… 文字內容-&gt;AES加密-&gt;輸出儲存需求又改成…. 文字內容-&gt;AES加密-&gt;Zip檔附加密碼-&gt;輸出儲存 可發現需求一直在對於文字內容操作順序做變化,但他們核心離不開對於文字內容的操作 這種情境很適合來使用 [裝飾者模式] 裝飾者模式 有兩個主要角色 被裝飾物件(Decorated) &amp; 裝飾物件(Decorator) 被裝飾物件(Decorated)就像蛋糕的一樣, 裝飾物件(Decorator)就是上的水果,奶油,巧克力…等等裝飾物品 一般先有蛋糕被裝飾物件(Decorated),後再將裝飾物品加上去裝飾物件(Decorator) 被裝飾物件(Decorated)如下圖 蛋糕的原型 圖片來源 將物件有效的往上附加職責,不動到內部的程式碼, 在原來職責上附加額外的職責 裝飾者模式運作就像 俄羅斯娃娃一樣 一層包一層 圖片來源 第一步 先找尋他們共同裝飾東西,因為是讀寫檔案 所以我們可以對於Byte下手 先做出 讀 跟 寫 介面簽章當作裝飾動作的統一介面 123456public interface IProcess&#123; byte[] Read(string path); void Write(string writePath, byte[] buffer);&#125; 在創建一個 ProcessBase 給日後裝飾物品(Decorator)來繼承 12345678910111213141516public abstract class ProcessBase : IProcess&#123; /// &lt;summary&gt; /// 儲存被裝飾的物件 /// &lt;/summary&gt; protected IProcess _process; public abstract byte[] Read(string path); public abstract void Write(string writePath, byte[] buffer); public virtual void SetDecorated(IProcess process) &#123; _process = process; &#125;&#125; 有兩點特別說明 protected IProcess _process; 儲存被裝飾的物件由 SetDecorated 方法來設置被裝飾的物件 就像俄羅斯娃娃只包裹一個娃娃,不管被包裹娃娃之前包含哪些娃娃 第二步 創建被裝飾物品(Decorated) 因為是檔案我們直接使用 File.ReadAllBytes 讀 檔案 File.WriteAllBytes 寫 檔案 123456789101112131415/// &lt;summary&gt;/// 讀取檔案/// &lt;/summary&gt;public class FileProcess : IProcess&#123; public byte[] Read(string path) &#123; return File.ReadAllBytes(path); &#125; public void Write(string writePath, byte[] buffer) &#123; File.WriteAllBytes(writePath, buffer); &#125;&#125; 第三步 創建裝飾物品(Decorator) 這次主要裝飾物品有兩個 加壓解壓ZIP檔 加解密 加密裝飾器繼承ProcessBase並按照加解密重寫 Write和 read 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// &lt;summary&gt;/// Aes 加密裝飾器/// &lt;/summary&gt;public class AESCrypProcess : ProcessBase&#123; private AesCryptoServiceProvider aes; public string AESKey &#123; get; set; &#125; = "1776D8E110124E75"; public string AESIV &#123; get; set; &#125; = "B890E7F6BA01C273"; public AESCrypProcess() &#123; aes = new AesCryptoServiceProvider(); aes.Key = Encoding.UTF8.GetBytes(AESKey); aes.IV = Encoding.UTF8.GetBytes(AESIV); &#125; public override byte[] Read(string path) &#123; byte[] encryptBytes = _process.Read(path); return DecryptData(encryptBytes); &#125; /// &lt;summary&gt; /// 進行解密 /// &lt;/summary&gt; /// &lt;param name="encryptBytes"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private byte[] DecryptData(byte[] encryptBytes) &#123; byte[] outputBytes = null; using (MemoryStream memoryStream = new MemoryStream(encryptBytes)) &#123; using (CryptoStream decryptStream = new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Read)) &#123; MemoryStream outputStream = new MemoryStream(); decryptStream.CopyTo(outputStream); outputBytes = outputStream.ToArray(); &#125; &#125; return outputBytes; &#125; /// &lt;summary&gt; /// 裝飾者呼叫方法 /// &lt;/summary&gt; /// &lt;param name="path"&gt;&lt;/param&gt; /// &lt;param name="data"&gt;&lt;/param&gt; public override void Write(string path, byte[] data) &#123; byte[] outputBytes = EncryptData(data); _process.Write(path, outputBytes); &#125; private byte[] EncryptData(byte[] data) &#123; byte[] outputBytes = null; using (MemoryStream memoryStream = new MemoryStream()) &#123; using (CryptoStream encryptStream = new CryptoStream(memoryStream, aes.CreateEncryptor(), CryptoStreamMode.Write)) &#123; MemoryStream inputStream = new MemoryStream(data); inputStream.CopyTo(encryptStream); encryptStream.FlushFinalBlock(); outputBytes = memoryStream.ToArray(); &#125; &#125; return outputBytes; &#125;&#125; 這次讀寫zip使用 SharpZipLib 開源第三方插件 ZIP裝飾器繼承ProcessBase並按照加解密重寫 Write和 read 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// &lt;summary&gt;/// 讀取Zip使用/// &lt;/summary&gt;public class ZipProcess : ProcessBase&#123; public string PassWord &#123; get; set; &#125; public string FileName &#123; get; set; &#125; public override byte[] Read(string path) &#123; byte[] buffer = _process.Read(path); return ZipReader(path, buffer); &#125; public override void Write(string writePath, byte[] data) &#123; byte[] buffer = ZipWriter(data); _process.Write(writePath, buffer); &#125; private byte[] ZipWriter(byte[] buffer) &#123; using (MemoryStream outputMemStream = new MemoryStream()) using (ZipOutputStream zipStream = new ZipOutputStream(outputMemStream)) using (MemoryStream memStreamIn = new MemoryStream(buffer)) &#123; zipStream.SetLevel(9); ZipEntry newEntry = new ZipEntry(FileName); newEntry.DateTime = DateTime.Now; zipStream.Password = PassWord; zipStream.PutNextEntry(newEntry); StreamUtils.Copy(memStreamIn, zipStream, new byte[4096]);//將zip流搬到memoryStream中 zipStream.CloseEntry(); zipStream.IsStreamOwner = false; zipStream.Close(); return outputMemStream.ToArray(); &#125; &#125; /// &lt;summary&gt; /// 讀取zip檔 /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;zip檔案byte&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private byte[] ZipReader(string filePath, byte[] buffer) &#123; byte[] zipBuffer = default(byte[]); using (MemoryStream memoryStream = new MemoryStream(buffer)) &#123; memoryStream.Seek(0, SeekOrigin.Begin); var zip = new ZipFile(memoryStream); zip.Password = PassWord; using (MemoryStream streamWriter = new MemoryStream()) &#123; byte[] bufferReader = new byte[4096]; var file = zip.GetEntry(FileName); //設置要去得的檔名 //如果有檔案 if (file != null) &#123; var zipStream = zip.GetInputStream(file); StreamUtils.Copy(zipStream, streamWriter, bufferReader); zipBuffer = streamWriter.ToArray(); &#125; &#125; &#125; return zipBuffer; &#125;&#125; 上面就把我們要用的裝飾物品 (備料) 準備完成 第四步 創建使用(開始擺盤) 創建一個 DecorateFactory 來當生產 裝飾產品的工廠 建構子傳入一個 被裝飾的物件(FileProcess) 之後可依照喜好一直疊加 裝飾物品(ZipProcess,AESCrypProcess…) 123456789101112131415161718192021public class DecorateFactory&#123; IProcess _original; public DecorateFactory(IProcess original) &#123; _original = original; &#125; public DecorateFactory SetProcess(ProcessBase process) &#123; process.SetDecorated(_original); _original = process; return this; &#125; public IProcess GetProcess() &#123; return _original; &#125;&#125; 裝飾者模式 裝飾的順序是很重要的 為了方便讀者閱讀 我使用小畫家畫出 讀寫順序 如下圖 使用就可很清晰來用 DecorateFactory來創建裝飾流程factroy.GetProcess(); 方法取得完成後的產品 在簡單呼叫讀和寫方法 1234567891011121314151617string filePath = @"C:\Users\daniel.shih\Desktop\test.zip";string content = $"你好 123456 12@()!@ &#123;Environment.NewLine&#125; fsfd嘻嘻哈哈!!";//設置初始化的被裝飾者DecorateFactory factroy = new DecorateFactory(new FileProcess());//設置裝飾的順序factroy.SetProcess(new AESCrypProcess()) .SetProcess(new ZipProcess() &#123; FileName = "1.txt",PassWord ="1234567"&#125;);IProcess process = factroy.GetProcess();byte[] data_buffer = Encoding.UTF8.GetBytes(content);process.Write(filePath, data_buffer);byte[] buffer = process.Read(filePath);Console.WriteLine(Encoding.UTF8.GetString(buffer)); 日後不管需求是改成 文字內容-&gt;壓縮zip(附上密碼)-&gt;輸出儲存 文字內容-&gt;AES加密-&gt;輸出儲存 文字內容-&gt;AES加密-&gt;Zip檔附加密碼-&gt;輸出儲存 還是….. 我們都不怕因為我們把各種操作封裝和多態 各個模組間都是獨立的很好映證 高內聚低耦合 的設計原則 小結: 裝飾者模式是一個很精美且優雅的模式 希望這篇文章可讓讀者對於此模式有更加了解 GitHub範例連結 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Decorator-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Design-Pattern</tag>
        <tag>Decorator-Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【深入淺出】Base編碼 (Base64為例子)]]></title>
    <url>%2Fbase64-principle%2F</url>
    <content type="text"><![CDATA[Base家族以Base64最為出名，這邊會用Base64編碼來做介紹 寫網站應該都用過Base64但你對於他的原理了解嗎? 此篇和大家分享Base家族的秘密 用途：Base64主要用途是某些系統中只能使用ASCII字符，為了避免某些機器無法識別我們傳輸資料 Base64就是用來將非ASCII字符的數據轉換成ASCII字符的一種方法。 base64特別適合在http，mime協議下快速傳輸數據(例如我們常使用 Email) 它使用下面表中所使用的字符與編碼。 圖片連結 Base64 中的64其實是有含意的 他會把資料轉成 a~z (26) A~Z (26) 0~9 (10) + (1) / (1) 上面編碼成上面五種種類字元的資料 64就是把所以可用字元數量總合 64 = 26+26+10+1+1 原理：那Base64是怎麼將資料轉成a~z，A~Z，0~9，/，+的組合呢? 最終目標想要把資料轉成在Ascii Code 0 ~ 127 的字元 Base64 wiki說明 轉換的時候，將3位元組的資料，先後放入一個24位元的緩衝區中，先來的位元組占高位。資料不足3位元組的話，於緩衝區中剩下的位元用0補足。每次取出6位元，按照其值選擇ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字元作為編碼後的輸出，直到全部輸入資料轉換完成。 這邊有幾個重點 會把資料分割成每 3 byte (24bit) 為單位 資料不足3 byte的話，於緩衝區中剩下的bit用0補足 計算出來值依照下表索引轉換成Base64可用字元 直到全部輸入資料轉換完成 下面有個例子方便大家了解！ 實際例子：先來看看下面的例子： BC 用 Base64 轉成 QkM= 過程． 將字元轉換成二進制 B (66) = 0 1 0 0 0 0 1 0 C (67) = 0 1 0 0 0 0 1 1 資料不足3 byte的話，於緩衝區中剩下的bit用0補足，所以我們將第三個Byte資料用0補齊 最左邊數字為頭，用每組６bit來重新分組轉換後的資料. 將轉換後的資料依照Base64轉換表 轉換成Base64字元. Base64編碼 Q k M =範例來自於Wiki = 並不是`Base64的字元 而是代表補0使用的雖然Base64在最後常常會看到 = 或 == 結尾，那是因為遇到要補位的情況.如果字元剛剛好滿的狀態(3 bytes)就不會看到 = 符號 範例來自於Wiki 小結：Base64分享到這邊！ 其實Base家族除了64還有 Base32,Base16 .... 你也可以自行依照上面算法建立自己 Base 編碼. Base32 : a~z , 2~7 原理其實都是一樣的 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/base64-principle/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Base64</tag>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(SQL Server) CTE RECURSIVE (遞迴)製作月曆]]></title>
    <url>%2FCTE-RECURSIVE%2F</url>
    <content type="text"><![CDATA[如果要製作月報…但只有給起訖日 要產生出如下的列表 要怎麼辦… 第一個想到的解法 會使用 WHILE + [暫存表]迴圈遍歷 把每個月新增入暫存表中 程式碼如下: 123456789101112131415161718192021222324252627282930313233DECLARE @t TABLE( StartDate DATETIME, EndDate DATETIME);INSERT INTO @t ( StartDate, EndDate )VALUES ( '2017/01/01', -- StartDate - datetime '2018/01/01' -- EndDate - datetime );--宣告一個起始時間變數DECLARE @TempStartDate DATETIMEDECLARE @TempEndDate DATETIME--設置變數 最小時間(起始時間) 和 最大時間SELECT @TempStartDate = StartDate,@TempEndDate=EndDate FROM @tCREATE TABLE #TEMP(Dates DATETIME)WHILE(@TempStartDate &lt; @TempEndDate)BEGIN --將資料新增入暫存表 INSERT INTO #TEMP (Dates) VALUES (@TempStartDate) --每跑一次迴圈就加一個月 SELECT @TempStartDate = DATEADD(MONTH,1,@TempStartDate)END SELECT * FROM #TEMPDROP TABLE #TEMP 但這個解法雖然簡單..但程式碼又臭又長.. Q: 有沒有更好看的解法又可達成目的呢? ANS: 有!! 就是本次主角 CTE 遞迴 話不多說先貼上程式碼 123456789101112131415161718192021222324DECLARE @t TABLE( StartDate DATETIME, EndDate DATETIME);INSERT INTO @t ( StartDate, EndDate )VALUES ( '2017/01/01', -- StartDate - datetime '2018/01/01' -- EndDate - datetime );;WITH CTE (Dates,EndDate) AS( SELECT StartDate AS Dates,EndDate AS EndDate FROM @t UNION ALL --注意這邊使用 UNION ALL SELECT DATEADD(MONTH,1,Dates),EndDate FROM CTE WHERE DATEADD(MONTH,1,Dates) &lt; EndDate --判斷是否目前遞迴月份小於結束日期)SELECT CTE.DatesFROM CTE 接下來解說 CTE遞迴原理 : 可看到CTE中最主要執行四個步驟 取得初始結果集並(錨點結果集) T(0) 將T(0)結果集進行判斷是否滿足 DATEADD(MONTH,1,Dates) &lt; EndDate 不滿足繼續走,並產生T(1)結果集,依照此結果集繼續往下執行 在執行上面的2步驟 直到滿足條件 T(0),T(1)…..T(n) 傳回結果集。將之前所有產生結果集 UNION ALL。 使用CTE遞迴必須使用UNION ALL 最後CTE結果集就會呈現如下^^ 補充 oracle解法 同場加映!! 如果使用 oracle 可使用 connect by 很簡便取得日曆 123456789101112CREATE TABLE T( StartDate DATE, EndDate DATE);INSERT INTO T( StartDate, EndDate ) VALUES (date '2017-01-01',date '2018-01-01');select add_months(trunc(StartDate,'mm'),level - 1 ) "Date" from T connect by trunc(EndDate,'mm') &gt;= add_months(trunc(StartDate,'mm'),level) order by 1 http://sqlfiddle.com/#!4/75cd9/14 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/CTE-RECURSIVE/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Tsql</tag>
        <tag>MSSql</tag>
        <tag>CTE</tag>
        <tag>UNION ALL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【財政部查詢類電子發票API】框架解說 C#]]></title>
    <url>%2FInvoiceTW-Framework%2F</url>
    <content type="text"><![CDATA[小弟之前有分享過串接【財政部查詢類電子發票API】小框架使用文 使用文連結 快速使用財政部電子發票API 使用 C#串接文件下載 電子發票查詢API 1.4.4程式原始碼連結 這次想跟大家分享我做出此框架的歷程.. 框架目的：希望可以做出方便日後維護擴展的API。 串接API時發現他們有幾個共同之處 API請求參數名稱需降冪排列 請求參數最後會加上簽章 都有時間戳記 回應資料格式都是Json 都是使用Http (Get or Post) 我就想到可以使用 工廠模式來實作這系列產品 (工廠模式主要是切割產品的使用和生產) 產品解說因為他們都有共同的能力傳入一組參數回傳一串Json 我就先寫出一個API共同的介面簽章 IApiRunner這個介面為基礎來撰寫後面的程式碼 123456789101112/// &lt;summary&gt;/// 執行api的介面/// &lt;/summary&gt;public interface IApiRunner&#123; /// &lt;summary&gt; /// 執行api /// &lt;/summary&gt; /// &lt;param name="model"&gt;傳入的參數&lt;/param&gt; /// &lt;returns&gt;回傳資料&lt;/returns&gt; string ExcuteApi(object model);&#125; 我在中間多一個抽象泛型類別 ApiBase (用泛型是為了給子類決定傳入參數的Model)原因: 中間使用泛型抽象類別讓子類決定要傳入哪組參數 可以將一些共通的方法寫在裡面 子類別只需要知道要提供哪些動作，所以在ApiBase中提供兩個方法來override 請求URL 目前預設讀取Config (GetApiURL) 參數的組合 (SetParamter) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// 子類繼承提供參數/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;protected abstract string SetParamter(T model);/// &lt;summary&gt;/// 取得api的Url路徑/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;protected virtual string GetApiURL()&#123; string apiname = this.GetType().Name; if (!ConfigurationManager.AppSettings.AllKeys.Contains(apiname)) &#123; throw new Exception(string.Format("請確認Config的appsetting有無此參數 &#123;0&#125;", apiname)); &#125; return ConfigurationManager.AppSettings[apiname];&#125;/// &lt;summary&gt;/// 執行Api/// &lt;/summary&gt;/// &lt;param name="model"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public virtual string ExcuteApi(object model)&#123; //建立所需參數 string result = string.Empty; string postData = string.Empty; string posturl = GetApiURL(); var data = ObjectToModel(model); //取得加密後的參數 postData = GetInvoiceParamter(SetParamter(data)); try &#123; ServicePointManager.ServerCertificateValidationCallback = HttpTool.ValidateServerCertificate; result = HttpTool.HttpPost(posturl, postData); &#125; catch (Exception ex) &#123; result = GetSysErrorMsg(); &#125; return result;&#125; 目前產品部分已經建構好了。 工廠解說工廠部分這次我選擇使用【反射方式來實現工廠】 工廠類別 MoblieInvoiceApiFactroy 其實最主要是使用GetInstance方法12345678910111213141516/// &lt;summary&gt;/// 提供api的工廠/// Model和Api命名要相關/// 例如:testModel 對 testApi/// &lt;/summary&gt;/// &lt;param name="model"&gt;Model參數&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IApiRunner GetInstace(object model)&#123; if (model == null) throw new ArgumentNullException("不能傳空的參數"); string modelName = model.GetType().Name; return (IApiRunner)Activator.CreateInstance (GetInstanceType(model), null);&#125; 其中我把決定使用哪個組API的決定權交給Model並寫在標籤上(Attirbute)在執行時他可獲取此參數Model所註冊參數的型別，來動態產生產品 123456789101112131415/// &lt;summary&gt;/// 反射取得綁定Model上綁定的API型別/// &lt;/summary&gt;/// &lt;param name="model"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static Type GetInstanceType(object model)&#123; var modelType = model.GetType(); var attr = modelType.GetCustomAttribute(typeof(ApiTypeAttribute)) as ApiTypeAttribute; if (attr != null) &#123; return GetApiType(attr); &#125; throw new Exception("Model尚未賦予ApiTypeAttribute");&#125; EX:查詢中獎號碼API Model 可以很清楚知道這個Model隸屬於哪個API 12345[ApiType(ApiType = typeof(QryWinningListApi), MockApiType = typeof(QryWinningListMockApi))]public class QryWinningListModel&#123; public string invTerm &#123; get; set; &#125;&#125; 值得一提的是它有多一個MockApiType 為什麼會有這個?原因：如果財政部伺服器連不到我們可以改成假資料或是模擬資料(讀取資料庫或是其他方式)。 以上就是此框架的解說 外部只需要呼叫工廠的GetInstance方法並傳入參數Model就會回傳相對應的產品API類別這樣就降低執行和產生產品的耦合度，因為外部不是直接強耦合於Api類別而是透過工廠日後如需增加API產品只需擴展新的類別 符合OCP(開放封閉原則)已經達到目的：希望可以做出方便日後維護擴展的API。 Ps:這次我除了使用 工廠模式,也有用到樣板模式,代理模式 剩下兩個模式讓大家來找看看吧^^ 一般來說很少只用一個模式就可以解決一個問題的，通常都是配合使用 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/InvoiceTW-Framework/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>SourceCode</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Design-Pattern</tag>
        <tag>Open-Source</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C#】 AOP輕型框架 AwesomeProxy.Net 介紹使用]]></title>
    <url>%2FAwesomeProxy-Net%2F</url>
    <content type="text"><![CDATA[今天和大家分享AwesomeProxy.Net小弟開源AOP輕型框架 簡單介紹 AOP (Aspect-Oriented Programming)AOP 是 OOP(物件導向)一個變化程式撰寫思想。（非取代OOP而是擴充） 導入AOP幫助： 可幫我們分離核心邏輯跟非核心邏輯代碼，很好降低模組間耦合性，已便日後擴充。 非核心邏輯代碼像：(日誌記錄，性能統計，安全控制，事務處理，異常處理等代碼從業務邏輯代碼中劃分出來) 例如下圖： 原本寫法把寫日誌相關程式寫入，業務邏輯方法中。導致此方法非單一職則。我們可以把程式重構改寫成(右圖)，將寫日誌方法抽離出來更有效達成模組化。 經典例子: Asp.Net MVC中Contoller，Action過濾器(FilterAttribute) AwesomeProxy.Net介紹：AwesomeProxy.Net 主要是攔截方法處理 方法執行前 方法執行後 方法異常 How to Use: 使用方法類似於Asp.Net MVC中Contoller，Action過濾器 撰寫一個標籤(Attribute) 標記攔截動作 123456789101112131415161718public class CacheAttribute : AopBaseAttribute&#123; public string CacheName &#123; get; set; &#125; public override void OnExcuting(ExcuteingContext context) &#123; object cacheObj = CallContext.GetData(CacheName); if (cacheObj != null) &#123; context.Result = cacheObj; &#125; &#125; public override void OnExcuted(ExcutedContext context) &#123; CallContext.SetData(CacheName, context.Result); &#125;&#125; 將要被攔截類別繼承於MarshalByRefObject類別 12345678public class CacheService : MarshalByRefObject&#123; [Cache] public string GetCacheDate() &#123; return DateTime.Now.ToString("yyyy/MM/dd hh:mm:ss"); &#125;&#125; 由ProxyFactory.GetProxyInstance 動態產生被代理類別1CacheService cache = ProxyFactory.GetProxyInstance&lt;CacheService&gt;(); 4.直接呼叫方法就可執行標籤上的攔截動作12CacheService cache = ProxyFactory.GetProxyInstance&lt;CacheService&gt;();Console.WriteLine(cache.GetCacheDate()); Simple Code： 撰寫Log 權限驗證 快取 Unit Test 結果 小結：使用 AwesomeProxy.Net 和ASP.Net MVC註冊Contoller或Action過濾器一樣AOP核心思想就是代理模式。 本篇只先介紹如何使用，後續有時間會再補充代理模式細節！ 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/AwesomeProxy-Net/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>AOP</tag>
        <tag>Asp.net</tag>
        <tag>Design-Pattern</tag>
        <tag>Open-Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C#】我們來土砲一個 Asp.net Session (Session核心原理)]]></title>
    <url>%2Fown-session%2F</url>
    <content type="text"><![CDATA[我們在寫網站一定會使用到 Session今天就跟大家分享自製微型 Asp.net Session 分析Session-&gt;實作Session-&gt;使用Session 在實作之前您必須先了解甚麼是Session網路上一大堆介紹Session文章在此我就不多介紹或可以點進之前小弟的介紹文來簡單了解 SessionID.cookie,Session傻傻分不清楚?? 簡單說明：Http協議是一個無狀態協議。 核心是 請求=&gt;處理=&gt;回應 每次請求都是獨立不會記住上一次做了甚麼Session可以幫我們把資料存在Server記憶體，方便我們下次請求使用上網連線眾多使用者，Server怎麼知道哪份資料,屬於哪個使用者的? 這就要依靠 SessonIDSessionID就像使用者的號碼牌，可以到Server拿相對應的資料 分析： 使用者請求頁面時會攜帶該網域下Cookies。 Asp.net接收到並使用Key為SessionID的Cookie，使用Cookie的Value來SessionPool中查找屬於使用者的Session。如果是第一次請求或是沒有SessionID 會幫他產生一個新的並加入回應的Cookie中 取得Session物件後就可以在程式中使用。 分析如下圖： 我們作出幾個核心來完成模擬Session: SessionPool來存放目前所有Session SessionObject (支援快取在系統記憶體中)模擬HttpContext封裝Session 實作：我要簡單呈現就選擇使用輕便 [泛型處理常式] ApplicationContext 模擬HttpContext封裝SessionPool創建一個靜態的SessionPool物件，因為程式都共用此SessionPool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// &lt;summary&gt;/// 請求上下文/// &lt;/summary&gt;public class ApplicationContext&#123; /// &lt;summary&gt; /// 存在Cookie中的SessionID /// &lt;/summary&gt; private readonly string MySessionID = "MySessionID"; public HttpRequest Request &#123; get; private set; &#125; public HttpResponse Respone &#123; get; private set; &#125; public ApplicationContext(HttpContext context) &#123; Respone = context.Response; Request = context.Request; &#125; private static SessionPool _container = new SessionPool(); public SessionObject Session &#123; get &#123; return GetSessionObj(); &#125; &#125; /// &lt;summary&gt; /// 從SessionPool中取得Session對象 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private SessionObject GetSessionObj() &#123; Guid sessionGuid; HttpCookie CookieSessionID = Request.Cookies[MySessionID]; //如果沒有MySessionID的cookie，做一個新的 if (CookieSessionID == null) &#123; sessionGuid = Guid.NewGuid(); HttpCookie cookie = new HttpCookie(MySessionID, sessionGuid.ToString()) &#123; Expires = DateTime.Now.AddDays(60) &#125;; Respone.Cookies.Add(cookie); &#125; else &#123; sessionGuid = Guid.Parse(CookieSessionID.Value); &#125; return _container[sessionGuid]; &#125;&#125; CacheDictionary 負責快取 使用一個 Dictionary 來對Session存取物件設置快取 12345/// &lt;summary&gt;/// 掌管物件存活時間的集合/// &lt;/summary&gt;private readonly Dictionary&lt;string, CancellationTokenSource&gt; _expireContaner = new Dictionary&lt;string, CancellationTokenSource&gt;(); 在Task.Delay可以讓物件存放在工作執行緒中 等Delay時間到就呼叫 ContinueWith 將物件消毀 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 設置快取對象/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;/// &lt;param name="key"&gt;&lt;/param&gt;/// &lt;param name="create"&gt;&lt;/param&gt;/// &lt;param name="expireIn"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T Set&lt;T&gt;(string key, Func&lt;T&gt; create, TimeSpan expireIn)&#123; //如果此Key被使用 將原本的內容移除 if (_expireTasks.ContainsKey(key)) &#123; _expireTasks[key].Cancel(); _expireTasks.Remove(key); &#125; var expirationTokenSource = new CancellationTokenSource(); var expirationToken = expirationTokenSource.Token; //物件快取 Task.Delay(expireIn, expirationToken).ContinueWith(_ =&gt; Expire(key), expirationToken); _expireTasks[key] = expirationTokenSource; return (T)(this[key] = create());&#125; SeesionPool 存放所有Session取Session會判斷此Guid是否有對應的Session物件，沒有會幫她創建一個放在池子中 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 存放所有Session池子/// &lt;/summary&gt;public class SessionPool&#123; private Dictionary&lt;Guid, SessionObject&gt; _SessionContain = new Dictionary&lt;Guid, SessionObject&gt;(); public SessionObject this[Guid index] &#123; get &#123; SessionObject obj; if (_SessionContain.TryGetValue(index, out obj)) &#123; return obj; &#125; else &#123; obj = new SessionObject(); _SessionContain.Add(index, obj); &#125; return obj; &#125; &#125;&#125; SessionObject 控制讀取時的值 (一般我們所使用的Session) 1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// Session物件/// &lt;/summary&gt;public class SessionObject&#123; private CacheDictionary cache = new CacheDictionary(); public object this[string index] &#123; get &#123; return GetObj(index); &#125; set &#123; SetCache(index, value); &#125; &#125; private void SetCache(string key, object value) &#123; cache.Set(key, () =&gt; value); &#125; private object GetObj(string key) &#123; return cache.GetOrDefault(key, () =&gt; default(object)); &#125;&#125; 使用： 在建構子中創建一個 ApplicationContext 之後,即可Asp.net那樣來使用Session 1234567891011121314151617private ApplicationContext app;public SessionHanlder()&#123; app = new ApplicationContext(HttpContext.Current);&#125;public void ProcessRequest(HttpContext context)&#123; if (null == app.Session["Time"]) &#123; app.Session["Time"] = $"Hello &#123;DateTime.Now.ToString("yyyy-MM-dd hh-mm-ss")&#125;"; &#125; context.Response.Write(app.Session["Time"]); context.Response.ContentType = "text/plain";&#125; 上面程式是簡單模擬Session核心作用的程式 但並未處理多執行緒並發讀寫…等等問題，所以建議別再實際專案中使用XD!! 專案使用 VS2015 GitHub原始碼 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/own-session/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>SourceCode</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五分鐘快速了解 [傳址，傳參考，傳址]]]></title>
    <url>%2Fref-address%2F</url>
    <content type="text"><![CDATA[傳址，傳參考，傳址 是基本但重要的概念。此概念在很多語言都通用 我使用Gif動畫檔 快速帶領大家了解 傳址，傳參考，傳址 傳值(Call By Value) 顧名思義 是把值傳到 另一個記憶體位置的值上 傳址 (Call By Adress) 是把記憶體位置傳到 另一個記憶體位置的值上 補充:嚴格來說(Call By Adress)是不正統的說法,其實傳址也是傳值但傳的是記憶體位置 傳參考(Call By Reference) 是把記憶體位置傳到 移到另一個記憶體位置上 (可看作同一個物件) 在C#廣義來說 基本型別 Struct (int,double,float,byte …) 可看作 傳值 一般型別 Class (自訂Class ,SqlConnection….) 可看作 傳址 更精確來說是傳Stack的值(指向Heap的記憶體位置) 在C#中並沒傳參考，只有傳值和傳址 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/ref-address/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Memory</tag>
        <tag>call by value</tag>
        <tag>call by adress</tag>
        <tag>call by reference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net使用快取 (二)]]></title>
    <url>%2Fcache-asp-net-2%2F</url>
    <content type="text"><![CDATA[Asp.net使用快取 (一) 向大家簡單介紹 快取是什麼 為何要使用快取 使用簡單HttpRuntime.Cache使用快取機制 這篇是分享把快取程式碼變得更有彈性 第二篇大綱 提出介面,提高可替換性 使用泛型改寫快取 讀取方式 使用擴充方法改寫快取 提出介面,提高可替換性情境: 目前有個專案使用 HttpRuntime.Cache 物件 在記憶體快取中除了使用 Asp.Net 中HttpRuntime.Cache類別外還有很多解決方案.例如使用Memcache,Redis… 如果我們原本使用HttpRuntime.Cache類別但之後要轉成其他快取方式怎麼辦? 1234567891011121314151617public class HomeController : Controller&#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; public ActionResult Index() &#123; string cacheData = cacheContainer.Get("data") as string; if (cacheData==null) &#123; cacheContainer.Insert("test1", DateTime.Now.ToShortDateString()); &#125; return View(cacheData); &#125;&#125; 雖然使用不同快取方式,但記得我上篇的重點快取會有兩個動作,讀和寫,所以最基本就會有讀和寫這兩個動作 OOP有個很重要的觀念 多個類有重複動作考慮提出父類別 為了方便了解我把HttpRuntime.Cache封裝成一個類別 12345678910public class NetCache &#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; public object GetCacheObject(string key) &#123; return cacheContainer.Get(key); &#125; public void SetCache(string key,object obj) &#123; cacheContainer.Insert(key, obj); &#125;&#125; 這邊有另一個Memcache快取Class 12345678910111213141516public class MemeryCache &#123; private ObjectCache _cache = MemoryCache.Default; public object GetCacheObject(string key) &#123; return _cache[cacheKey]; &#125; public void SetCache(string key, object obj) &#123; var policy = new CacheItemPolicy(); policy.RemovedCallback = OnFileContentsCacheRemove; // 設定快取時間2分鐘 policy.AbsoluteExpiration = DateTimeOffset.Now.Minute(2); _cache.Set(cacheKey, fileContents, policy); &#125;&#125; 先不關注這兩個物件裡面細節,我們可以發現他們都有 GetCacheObject 方法和SetCache 方法 這時我們就可以適時提出介面(interface),當作這兩個類別的合約 123456public interface ICache &#123; void Set(string key,object obj); object Get(string key);&#125; 之後將他們兩個類別實現 ICache 介面 1234567891011121314151617181920212223242526272829public class MemeryCache : ICache&#123; private ObjectCache _cache = MemoryCache.Default; public object Get(string key) &#123; return _cache[cacheKey]; &#125; public void Set(string key, object obj) &#123; var policy = new CacheItemPolicy(); policy.RemovedCallback = OnFileContentsCacheRemove; // 設定快取時間2分鐘 policy.AbsoluteExpiration = DateTimeOffset.Now.Minute(2); _cache.Set(cacheKey, fileContents, policy); &#125;&#125;public class NetCache : ICache&#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; public object Get(string key) &#123; return cacheContainer.Get(key); &#125; public void Set(string key,object obj) &#123; cacheContainer.Insert(key, obj); &#125;&#125; 提出介面有甚麼好處? 我們可以把前面程式碼改成IOC依賴注入的方式,不要在程式碼寫死使用HttpRuntime.Cache,由IOC容器幫我們把物件注入程式碼中. Note:我使用建構子注入法 12345678910111213141516171819202122public class HomeController : Controller&#123; //不用寫死使用 HttpRuntime.Cache //System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; ICache cacheContainer; public HomeController(ICache Container)&#123; cacheContainer = Container; &#125; public ActionResult Index() &#123; string cacheData = cacheContainer.Get("data") as string; if (cacheData==null) &#123; cacheContainer.Insert("test1", DateTime.Now.ToShortDateString()); &#125; return View(cacheData); &#125;&#125; ICache 變成快取程式碼的潤滑劑.可讓程式變得更有彈性 使用泛型改寫快取 讀取方式我在StackOverFlow解答的方式就是第二種 其中最主要的技巧就是把Get方法返回的Object改成使用泛型 123456789101112131415161718 public T GetOrSetCache&lt;T&gt; (string key,T obj, int cacheTime) where T:class,new()&#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; T cacheObj = cacheContainer.Get(key) as T; if (cacheObj == null) &#123; cacheContainer.Insert(key, obj, null, DateTime.Now.AddMinutes(cacheTime), System.Web.Caching.Cache.NoSlidingExpiration); cacheObj = obj; &#125; return cacheObj;&#125; 讓我們在使用時可以變成 123var data = DateTime.Now.ToShortDateString();int numberOfMinutes = 3;data = GetOrSetCache("name1",data,numberOfMinutes ); 我們只需要呼叫GetOrSetCache方法,這個方法把GetCache和SetCache封裝起來了 使用擴充方法改寫快取.Net有提供一個很方便的機制 擴充方法,這個機制幫我們解決一個很重要的問題.我們可以擴充已經封裝但沒有原始碼的類別, 在這段程式碼中,使用Func&lt;TObj&gt; 可以使用lambda 表達式,讓程式碼更簡潔有力!! 123456789101112131415public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key, int cacheTime) where TObj : class&#123; Cache cacheContainer = HttpRuntime.Cache; //get cache Object var obj = cacheContainer.Get(key) as TObj; //if there isn't cache object add this object to cache if (obj == null) &#123; obj = selector(); cacheContainer.Insert(key, obj); &#125; return obj;&#125; 我們使用時如下 變更簡潔動作更漂亮 12int numberOfMinutes = 3;data = GetOrSetCache(()=&gt; DateTime.Now.ToShortDateString(),"name1",data,numberOfMinutes ); 同場加映: 擴展方法和介面搭配使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class WebDefaultCache : ICache&#123; Cache cacheContainer = HttpRuntime.Cache; public object Get(string key) &#123; return cacheContainer.Get(key); &#125; public void Set(string key, object obj) &#123; cacheContainer.Insert(key, obj); &#125;&#125;public interface ICache&#123; void Set(string key, object obj); object Get(string key);&#125;public static class InfrastructureExtension&#123; public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key) where TObj : class &#123; return GetOrSetCache(selector, key,10); &#125; public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key, int cacheTime) where TObj : class &#123; return GetOrSetCache(selector, key, cacheTime, new WebDefaultCache()); &#125; public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key, int cacheTime, ICache cacheContainer) where TObj : class &#123; //get cache Object var obj = cacheContainer.Get(key) as TObj; //if there isn't cache object add this object to cache if (obj == null) &#123; obj = selector(); cacheContainer.Set(key, obj); &#125; return obj; &#125;&#125; 雖然在使用上和第三種一樣但我們多了使用方法重載多傳一個參數ICache介面 可以讓我們在寫程式時決定要使用哪種cache方式,不用改快去那邊程式碼. 同場加映程式碼我放在我自己常用的ExtenionTool專案中 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/cache-asp-net-2/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net使用快取 (一)]]></title>
    <url>%2Fcache-asp-net-1%2F</url>
    <content type="text"><![CDATA[最近回答SQL Server data caching in ASP.NET問題,且有人問我有關快取的問題. 所以小弟打算寫兩篇文章簡單分享我知道的快取 目錄:第一篇 為何要使用快取 快取操作 Asp.Net中使用快取 by HttpRuntime.Cache 第二篇 提出介面,提高可替換性 使用泛型改寫快取 讀取方式 使用擴充方法改寫快取 正文快取機制很重要,但有些觀念可能要先釐清楚 為何要使用快取在使用一個東西前,使用的原因很重要. 如果某些資料常常使用,但卻不常改變我們會把資料存在某個空間中(常常會存記憶體,因為記憶體速度快),方便日後讀取使用. 快取操作一般使用快取會有兩個動作,讀和寫如果是存在記憶體中一般會有期限,因為記憶體資源很寶貴不能一直占用. 寫入 通常有一個Key,跟要存入物件就像我們把東西存入保險箱,會拿到一個鑰匙 來取東西 讀取 讀取就是依照Key讀取我們存入的物件 就像我們要拿保險箱裡的東西需要的鑰匙 Asp.Net中使用快取 by HttpRuntime.Cache 在Asp.net中 有一個靜態物件 HttpRuntime.Cache 可以很方便使用快取 存入快取可以呼叫 Insert 方法 他有多個重載 可以使用最簡單的 Insert(string [key],object [value]) 如下面範例 123System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache;string data = "";cacheContainer.Insert("test1", data); 讀取快取資料 呼叫 Get 傳入Key值即可獲得 Note:如果快取容器沒有此物件會回傳NULL 1string cacheData = cacheContainer.Get("data") as string; 小結:這篇簡單介紹快取 下篇會將目前程式碼做改進,變得更優美彈性 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/cache-asp-net-1/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsonConvert.SerializeObject 呼叫 object.Equals 問題探討]]></title>
    <url>%2FJsonConvert-SerializeObject%2F</url>
    <content type="text"><![CDATA[最近在 StackOverFlow 解答一個很有趣的問題Json.Net / Newtonsoft: Using JsonConvert.SerializeObject results in weird .Equals calls - why? 問題簡述是：使用Newtonsoft.Json.JsonConvert.SerializeObject方法 來把物件轉成JSON資料時,為什麼會呼叫物件的Equals 方法 且傳入的object obj類型不是此類別類型,而是屬性的類型 以下是發問者提供的程式碼: 1234567891011121314151617181920public class JsonTestClass&#123; public string Name &#123; get; set; &#125; public List&lt;int&gt; MyIntList &#123; get; set; &#125; public override bool Equals(object obj) &#123; if (obj == null) return false; JsonTestClass jtc = (JsonTestClass)obj; return true; &#125;&#125;JsonTestClass c = new JsonTestClass();c.Name = "test";c.MyIntList = new List&lt;int&gt;();c.MyIntList.Add(1);string json = JsonConvert.SerializeObject(c, new JsonSerializerSettings() &#123; TypeNameHandling = TypeNameHandling.All &#125;); 問題解析：看到問題後我就直接去看Json.net原始碼 一探到底原因出在哪邊. 後面發現當我們在呼叫JsonConvert.SerializeObject方法,會執行一個 private bool CheckForCircularReference私有方法. 123bool exists = (Serializer._equalityComparer != null) ? _serializeStack.Contains(value, Serializer._equalityComparer) : _serializeStack.Contains(value); ### 重點： 這個方法主要用意是判斷目前序列化JSON物件是否有重複引用本身,方法中有段程式碼使用到 List&lt;T&gt;.Contains. 當我們在呼叫List&lt;T&gt;.Contains時 預設EqualityComparer&lt;T&gt;.Default 進行比較來進行判斷是否存在集合中. 要寫客製化比較方式有兩種 在.net中每個類別都繼承於Object, Object 中有object.Equals 所以可以重寫object.Equals方法. 將此類別實現 IEquatable&lt;T&gt; 並重寫你要的比較方式. 所以會呼叫object.Equals是因為上段程式碼 補充說明：什麼是判斷目前序列化JSON物件是否有重複引用本身? 以下的範例是private bool CheckForCircularReference想要防止的問題 123456789101112public class JsonTestClass&#123; public string Name &#123; get; set; &#125; public List&lt;int&gt; MyIntList &#123; get; set; &#125; public JsonTestClass Test&#123;get;set;&#125;&#125;JsonTestClass c = new JsonTestClass();c.Name = "test";c.Test = c;string json = JsonConvert.SerializeObject (c, new JsonSerializerSettings() &#123; TypeNameHandling = TypeNameHandling.All &#125;); 我們可以看到c.Test = c; 將自己本身付值給 public JsonTestClass Test{get;set;} 這個屬性. 我們執行上面程式碼會得到此錯誤 Self referencing loop detected for property ‘Test’ with type ‘Program+JsonTestClass’. Path ‘’. 是因為他要防止重複引用本身導致無限迴圈解析JSON. Note預設值類型的比較是比較值.預設參考類別比較的是地址. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/JsonConvert-SerializeObject/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Json.net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC(控制反轉)，DI(依賴注入) 深入淺出~~]]></title>
    <url>%2Fioc-di%2F</url>
    <content type="text"><![CDATA[IOC是一個oop重要的程式設計思想。 學一個技術或思想前我們先了解，這個技術或思想為我們解決怎樣問題。 Ioc—Inversion of Control 控制反轉控制反轉是一個設計思想 ，把對於某個物件的控制權移轉給第三方容器 簡單解釋A物件程式內部需要使用B物件 A,B物件中有依賴的成份 控制反轉是把原本A對B控制權移交給第三方容器 降低A對B物件的耦合性，讓雙方都倚賴第三方容器。 反轉概念如下圖 我們可發現有兩點差異 使用者原本直接耦合於A，但使用IoC容器使用者就直接對容器而不是A 至於A關連於誰由容器決定原本A直接控制於B,C，但透過一個IoC容器我們控制權反轉給了容器 IoC經典實現對象設計法則 好萊塢法則：“別找我們，我們找你”系統中模組建議依賴抽象，因為各個模組間不需要知道對方太多細節（實作），知道越多耦合越強。DI—Dependency Injection 依賴注入 把被依賴物件注入被動接收物件中 案例解釋：小明是個愛乾淨的人，但他工作時常加班導致 學一個技術或思想前我們必須先了解，這個技術或思想可為我們解決什麼問題。 Ioc(Inversion of Control)控制反轉 控制反轉是一個設計思想 簡單解釋 A物件程式內部需要使用B物件 A,B物件中有依賴的成份 控制反轉把原本A對B直接控制權移交給由第三方容器 降低A對B物件的耦合程度，並讓雙方都倚賴抽象。 IoC經典實現對象設計法則 好萊塢法則：“別找我們，我們找你” 系統中模組建議依賴抽象，因為各個模組間不需要知道對方太多細節（實作），知道越多耦合越強。 DI—Dependency Injection 依賴注入 把被依賴物件注入被動接收物件中 案例解釋： 小明是個愛乾淨的人，但他工作時常加班導致房間雜亂，他不能忍受此狀況，所以小明去找一個清潔阿姨每天幫忙他打掃家裡 哪天阿姨哪天有事不能打掃，小明就必須要再去找人來幫忙打掃，由此可知小明耦合阿姨 如果今天是…. 小明把他要的條件給「打掃仲介公司」，仲介公司幫他尋找有沒有符合小明需求的打掃阿姨，假如今天A阿姨請假了，仲介公司會自動找另一個符合需求B阿姨幫忙打掃… 原本小明需耦合於打掃阿姨，現在被「仲介公司」做了控制反轉讓「仲介公司」來提供打掃阿姨。 小明不用管是否今天有人會來打掃，「仲介公司」會幫小明找到一個掃地阿姨。 「仲介公司」可看作 依賴注入容器 「小明」可看作 被動接收物件 「打掃阿姨」可看作 被依賴物件 在使用IOC容器前需先了解雙方的依賴關係(誰依賴誰?) 上述還有一個很重要的觀念是，依賴和被接收對象要倚賴抽象。 範例使用：VS2015 IOC容器：AutoFac 下面範例來說明上面的例子 小明自己依賴於掃地阿姨依賴程式碼寫在小明類別內部日後要更改只能動內部程式碼。 12345678910111213/// &lt;summary&gt;/// 小明直接依賴 Aunt 不是依賴抽象/// 日後要改必須動內部/// &lt;/summary&gt;public class Mine&#123; public Aunt aunt = new Aunt(); public void Room() &#123; aunt.Swapping(); &#125;&#125; 呼叫使用時 12Mine mine = new Mine();mine.Room(); 小明找仲介公司 仲介公司(Ioc容器) 在仲介公司內註冊需求，讓仲介公司日後幫你找人（註冊的類別） 123456789101112131415/// &lt;summary&gt;/// 仲介公司/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private static IContainer MiddleCompany()&#123; ContainerBuilder builder = new ContainerBuilder(); //在仲介公司裡寫需求人申請單 builder.RegisterType&lt;MineWithMiddle&gt;(); //小明所需打掃阿姨需求 builder.RegisterType&lt;Aunt&gt;().As&lt;ISwapable&gt;(); return builder.Build();&#125; 使用起來 12345IContainer middleCompany = MiddleCompany();//仲介公司(IOC AutoFac)自動幫小明注入一個打掃阿姨MineWithMiddle mineWithMiddle = middleCompany.Resolve&lt;MineWithMiddle&gt;();mineWithMiddle.Room(); 總結： 雖然上面程式碼執行結果一樣，但內部結構和日後擴展性卻截然不同 重點：系統中模組建議依賴抽象，因為各個模組間不需要知道對方太多細節（實作），知道越多耦合越強。 像網頁瀏覽器和伺服器是依賴Http協議，用戶端不管是手機.電腦,平板，伺服器端php,asp.net,java都可互相交信，依賴Http協議共用的合約 範例原始碼 參考連結 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/ioc-di/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IOC</tag>
        <tag>Autofac</tag>
        <tag>Design-Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沒有Source Code 如何修改程式??]]></title>
    <url>%2Fmodify-sourcecode%2F</url>
    <content type="text"><![CDATA[某些專案因為歷史久遠沒有Source Code,但有個需求需要異動裡面的程式該怎麼辦?? 難道只能整個反組譯,查看程式碼翻一份做新的嗎? 不~~其實有辦法直接對於DLL進行修改 只需使用 Reflexil 搭配 ILSpy 或其他支援的反組譯軟體 Reflexil 是一個組譯編輯器插件目前支援 Reflector, ILSpy 和 Telerik’s JustDecompile. 下載連結 Reflexil Release 2.2 搭配 ILSpy version 3.2 前置動作，安裝Reflexil 下載下載 reflexil.for.ILSpy.2.2.bin.zip，不用下載AIO 作者有說 ILSpy version 3.2 (ILSpy 4 is not currently compatible with Reflexil, given the use of System.Reflection.Metadata, deprecating Mono.Cecil usage)ILSpy 4 當前版本 ILSpy.2.2 並不支援 ILSpy 3.2 下載 下載完後就把全部的DLL放在同一個資料夾下,並開啟 ILSpy.exe 按下上方的齒輪UI 就可獲得下方藍色的Reflexil 修改框框. 組件修改需求 目前組件 有個ClassA 類別,裡面有一個prop1屬性 型態是string, 我們希望在這新增另一個屬性 使用滑鼠右鍵點擊類別ClassA,我們可以看到很多方式可以注入新的程式碼 在這我們選擇inject property. 我們需要修改的是 Item Name (使用屬性的名稱) Property Type(使用屬性類別) 選擇完後按下OK,我們就會發現prop2新屬性會出現在ClassA中. 新增完後不代表已經將修改儲存!! 我們需要點選組件，之後再按下Save AS 把本次修改儲存 日後我們就可以使用新的屬性在我們程式中了!! 小結此插件還可以新增,插入許多東西時屬非常強大,有興趣的玩家可再自行深入琢磨. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/modify-sourcecode/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Reflection</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淺談-編碼(encoding) vs 加解密 vs 雜湊(Hash)]]></title>
    <url>%2Fhash-encoding%2F</url>
    <content type="text"><![CDATA[這一邊有三筆資料 U2FsdGVkX19FJsgVyam+Gh2EwmGs4BEJjJJsWxCXHWw84gp3uHvozWsHY8gfAx0C VG9kYXkgaXMgYSBnb29kIERheQ== 046a484a529ecfc7693753ee65802b5cfcafd548252d0e5f1bca845ad2208b91 這三個東西看起來都是亂碼，但所代表含意完全不一樣 這邊會跟大家分享這三個東西特性和差異性 此文同步發布 Blog [淺談] 編碼(encoding) vs 加解密 vs 雜湊(Hash) 前言：會想分享這篇文章是因為蠻多人把 編碼(encoding) 加解密 雜湊(Hash) 這三個東西搞混，尤其是把編碼當作加密….這是非常危險的事情. 編碼!= 加密 兩個是完全不一樣的東西 編碼!= 加密 兩個是完全不一樣的東西 編碼!= 加密 兩個是完全不一樣的東西 很重要所以要說三次XD! 編碼說明：這邊用Base64編碼來介紹，我們可以看到下圖資料轉換是雙向的． Hello Daniel =&gt; SGVsbG8gRGFuaWVs 如果我們想要把SGVsbG8gRGFuaWVs 變回 Hello Daniel 只需進行Base64解碼即可 編碼是將原本的資料經過一個運算轉換成另一組資料,如果要還原成原本資料解碼 用途：在網路傳輸會使用到編碼主要是資料在傳輸時有些特殊字元,有特殊用途(ex:Http 傳參數 &amp;….) 這時就可使用編碼將資料轉換成不會衝突到字串. 如果想要了解 Base64 原理和演算法的話可以看我另一篇【深入淺出】Base編碼 (Base64為例子) 加解密說明：這邊以AES來介紹，我們可以看到下圖資料轉換是雙向，但會透過一個Key來做轉換(這邊是和編碼最大的差別) 要還原成原始資料我們只能透過一樣的Key才可以達成，就像一個寶相只有唯一一把鑰匙可以打開一樣． 這邊補充一個簡單加密法(凱薩算法)，他是使用字元位移的數字來當作Key 如果位移數量是1 ABCD =&gt; BCDE 如圖 用途：加密可以確保資料的安全性（只有相同的Key才可還原成原本資料）很適合用在機密資料且須要還原使用 雜湊(Hash)說明：這裡用Sha256來當作範例 Hash有幾個特點 不管資料量多大經過SHA256運算字串長度都是一樣的 SHA256的原因是運算完的資料大小一定是 256 bit 她是一個不可逆的算法所以我們可以看到箭頭是單向. 相同的值用SHA運算過後值都是一樣的 一定會有小夥伴好奇,運算完都是固定長度 那會不會出現一個情況,原始資料不一樣但算完Hash結果是一樣的 會 這個我們稱之為雜湊碰撞 這個機率很小 用途：一般我們可以把使用者密碼經Hash運算存入資料庫中,當作使用唯一識別碼(像指紋)下次使用者登入用運一樣的Hash算法 再將值拿來比較辨識使用者合法性. 小結：對於這邊有一個簡單的比較表格 編碼(encoding) 加解密 雜湊(Hash) 加解密和編碼最常被大家誤會搞錯地方是以為使用Base64編碼就很安全(但有心人事取得你的資料只要知道你使用編碼就可以還原成原始資料) 如果要確保資料隱密性時可以使用加解密而不是編碼 所以別再把Base64編碼當作加密工具來使用. 這是很危險低 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/hash-encoding/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>Base64</tag>
        <tag>Encoding</tag>
        <tag>AES</tag>
        <tag>SHA256</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
</search>
