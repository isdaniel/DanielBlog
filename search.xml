<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JOIN範圍條件Index優化]]></title>
    <url>%2FJoin-Index-Improve%2F</url>
    <content type="text"><![CDATA[Agenda 前文 資料初始化 建立Index 查詢語法 前文JOIN條件範圍時,執行計畫預估值容易不準確,這也間接導致查詢效能不好. 就算有建立Index也會遇到上述問題 假如我們想要提升JOIN條件範圍效能並讓Index可以發揮最大最用可以怎麼做? 就讓我利用一個範例來跟大家分享. 案例此範例有使用到三張表 Product表:擁有1-10編號產品 ReportPeriod表:存放產每期報表的資訊(時間,和是否產報表) T99表:線上產品訂單資訊 12345678910111213141516171819CREATE TABLE [dbo].[Product]( [ProductId] INT NOT NULL)CREATE TABLE [dbo].[T99]( [TransactionId] [int] IDENTITY(1,1) NOT NULL, [Amount] DECIMAL(18,6), [CreateDate] [datetime2](3) NULL)GOCREATE TABLE [dbo].[ReportPeriod]( [PerioidID] [int] IDENTITY(1,1) NOT NULL, [ProductId] INT NOT NULL, [IsGenerate] [bit] NULL, [StartDate] [datetime2](3) NULL, [EndDate] [datetime2](3) NULL) ON [PRIMARY]GO 我們利用T99.CreateDate來跟ReportPeriod判斷是屬於哪期報表. 資料初始化我們利用亂數產生Sample資料來模擬線上大資料狀況. ReportPeriod期別由&#39;2019-08-01&#39;到&#39;2020-07-31&#39; 因為產生報表以5分鐘為區間,所以可以利用CTE遞迴來幫我們產生資料. 1234567891011121314151617181920212223242526272829303132INSERT INTO [dbo].[Product] VALUES (1);INSERT INTO [dbo].[Product] VALUES (2);INSERT INTO [dbo].[Product] VALUES (3);INSERT INTO [dbo].[Product] VALUES (4);INSERT INTO [dbo].[Product] VALUES (5);INSERT INTO [dbo].[Product] VALUES (6);INSERT INTO [dbo].[Product] VALUES (7);INSERT INTO [dbo].[Product] VALUES (8);INSERT INTO [dbo].[Product] VALUES (9);INSERT INTO [dbo].[Product] VALUES (10);declare @FromDate DATETIME2(3) = '2019-08-01'declare @ToDate DATETIME2(3) = '2020-07-31';WITH CTE AS ( SELECT @FromDate fromDt,@ToDate endDt UNION ALL SELECT DATEADD(MINUTE,5,fromDt),endDt FROM CTE WHERE DATEADD(MINUTE,5,fromDt) &lt; endDt)INSERT INTO [dbo].[ReportPeriod] ([ProductId],[IsGenerate],[StartDate],[EndDate])SELECT ProductId,0,fromDt,DATEADD(MINUTE,5,fromDt) FROM CTE CROSS JOIN dbo.ProductOPTION (MAXRECURSION 0); INSERT INTO T99 ([CreateDate],Amount)SELECT top 1000000 dateadd(SECOND, rand(checksum(newid()))*(1+datediff(SECOND, @FromDate, @ToDate)), @FromDate), CAST(RAND(CHECKSUM(NEWID())) * 100000 as INT) + 1FROM sys.all_columns c1 CROSS JOIN sys.all_columns c2 建立Index123456789101112131415161718192021CREATE CLUSTERED INDEX [CIX_ReportPeriod_StartDate] ON [dbo].[ReportPeriod]( [StartDate] ASC, [EndDate] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]ALTER TABLE [dbo].[ReportPeriod] ADD CONSTRAINT [PK_ReportPeriod] PRIMARY KEY NONCLUSTERED ( [PerioidID] ASC, [ProductId] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]CREATE CLUSTERED INDEX [CIX_T99_CreateDate] ON [dbo].[T99]( [CreateDate] ASC)CREATE UNIQUE NONCLUSTERED INDEX [IX_T99_TransactionId] ON [dbo].[T99]( [TransactionId] ASC) 查詢語法在線上我們會使用UDT當作參數來取得某些期別資訊. 這裡為了方便模擬我使用Table Variable來取代. 1234567891011121314set nocount onDECLARE @Transaction AS TABLE( TransactionId INT, ProductId INT);INSERT INTO @Transaction VALUES (1,1)INSERT INTO @Transaction VALUES (101,2)INSERT INTO @Transaction VALUES (1001,3)SELECT p.*FROM dbo.T99 t JOIN [dbo].[ReportPeriod] p ON t.CreateDate BETWEEN p.StartDate AND p.EndDateJOIN @Transaction t1 ON t.TransactionId = t1.TransactionId AND p.ProductId = t1.ProductId 使用上面語法我們只需查詢三個期別資料,但看執行計畫時能發現，ReportPeriod使用的Clustered預估資訊有1百多萬筆 Q:我明明有對於條件建立Index，但為什麼預估值卻會跑真那麼嚴重？ 12345CREATE CLUSTERED INDEX [CIX_ReportPeriod_StartDate] ON [dbo].[ReportPeriod]( [StartDate] ASC, [EndDate] ASC) 原因出在範圍條件會因為查找範圍過大導致預估值不準確 甚麼意思? 讓我們看看下圖(代表ReportPeriod內含日期資料) 而我們在JOIN條件只有t.CreateDate BETWEEN p.StartDate AND p.EndDate這就會導致,我們需要查找ReportPeriod日期資料在挑出符合的資料 12JOIN [dbo].[ReportPeriod] p ON t.CreateDate BETWEEN p.StartDate AND p.EndDateJOIN @Transaction t1 ON t.TransactionId = t1.TransactionId AND p.ProductId = t1.ProductId 最後就會看到走針的估計值 如何優化? 效能差問題,選擇對Index和撰寫合理的查詢可以改善40%左右問題 我們思考一下如果可以把範圍條件改成精準=查找條件不就可以更精準預估資訊了? 1t.CreateDate BETWEEN p.StartDate AND p.EndDate 那我們怎麼把上面條件使用=取代BETWEEN範圍查詢呢? 這時我們可以利用空間來換取時間 建立一個新的COLUMN運用算法來計算每個期數StartTime 例如:CreateDate = 2020/01/03 10:08:55會歸類在2020/01/03 10:05:00中 12345678ALTER TABLE dbo.T99 ADD PeriodDate AS DATEADD(MINUTE,DATEPART(MINUTE,CreateDate) %5 * -1, DATETIMEFROMPARTS( DATEPART(YEAR,CreateDate), DATEPART(MONTH,CreateDate), DATEPART(DAY,CreateDate), DATEPART(HOUR,CreateDate), DATEPART(MINUTE,CreateDate),0,0)) 建立完新COLUMN後別忘記加入一個Index給此COLUMN. 123CREATE INDEX IX_PeriodDate_T99 ON dbo.T99( PeriodDate) 最後我們修改一下查詢語法 1234SELECT p.*FROM dbo.T99 t JOIN [dbo].[ReportPeriod] p ON p.StartDate = t.PeriodDateJOIN @Transaction t1 ON t.TransactionId = t1.TransactionId AND p.ProductId = t1.ProductId 預估值和讀取值已經可以大幅降低了!! 小結:在JOIN範圍條件差效能問題,可以思考一下是否有辦法利用算法或是公式來優化查詢效能，如此次範例一樣. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Join-Index-Improve/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>DataBase</category>
        <category>Turning</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Turning</tag>
        <tag>Sql-server</tag>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server Merge condition on declare value problem]]></title>
    <url>%2FSQLServer-Merge-condition-problem%2F</url>
    <content type="text"><![CDATA[前言假如要判斷資料是否存在於資料表中,存在就更新,不存在就新增. 這時我們可以使用Merge來幫助我們完成. 當兩個資料表有複雜的比對的特性時，MERGE陳述式的條件式行為表現最佳。 有了Merge我們就不用使用IF EXISTS. 一切都是這麼完美… 直到到有一天Merge在Prod撞到一個問題.. 問題描述使用語法user defined table type &amp; Table如下 12345678910111213141516171819202122232425CREATE TABLE [dbo].[PriceLimitation]( [CategoryID] [int] NOT NULL, [ProdcutGroupID] [smallint] NOT NULL, [UserID] [int] NOT NULL, [StakeAmount] [numeric](18, 4) NOT NULL, [ProductID] [smallint] NOT NULL, CONSTRAINT [PK_PriceLimitation] PRIMARY KEY CLUSTERED ( [UserID] ASC, [CategoryID] ASC, [ProductID] ASC, [ProdcutGroupID] ASC)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]GOCREATE TYPE [dbo].[uftt_PriceLimit] AS TABLE( [UserID] [int] NOT NULL, [StakeAmount] [numeric](18, 4) NOT NULL, PRIMARY KEY CLUSTERED ( [UserID] ASC)WITH (IGNORE_DUP_KEY = OFF)) 呼叫執行SP[dbo].[CalculateLimitation] 1234567891011121314151617181920CREATE OR ALTER PROC [dbo].[CalculateStake] @CategoryID int, @ProductID smallint , @ProdcutGroupID smallint, @PriceLimit [uftt_PriceLimit] readonlyASBEGIN SET NOCOUNT ON; MERGE INTO [dbo].[PriceLimitation] t1 USING @PriceLimit t2 ON t1.UserID = t2.UserID AND t1.ProdcutGroupID= @ProdcutGroupID AND t1.CategoryID=@CategoryID AND t1.ProductID = @ProductID WHEN MATCHED THEN UPDATE SET t1.StakeAmount = t1.StakeAmount + t2.StakeAmount WHEN NOT MATCHED THEN INSERT VALUES(@CategoryID, @ProdcutGroupID, t2.UserID ,t2.StakeAmount, @ProductID);END 主要傳入參數判斷更新或新增[dbo].[PriceLimitation]表 我們在ELK發現在執行SP時很少概率會發生PRIMARY KEY重複問題. Violation of PRIMARY KEY constraint ‘PK_PriceLimitation’. Cannot insert duplicate key in object ‘dbo.PriceLimitation’. 但這張表PK使用欄位都有正確在Merge條件上,所以當下我們嘗是在DEV重現此問題,但一直無法成功 後來發現此問題在高併發時才會發生,所以我們使用Query Stress來幫助我們模擬高併發請求時的狀態. Query Stress重現問題撰寫了模擬SQL並利用Query Stress重現問題. 模擬SQL腳本 1234567891011121314151617181920212223DECLARE @CategoryID int, @ProductID smallint , @ProdcutGroupID smallint, @PriceLimit [uftt_PriceLimit] declare @from intSELECT @from = ROUND(RAND(CAST(NEWID() as varbinary)) * 500,0)SELECT @CategoryID = CAST(ROUND(RAND(CAST(NEWID() as varbinary)) * 123,0) as int) % 4 +1SELECT @ProductID = CAST(ROUND(RAND(CAST(NEWID() as varbinary)) * 123,0) as int) % 5 +1SELECT @ProdcutGroupID = CAST(ROUND(RAND(CAST(NEWID() as varbinary)) * 731,0) as int) % 20 +1;with cte as( select @from as num union all select num + 1 as num from cte where num &lt; @from+500) insert into @PriceLimit ([UserID],[StakeAmount],CategoryID,[ProductID],[ProdcutGroupID])select num,100,@CategoryID,@ProductID,@ProdcutGroupIDfrom cteoption(MAXRECURSION 0);exec [dbo].[CalculateStake] @CategoryID,@ProductID,@ProdcutGroupID,@PriceLimit 我使用模擬參數是 Iterator:30 Thread:100 來模擬高併發時資料庫請求狀況,就能發現這時已經會出現Prod的Exception. 找到問題尋求解法對於目前Prod問題已經邁出一大步了,因為現在問題可以重現,在網路上找了許多文章還是沒找到解法…. 後面在MSDN時看到關鍵一段話,關於merge-transact-sql. 請務必只從目標資料表指定用於比對用途的資料行。 也就是說，從目標資料表中指定要與來源資料表的對應資料行進行比較的資料行。 請勿嘗試在 ON 子句中篩選出目標資料表的資料列 (例如指定 AND NOT target_table.column_x = value) 來改善查詢效能。 這樣做可能會傳回非預期且不正確的結果。 後面有看到有篇文章在介紹use-where-clause-with-merge 我就嘗試把sp寫法改成只利用兩個Table可以JOIN欄位當作條件,發現Duplicate PK問題就可以解決了….但發現另一個更麻煩問題. SP改寫後 123456789101112131415161718192021CREATE OR ALTER PROC [dbo].[CalculateStake] @CategoryID int, @ProductID smallint , @ProdcutGroupID smallint, @PriceLimit [uftt_PriceLimit] readonlyASBEGIN SET NOCOUNT ON; MERGE INTO [dbo].[PriceLimitation] t1 USING @PriceLimit t2 ON t1.UserID = t2.UserID WHEN MATCHED AND t1.ProdcutGroupID= @ProdcutGroupID AND t1.CategoryID=@CategoryID AND t1.ProductID = @ProductID THEN UPDATE SET t1.StakeAmount = t1.StakeAmount + t2.StakeAmount WHEN NOT MATCHED THEN INSERT VALUES(@CategoryID, @ProdcutGroupID, t2.UserID ,t2.StakeAmount, @ProductID);END 新寫法的執行計畫在對於大資料表時會很沒效率…. 改寫後遇到的問題(不好的執行計畫)一般SP在執行過後都會把使用的執行計畫快取起來,所以我們可以透過DMV來查看執行執行計畫. 12345SELECT Cacheobjtype, Objtype, TEXT, query_planFROM sys.dm_exec_cached_plans t1CROSS APPLY sys.dm_exec_sql_text(plan_handle) t2CROSS APPLY sys.dm_exec_query_plan(plan_handle) t3where t2.objectid = object_id('dbo.CalculateStake', 'p') 新和舊SP寫法執行計畫如下圖. 舊寫法 新寫法 造成上面差異原因，因為新寫法透過統計資訊使用效能較差的執行計畫(能看到上面使用Merge Join明明傳入結果集資料並不多)且在WHEN MATCHED進行第二次判斷… 所以效能就變很差,現在已經找到此問題點了，我就在思考那有沒有辦法兼具效能又可解決此問題呢? 最終版SP寫法最後我就思考何不如把傳入參數全部加入user defined table type 這樣就可以利用傳入參數當作ON條件也可以得到精準執行計畫. user defined table type所有欄位可以跟Table的Clustered Index Match. 1234567891011121314151617181920212223242526272829303132333435drop proc[dbo].[CalculateStake]drop type [dbo].[uftt_PriceLimit] CREATE TYPE [dbo].[uftt_PriceLimit] AS TABLE( [CategoryID] [int] NOT NULL, [ProdcutGroupID] [smallint] NOT NULL, [UserID] [int] NOT NULL, [StakeAmount] [numeric](18, 4) NOT NULL, [ProductID] [smallint] NOT NULL, PRIMARY KEY CLUSTERED ( [UserID] ASC, [CategoryID] ASC, [ProductID] ASC, [ProdcutGroupID] ASC)WITH (IGNORE_DUP_KEY = OFF))CREATE OR ALTER PROC [dbo].[CalculateStake] @PriceLimit [uftt_PriceLimit] readonlyASBEGIN SET NOCOUNT ON; MERGE INTO [dbo].[PriceLimitation] t1 USING @PriceLimit t2 ON t1.UserID = t2.UserID AND t1.ProdcutGroupID= t2.ProdcutGroupID AND t1.CategoryID=t2.CategoryID AND t1.ProductID =t2.ProductID WHEN MATCHED THEN UPDATE SET t1.StakeAmount = t1.StakeAmount + t2.StakeAmount WHEN NOT MATCHED THEN INSERT VALUES(t2.CategoryID, t2.ProdcutGroupID, t2.UserID ,t2.StakeAmount, t2.ProductID);END 測試腳本改成把參數透過uftt_PriceLimit傳入 1234567891011121314151617181920212223DECLARE @CategoryID int, @ProductID smallint , @ProdcutGroupID smallint, @PriceLimit [uftt_PriceLimit] declare @from intSELECT @from = ROUND(RAND(CAST(NEWID() as varbinary)) * 500,0)SELECT @CategoryID = CAST(ROUND(RAND(CAST(NEWID() as varbinary)) * 123,0) as int) % 4 +1SELECT @ProductID = CAST(ROUND(RAND(CAST(NEWID() as varbinary)) * 123,0) as int) % 5 +1SELECT @ProdcutGroupID = CAST(ROUND(RAND(CAST(NEWID() as varbinary)) * 731,0) as int) % 20 +1;with cte as( select @from as num union all select num + 1 as num from cte where num &lt; @from+500) insert into @PriceLimit ([UserID],[StakeAmount],CategoryID,[ProductID],[ProdcutGroupID])select num,100,@CategoryID,@ProductID,@ProdcutGroupIDfrom cteoption(MAXRECURSION 0);exec [dbo].[CalculateStake] @PriceLimit 請在跑修改後的SP前記得把Table先Truncate掉，這樣可以更精準模擬 使用QueryStress模擬參數 Iterator:30 Thread:100 執行結果如下 利用Query Stress工具壓測發現問題解決且效能不會變差:) 小結:沒想到Merge在On條件有些隱藏限制(對於On寫value condition官方只有說會有想不到的問題發生,並沒解釋原因為何…),但經過這次經驗我日後在使用Merge時不會直接在On使用value condition會在中間多墊一層Table這樣就可以使用ON來JOIN. 另外QueryStress真是一個對於DB壓測找問題的好工具,推薦大家去了解使用 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/SQLServer-Merge-condition-problem/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL-Server</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>SQL-Server</tag>
        <tag>Merge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年String.Format中的Boxing和UnBoxing]]></title>
    <url>%2FStringFormat_Compare%2F</url>
    <content type="text"><![CDATA[前言：下面有兩個虛擬程式碼 12345int times = 30000000;string s = string.Empty;s = $"&#123;times&#125;";s = $"&#123;times.ToString()&#125;"; 請問下面這兩段程式碼有沒有差別? 12s = $"&#123;times&#125;";s = $"&#123;times.ToString()&#125;"; $&quot;&quot;這個程式碼是string.Format()語法糖 如果知道差別的同學,恭喜你已經可以下課了 如果不知道差別也沒關係,讓我細細講述. String.Format方法簽章在String.Format方法有一個重載方法,可以看到裡面吃參數是params object[]這可以讓我們傳進東西當作參數(他會在方法中呼叫ToString方法). 1public static string Format(string format, params object[] args) 所以這段程式碼看起來應該是要一樣,但事實並非如此… 12s = $"&#123;times&#125;";s = $"&#123;times.ToString()&#125;"; $”{times}” vs $”{times.ToString()}”在執行下面程式碼會發現兩段程式碼不管怎麼執行 執行時間$&quot;{times}&quot;;永遠都會比$&quot;{times.ToString()}&quot;;來的多 1234567891011121314151617181920212223242526class Program&#123; static void Main(string[] args) &#123; int times = 30000000; string s = string.Empty; Stopwatch sw = new Stopwatch(); sw.Start(); for (int i = 0; i &lt; times ; i++) &#123; s = $"&#123;times&#125;"; &#125; sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); sw.Restart(); for (int i = 0; i &lt; times ; i++) &#123; s = $"&#123;times.ToString()&#125;"; &#125; sw.Stop(); Console.WriteLine(sw.ElapsedMilliseconds); Console.ReadKey(); &#125;&#125; 執行時間如上圖 Source Code 這是為什麼呢?? 原因出在Boxing和UnBoxing上… Boxing 和 UnBoxing在說Boxing和UnBoxing之前 我們要了解.Net中的Refer Type和Value Type在記憶體存放上差別. 想了解Refer Type和Value Type的人,可以參考我之前寫文章 【C#】 參考類型 , 值類型 Equals方法 和 ==. 假如已經了解Refer Type和Value Type,在.Net中有分Stack記憶體區段和Heap記憶體區段. Stack:存放Value Type(struct)資料 Heap:存放Refer Type資料 Boxing因為在Boxing時我們會把Value Type資料複製一份資料到Refer Type記憶體中. 12int i=20;object o=(object)i; 上面程式碼大概會如下圖操作 int強制轉型為object 因為我們所有物件都是繼承於object物件 UnBoxing至於UnBoxing動作就如下面程式碼 123int i=20;object o=(object)i;int j=(int)o; UnBoxing會將原本存在Heap的值,會把他搬回Stack並附值給J o Object強轉成int在這個案例不會有問題，但如果是將o轉為char就會有問題 (解答)String.Format兩個範例 效能差異如果有從頭看到尾小夥伴,相信應該可以了解到問什麼會有沒有.ToString會造成差異性了吧. 因為Boxing會造成系統無形中消耗,如果我們先把傳入Value Type資料轉成String再傳入就可以避免Boxing問題. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/StringFormat_Compare/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Boxing-UnBoxing</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Boxing vs UnBoxing]]></title>
    <url>%2FBoxing_UnBoxing%2F</url>
    <content type="text"><![CDATA[前言:Boxing跟UnBoxing在.net中,我們可能在無意識使用到但這個事情確會造成一些效能影響… .NET兩種類型在.NET有分兩種類型 值類型(int,double,char….) 參考類型(自行宣告的類別,string….) 而存放資料的方式也有兩種: 堆疊Stack 堆積Heap 談談Boxing和UnBoxing之前，我們先來了解Stack和Heap 值類型(Value Type)會存取在Stack記憶體區塊中 參考類型(Reference Type)內容會在Heap記憶體區塊上，Stack會指向Heap上記憶體位置(有點像c++傳址) 如下圖 了解Stack和Heap後 我們來談談Boxing和UnBoxing Boxing:型態由大轉小 12int i=20;object o=(object)i; int強制轉型為object 因為我們所有物件都是繼承於object物件 原本值類型存在Stack中,但因為我們強轉成Object = 20會存在Heap記憶體區塊中. 因為Object是ReferType型別,這個現象就是Boxing 如下圖 UnBoxing:型態由小轉大(小轉大會有轉型出錯的問題) 123int i=20;object o=(object)i;int j=(int)o; 將Object強轉成int在這個案例不會有問題，但如果是將o轉為char就會有問題 在執行UnBoxing如下圖 可以看到原本存在Heap上值 我們會把他搬回Stack並附值給J 把Heap上直搬回Stake上就會遇到UnBoxing. .Net現實生活中常遇到的案例 String.Format DataTable String.Format的Boxing1public static string Format(string format, params object[] args) 我們常使用上面String.Format重載方法,但使用這個方法會不小心遇到Boxing問題 我們在呼叫方法時假如參數是一個Value Type,.Net會在呼叫前把此值複製在傳入方法中(如果是Refer Type傳入此物件Heap記憶體位置). String.Format吃參數是Object,所以如果傳入參數是Value Type如(1,1.1m)就會遇到Boxing. 但如果我們在呼叫String.Format前使用ToString方法就可以避免Boxing的動作,$&quot;{times.ToString()}&quot;. DataTable的Boxing UnBoxing我們在ADO.Net將資料存放在DataTable就會經歷一次Boxing在利用DataTable.Row[][]返回是一個Object型態資料(因為會把ValueType型別資料放進Heap中). 我們在取用時會把Object轉成我們希望型態(UnBoxing). 12DataTable dt= new DataTable();dt.Rows[0]["col1"] //返回一個object型態的物件 所以我在讀取DB資料時建議使用DataReader而不是使用DataTable,因為使用DataReader可以直接去得使用型態(避免Boxing and UnBoxing). 小結希望本篇文章可以讓大家對於Boxing和UnBoxing更了解，避免踏入這個問題中。 參考連結 參考 MSDN https://msdn.microsoft.com/zh-tw/library/yz2be5wk.aspx 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Boxing_UnBoxing/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Boxing-UnBoxing</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[影響Query Optimizer產生執行計畫的關鍵(統計值)]]></title>
    <url>%2FSQLServer-Statistics%2F</url>
    <content type="text"><![CDATA[什麼是統計值SQL Server的QO(Query Optimizer)透過cost-based model來選擇一個最合適計畫(估算成本最低)來執行查詢 注意每個執行計畫是使用CPU來做估算，使用過的執行計畫一般會Cache起來已便下次使用 QO會依照基數估計(Cardinality estimation)來產生執行計畫，基數估計扮演一個很重要的角色 SQL Server統計值是對於每個Index或欄位資料分布做紀錄，任何型態都支援統計值資料. 過期的統計值資料導致QO誤判產生不良執行計畫 在我們建立Index時，統計值會自動創建。此外當欄位在查詢裡被使用(作為WHERE條件的一部分,group by子句,join條件)統計值會被自動建立 何時建立統計值?每個索引都會有自己個統計資訊，在UI查看統計資訊如下圖. 如果查詢條件欄位沒有統計值，Query Optimizer會在編譯前將統計值建立或有門檻條件性的更新。 如下圖我們使用C3沒有建立索引欄位來查詢，SQL-Server就會幫我們自動產生_WA_Sys_00000003_6EF57B66這個統計資訊來讓QO產生執行計畫時有個依據. 查詢資料表統計值 &amp; 了解統計值欄位含意想要查詢資料表索引的統計值可以輸入DBCC SHOW_STATISTICS，第一個參數是查詢資料表，第二個參數是查詢的索引或統計值. 1DBCC SHOW_STATISTICS('dbo.posts','PK_Posts') 使用上語法查詢會出現三個結果集 第一個結果集 顯示出此統計值的基本資訊其中有幾個重要的欄位 最後更新時間 密度 統計值Key的欄位大小 第二個結果集 密度分布,使用常數查詢,直接使用子方圖進行資料筆數估計 第三個結果集 RANGE_HI_KEY:每個區域資料的分佈。RANGE_ROWS:上圖列出(120 + 1) ~(126)區間的Row是57.175筆資料EQ_ROWS:代表這個區間值。DISTINCT_RANGE_ROWS:代表這個區間裏面有幾個特殊/單一(Unique)值。AVG_RANGE_ROWS:代表這個區間每個特殊值平均有幾筆 觸發統計值更新假如有設定自動更新統計值，異動資料筆數超過 (500 + 20%)資料，會觸發統計值更新 如果是大資料表容易造成統計值不準確，因為要達到自動更新門檻有點困難 在SQL2017之前版本建議啟用TF2371，可以讓自動更新統計值的門檻數量變平滑點 1DBCC TRACEON (2371,-1) 啟動後大資料就不會只使用(500 + 20%)條件來更新統計值，會依照資料表筆數來判斷(如下圖) 假如使用執行計畫(估計值)很不準確可以查看，當前的統計值是否是正確 如果要更新統計值可以使用下面語法. 12UPDATE STATISTICS dbo.T1; --更新統計值DBCC SHOW_STATISTICS ('dbo.T1', idx1) --顯示統計值 刪除重複統計值資料我們在建立索引，在下次查詢時SQL-Server會幫我們建立索引的統計值資料,這時候之前建立資料變得是多餘的就可以利用下面Script找尋是否有同個欄位擁有重複統計值，可建立刪除Script 12345678910111213141516171819202122232425262728WITH autostats(object_id, stats_id, name, column_id)AS (SELECT sys.stats.object_id , sys.stats.stats_id , sys.stats.name , sys.stats_columns.column_idFROM sys.stats INNER JOIN sys.stats_columns ON sys.stats.object_id = sys.stats_columns.object_id AND sys.stats.stats_id = sys.stats_columns.stats_idWHERE sys.stats.auto_created = 1 AND sys.stats_columns.stats_column_id = 1)SELECT OBJECT_NAME(sys.stats.object_id) AS [Table] , sys.columns.name AS [Column] , sys.stats.name AS [Overlapped] , autostats.name AS [Overlapping] , 'DROP STATISTICS [' + OBJECT_SCHEMA_NAME(sys.stats.object_id) + '].[' + OBJECT_NAME(sys.stats.object_id) + '].[' + autostats.name + ']'FROM sys.stats INNER JOIN sys.stats_columns ON sys.stats.object_id = sys.stats_columns.object_id AND sys.stats.stats_id = sys.stats_columns.stats_id INNER JOIN autostats ON sys.stats_columns.object_id = autostats.object_id AND sys.stats_columns.column_id = autostats.column_id INNER JOIN sys.columns ON sys.stats.object_id = sys.columns.object_id AND sys.stats_columns.column_id = sys.columns.column_idWHERE sys.stats.auto_created = 0 AND sys.stats_columns.stats_column_id = 1 AND sys.stats_columns.stats_id != autostats.stats_id AND OBJECTPROPERTY(sys.stats.object_id, 'IsMsShipped') = 0; 統計值和查詢記憶體分配SQL-Server查詢不同操作有不同的記憶體分配方式,例如Index Scan不用把資料存在記憶體中(因為一筆一筆取出就可以),但如果是使用Sort相關的操作,需要在執行前訪問rowset SQL-Server會依照統計值來分配合適的記憶體大小,假如統計值不准會導致記憶體分配不對,就會把資料存在TempDb造成查詢效能低落. 下面這個範例來演示上面所說的 12345678910111213141516171819202122create table dbo.MemoryGrantDemo ( ID int not null, Col int not null, Placeholder char(8000) ); create unique clustered index IDX_MemoryGrantDemo_ID on dbo.MemoryGrantDemo(ID); ;with N1(C) as (select 0 union all select 0) -- 2 rows ,N2(C) as (select 0 from N1 as T1 cross join N1 as T2) -- 4 rows ,N3(C) as (select 0 from N2 as T1 cross join N2 as T2) -- 16 rows ,N4(C) as (select 0 from N3 as T1 cross join N3 as T2) -- 256 rows ,N5(C) as (select 0 from N4 as T1 cross join N4 as T2) -- 65,536 rows ,IDs(ID) as (select row_number() over (order by (select null)) from N5) insert into dbo.MemoryGrantDemo(ID,Col,Placeholder) select ID, ID % 100, convert(char(100),ID) from IDs; create nonclustered index IDX_MemoryGrantDemo_Col on dbo.MemoryGrantDemo(Col); 建立一張表MemoryGrantDemo並建立Clustered Index跟新增65,536筆資料Col介於1~100之間,最後在建立一個NonClustered Index Col介於1~100之間會有統計值 12345678910;with N1(C) as (select 0 union all select 0) -- 2 rows ,N2(C) as (select 0 from N1 as T1 cross join N1 as T2) -- 4 rows ,N3(C) as (select 0 from N2 as T1 cross join N2 as T2) -- 16 rows ,N4(C) as (select 0 from N3 as T1 cross join N3 as T2) -- 256 rows ,N5(C) as (select 0 from N4 as T1 cross join N2 as T2) -- 1,024 rows ,IDs(ID) as (select row_number() over (order by (select null)) from N5) insert into dbo.MemoryGrantDemo(ID,Col,Placeholder) select 100000 + ID, 1000, convert(char(100),ID) from IDs where ID &lt;= 656; 最後在新增Col = 1000的656筆資料 因為只有新增656只有原本的1%所以不會觸法更新統計值 如下圖能看到IDX_MemoryGrantDemo_Col並沒有Col=1000的資訊 建立好資料後我們使用statistics和打開執行計畫來看看兩者差別 1234567 declare @Dummy int set statistics time on select @Dummy = ID from dbo.MemoryGrantDemo where Col = 1 order by Placeholder; select @Dummy = ID from dbo.MemoryGrantDemo where Col = 1000 order by Placeholder; set statistics time off 在執行計畫中看到第二個查詢有個驚嘆號,移過去看可以發現查詢出來的資料寫入TempDb中 [訊息]中能看到第二個查詢語法使用時間比較長 因為SQL-Server依照統計值分配記憶體大小,所以會把統計值預估外資料搬到tempdb資料庫 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/SQLServer-Statistics/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>DataBase</category>
        <category>Turning</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Turning</tag>
        <tag>Sql-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[撰寫SQL的建議]]></title>
    <url>%2FDBNote%2F</url>
    <content type="text"><![CDATA[Agenda 前文 前文本篇會分享在撰寫SQL時建議和比較分享 永遠先考慮T-SQL改寫 符合SARG Statement進行撰寫 &lt;、&gt;、=、&lt;=、&gt;=、LIKE(視%所在位置，前面有%讓DB engine選擇不走INDEX) 不要在Where欄位做運算 使用ANSI 92相容的Join方式連接資料庫(避免使用舊式Join) 避免row by row操作 符合SARG格式的撰寫 + 適當Index設計可以解決大部分的效能問題 使用Like查詢建議 盡量別把%放在前面 如果查詢條件是CNAME LIKE &#39;%范&#39;想讓讓查詢走索引(seek 查詢),在後面加一個條件AND CNAME &gt; &#39;&#39;讓查詢走Seek. 12345SELECT [MID] ,[NickName] ,[CName]FROM [Member_Basic] WITH (NOLOCK)WHERE CNAME LIKE '%范' AND CNAME &gt; '' 使用Count函數建議如果要取得筆數數量使用COUNT(*)比Count(c1)效能好. Count(c1)會忽略c1 IS NULL數量. 另外如果[資料筆數]&gt;2^15-1(大於INT最大值)筆數量可使用count_big(*)方法 如果需要COUNT資料很大造成效能影響可以透過DMV取得當前資料表數量(資料會不準確,因為並非及時更新) 1234567SELECT SUM(p.rows)FROM sys.partitions p WHERE p.[object_id] = object_id('dbo.Person') AND p.index_id &lt; 2SELECT SUM(p.row_count)FROM sys.dm_db_partition_stats p WHERE p.[object_id] = object_id('dbo.Person') AND p.index_id &lt; 2 使用if exists (select 1 from dbo.table)取代count函式判斷資料是否存在 NOT IN vs NOT EXISTS在查詢時避免使用NOT IN，因為會被QO改寫成 &lt;&gt; NULL，在SQL中NULL代表不知道(Unknow)，所以會什麼都查不到 因為此欄位是可空(NULL)時會造成非預期結果(因為NULL會造成判斷失誤NULL不是一個值他代表未知) 使用NOT EXISTS替代NOT IN NOT EXISTS在可空欄位效能比NOT IN還要好(如果有建立Index兩個產生執行計畫理論上是一樣) 下面有一個範例來解說為什麼避免在可空欄位使用NOT IN 1234567891011121314151617181920212223CREATE TABLE T( ID INT)INSERT INTO T VALUES (1)INSERT INTO T VALUES (2)SELECT *FROM dbo.TWHERE ID NOT IN ( SELECT ID FROM (SELECT NULL v UNION ALL SELECT 1) t1)SELECT *FROM dbo.T WHERE NOT EXISTS ( SELECT ID FROM (SELECT NULL v UNION ALL SELECT 1) t1 WHERE ID = v)--DROP TABLE T 上圖可以看到在T資料表中有兩筆資料，如果我們使用NOT IN和NOT EXISTS結果會不一樣，原因是使用NOT IN在判斷NULL時會造成NULL&lt;&gt;任何值,所以就撈不出任何資料，相反使用NOT EXISTS取得的結果就符合我們預期. 避免在Where條件中對欄位進行操作運算@col &gt; ‘’ 替代 @col NOT NULL AND &lt;&gt; ‘’我們會有一種需求須要判斷此 12345678910111213141516171819202122232425262728CREATE TABLE T( Col VARCHAR(50))INSERT INTO TSELECT TOP 100000 NULLFROM sys.all_columns c1CROSS JOIN sys.all_columns c2INSERT INTO T VALUES ('DANIEL')INSERT INTO T VALUES ('DANIEL2')INSERT INTO T VALUES ('')INSERT INTO T VALUES ('')--CREATE INDEXCREATE INDEX IX_Col on dbo.T( Col)SELECT *FROM dbo.TWHERE col &gt; ''SELECT *FROM dbo.TWHERE col IS NOT NULL AND col &lt;&gt; ''--DROP TABLE T 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/DBNote/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>DataBase</category>
        <category>Turning</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Turning</tag>
        <tag>Sql-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SqlServer資料表深入淺出]]></title>
    <url>%2FDBTable%2F</url>
    <content type="text"><![CDATA[前文本篇會跟大家對於SQL-Server資料表深入淺出的介紹. 關於子頁層資料會存在子頁層中(page),一個Page大小為 8K/Page =&gt; 8092(8060 bytes) 每個Page除了存取資料還會存放一些MetaData，我們可以先當作是每個Page大小是8K Heap資料表如果一張資料表沒有Clustered Index就會為Heap資料表，這意味著Heap資料表的資料不會有排序一直把資料新增進資料表中，Heap資料表Insert資料快 適合使用在Log資料表、Event資料表、稽核資料表….一直新增資料但比較少查詢表 IAM(index allocation map)當Heap資料表要搜尋資料SQL-Server透過IAM(index allocation map)去尋要掃描Page範圍，因為IAM會以範圍存在於檔案中的順序來表示它們，這代表循序的堆積掃描都將依檔案順序進行。 使用IAM分頁設定掃描順序也表示堆積中的資料列通常不會依插入順序傳回 IAM Page在讀取資料的示意圖 可以看到讀取Page中資料順序和新增資料順序不一樣. forwarding pointer假如在Heap資料表更新欄位資料，就可能會造成forwarding pointer 製造forwarding pointer是因為原本Page塞不下更新後資料就會先把資料搬到另一個新建立Page上並在原本Page建立一個類似指標東西指向它. 這個指標會存在原本的Page大小是16 byte forwarding pointer(Demo)一個Page大小是8k 我們建立一個ForwardingPointers資料表，並且新增3筆資料進去 其中有一筆資料replicate(&#39;2&#39;,7800)佔據78xxBytes. 12345678create table dbo.ForwardingPointers( ID int not null, Val varchar(8000) null);insert into dbo.ForwardingPointers(ID,Val)values(1,null),(2,replicate('2',7800)),(3,null); 新增完後我們利用DMV查詢目前ForwardingPointers使用的Page數量可以看到只使用一頁 因為目前資料大小可以放在同一個Page 1234select page_count, avg_record_size_in_bytes, avg_page_space_used_in_percent ,forwarded_record_countfrom sys.dm_db_index_physical_stats(db_id(),object_id(N'dbo.ForwardingPointers'),0 ,null,'DETAILED'); 我們將dbo.ForwardingPointers另外兩個Val IS NULL更新成replicate(&#39;2&#39;,7800) 123UPDATE dbo.ForwardingPointersSET Val = replicate('2',7800)WHERE Val IS NULL 再查詢一次dbo.ForwardingPointers使用Page，能發現已經使用了3個Page(因為已經觸發forwarding pointer) 已經把這次更新的資料搬到新Page上，因為更新後的資料大小已經超過目前Page可以負擔的大小 RID Lookup在資料庫索引深入淺出(一)有說，資料表沒有Clustered Index且使用Index所有查詢欄位不包含在Converting Index中就會透過RID Lookup查找確切Page上的Row(藉由Row-Id) 此資料表是Heap資料表在NonClustered Index中會存放Heap RID 記得在DBCC IND取得的PID是要找PageType = 2 123DBCC traceon (3604);DBCC IND ([Your DataBase],T1,-1)DBCC PAGE([Your DataBase],1,[Your PID],3) 透過DBCC可以看到查找資料表Page資料可以顯示如下結果集. 如果是Heap資料表會有一個欄位是Heap RID(Key)欄位. HEAP RID:0x40110F0001002900大小 8 bytes FID（2 bytes） PID（4 bytes） SLOT（2 bytes） 可藉由下面的Script來拆解Heap RID(Key)資料 1234567891011121314151617--轉換RID為 FID:PID:slot格式declare @Heaprid binary(8)set @Heaprid = 0x40110F0001002900select [FID:PID:Slot]= CONVERT (VARCHAR(5), CONVERT(INT, SUBSTRING(@Heaprid, 6, 1) + SUBSTRING(@Heaprid, 5, 1))) + ':' + CONVERT(VARCHAR(10), CONVERT(INT, SUBSTRING(@Heaprid, 4, 1) + SUBSTRING(@Heaprid, 3, 1) + SUBSTRING(@Heaprid, 2, 1) + SUBSTRING(@Heaprid, 1, 1))) + ':' + CONVERT(VARCHAR(5), CONVERT(INT, SUBSTRING(@Heaprid, 8, 1) + SUBSTRING(@Heaprid, 7, 1))) 透過上面Script我們可以得到1:987456:41 我們在透過 1DBCC PAGE(AdventureWorks2012_Data,1,987456,3) 就可以查找到我們要的資料在PID = 987456這個Page中. dbcc page 語法下面語法透過dbcc page可以了解資料表存取資訊 123456789101112131415161718192021222324252627282930/* 建立測試資料表 */drop table if exists dbo.T;create table dbo.T( Name nvarchar(10) not null, EmpID int not null, CouID int not null, Locate nchar(2) not null, Dist nchar(1) not null, BDate datetime not null, Address nvarchar(100) null, CheckID int not null);go/* 寫入測試資料 */insert into dbo.T (Name, EmpID, CouID, Locate, Dist, BDate, Address, CheckID)values (N'Daniel',1,950,N'TW',N'M','2020-01-01 00:00:00',N'Taipei City',9);go/* 先取得Page的位置 */dbcc ind ('DEMO','dbo.T', -1);/* 16776 - 不會一樣, 依照產出的資料配置dbcc page *//* 查看Page內容 */dbcc traceon (3604);dbcc page ('DEMO', 1, 16776, 3)dbcc traceoff (3604); PageType – the page type. Some common ones are: 1 – data page 2 – index page 3 and 4 – text pages 8 – GAM page 9 – SGAM page 10 – IAM page 11 – PFS page 12dbcc traceon (3604);DBCC IND ( &#123; ‘dbname’ | dbid &#125;, &#123; ‘objname’ | objid &#125;,&#123; nonclustered indid | 1 | 0 | -1 | -2 &#125; [, partition_number] ) 第一個參數是數據庫名或數據庫ID。 第二個參數是數據庫中的對象名或對象ID，對象可以是表或者索引視圖。 第三個參數是一個非聚集索引ID或者 1, 0, 1, or 2. 值的含義： 0: 只顯示對象的in-row data頁和 in-row IAM 頁。 1: 顯示對象的全部頁, 包含IAM 頁, in-row數據頁, LOB 數據頁row-overflow 數據頁 . 如果請求的對象含有聚集所以則索引頁也包括。 -1: 顯示全部IAM頁,數據頁, 索引頁 也包括 LOB 和row-overflow 數據頁。 -2: 顯示全部IAM頁。 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/DBTable/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>DataBase</category>
        <category>Turning</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Turning</tag>
        <tag>Sql-server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[資料庫索引深入淺出(二)]]></title>
    <url>%2FDBIndex-2%2F</url>
    <content type="text"><![CDATA[Agenda 前文 Covering Index 加入INCLUDE欄位含意 案例解說 Filter Index filter index的限制 Index Intersection Primary Key 前文本系列文章 資料庫索引深入淺出(一) 資料庫索引深入淺出(二) 兩種基本索引 Clustered Index(叢集索引) NonClustered Index(非叢集索引) 兩種Lookup(如果NonClustered Index無法滿足查詢結果執行) RID Lookup Key Lookup 本篇會介紹其他種類Index Covering Index我們先來看看Covering Index語法. 最主要使在NONCLUSTERED INDEX後面加上INCLUDE欄位. 123456CREATE NONCLUSTERED INDEX IX_T_Id_Convering on dbo.T( id) INCLUDE ( UserId, UserGroup) 加入INCLUDE欄位含意在NONCLUSTERED INDEX把Column加入INCLUDE區域後此NONCLUSTERED INDEX會把此欄位資料加入至子頁層.之後如果要查找資料時就不用在Lookup回去 所以我們可以把Covering Index當作是偽CLUSTERED INDEX. 如果每次只需要SELECT少部分欄位且範圍較大又須排序，Covering Index執行效率會比CLUSTERED INDEX來的快. Covering欄位只會在子頁層儲存資料，並不會在中葉層儲存相關資訊。 儲存方式如下圖會把資料存在子頁層中，並不會把Include資料存在中葉層 適合Covering Index很適合用在查出來Column不需要當作Key 案例解說樣本資料一樣使用上一篇的資料 1234567SELECT *FROM dbo.TWHERE id = 10000SELECT *FROM dbo.T with(index(IX_T_Id))WHERE id = 10000 有兩段語法一段是有使用Hint，執行出來後會有兩個執行計畫. 第一個執行計畫是上面的語法,第二個執行計畫是下面的語法 建立完Convering Index後我們使用的查詢就會變成只使用Seek，而且在執行成本也大幅降低. Filter Index在SQL-Server 2008之後,支援使用filter index.他可以節省index大小和維護成本 Filter Index語法就是在最後寫where條件 1234567CREATE NONCLUSTERED INDEX FIX_T_Id_UserGroup on dbo.T( id) INCLUDE ( UserId, UserGroup)where UserGroup = 8 上面語法意思是只針對於UserGroup = 8的Row建立資料在子頁層，Filter Index主要是提升維護性和降低Index大小. filter index的限制 filter index只支援簡單過濾條件，在where查詢如果有使用到OR、function、計算欄位,可能會讓filter index失效 因為sql-server會cache執行計畫,所以filter index無法在參數化查詢發揮作用 關於第二點我們可以看下面查詢,假如我們建立一個fitler index(IDX_Data_Unprocessed_Filtered)因為我們使用參數化查詢所以導致此index無法正常發揮 123456789create nonclustered index IDX_Data_Unprocessed_Filteredon dbo.Data(RecId)include(Processed)where Processed = 0;select top 1000 RecIdfrom dbo.Datawhere Processed = @Processedorder by RecId; 所以假如此查詢有使用到filter index請在查詢使用硬變數或是可以使用option(recompile)不讓執行計畫被cache. 12345678910select top 1000 RecIdfrom dbo.Datawhere Processed = 0order by RecId; select top 1000 RecIdfrom dbo.Datawhere Processed = @Processedorder by RecId; option(recompile) 注意:如果有使用到Filter Index的SP或Script，如果沒有加上SET QUOTED_IDENTIFIER ON就會造成錯誤，所以在撰寫Script時要養成加上面語法的好習慣. Index IntersectionSQL-Server可透過多個Index完成一段查詢(通常選擇子集合較小)在透過JOIN完成查詢 假如我們有兩個一個查詢會用到UserId和Id Column當作條件我們可能會建立下面這個索引. 1234CREATE CLUSTERED INDEX IX_T_UserId_Id on dbo.T( UserId, Id) 但除了同時利用UserId和Id Column當作條件外還可能個別當作查詢條件. 我們就可以考慮把這個Index拆開成兩個，這樣可以提高索引使用率（因為執行計畫透過統計值來產生，而Index統計值計算是由Index第一個Column來當計算） 注意:把Index猜成兩個或許可以增加查詢效率，但每個Index就是一個B+ Tree這會造成 1234567CREATE CLUSTERED INDEX IX_T_UserId on dbo.T( UserId)CREATE CLUSTERED INDEX IX_T_Id on dbo.T( Id) Primary Key在SQL-Server很常使用PRIMARY KEY但你知道他代表甚麼含意嗎? PRIMARY KEY是也是一個Index，他可以設定NonClustered Index或是Clustered Index PRIMARY KEY有幾個特徵 資料不能重複(Unique) Columns都必須定義成NOT NULL PRIMARY KEY是一個Index 預設建立的PRIMARY KEY是Clustered Index，但我們使用語法自行建立為NonClustered Index的PRIMARY KEY 如下範例我們可以建立一個NONCLUSTERED的PRIMARY KEY 123456CREATE TABLE T( ID INT NOT NULL, CONSTRAINT [PK_T] PRIMARY KEY NONCLUSTERED ( ID )) 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/DBIndex-2/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>DataBase</category>
        <category>Turning</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Turning</tag>
        <tag>Sql-server</tag>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[資料庫索引深入淺出(一)]]></title>
    <url>%2FDBIndex-1%2F</url>
    <content type="text"><![CDATA[Agenda 前文 Index使用的資料結構(B+ tree) Index優缺點 Clustered Index(叢集索引) NonClustered Index(非叢集索引) RID Lookup Key Lookup 範例演示 建立一個 NonClustered Index 再建立一個 Clustered Index 前文Index第一個欄位至關重要它會影響資料統計值結果，Index一般建立在查詢條件的欄位 每個Index都擁有自己的B+ tree. Index使用的資料結構(B+ tree)B+ tree是一種資料結構這個資料結構被Index拿來使用，關於B+ tree網路上有很多資源可再自行尋找，所以我們來談談為什麼DataBase會使用B+ tree 在Wiki講述B+ tree有其中一段 B+ tree是能夠保持資料穩定有序，其插入與修改擁有較穩定的對數時間複雜度。B+ tree元素由下而上插入，通過最大化在每個內部節點內的子節點的數目減少樹的高度，平衡操作不經常發生，而且效率增加了。這種價值得以確立通常需要每個節點在次級儲存中占據完整的磁碟塊或近似的大小。 簡白來說B+ tree有一個特性是他會把資料存在子頁中並且透過連結把每個子頁串聯起來，提高他的穩定度. B+ tree資料結構如下圖，這個資料結在在範圍查詢時較B tree來的更穩定 Index真正在使用B+ tree儲存類似於下圖 此圖來自(Pro SQL Server Internals, 2nd edition) Index優缺點建立太多Index，小心降低新增、更新效率，Index可以加快查詢速度，是Index以空間換取時間。 基本上它使用的資源如下: 每個Index都會建立一顆 b+ tree 每次新增、更新資料時都會改變 b+ tree 所以當你Index越多時，你需要維護的Index越多(代表需要更多資源來維護) Clustered Index(叢集索引)每個資料表只能有一個Clustered index，資料表會依照Clustered index方式存放排列資料，Clustered Index跟資料一起放置在Left子頁層 Cluster index好比書籍頁碼目錄。每本書只能有一個目錄 建立Clustered Index欄位有幾個重點 常用於查詢欄位 可識別度高(唯一性較高) NonClustered Index(非叢集索引)每個資料表能有許多NonClustered Index，像每本書可以有很多種附錄 例如依照字母排序 依照附錄A 附錄B NonClustered Index按照Key Column排序， NonClustered Index(index page)上所有分葉節點存放指標，如果資料表已存在Clustered Index(KeyID)，那麼該指標將會指Clustered Index，如不存在將指向資料真實存放位置(RID) this is a very important point to remember. Nonclustered indexes do not store information about physical row location when a table has a clustered index. They store the value of the clustered index key instead. 上面簡單來說如果NonClustered Index沒有包含所有要查詢欄位 有Clustered Index，會執行Key Lookup 沒有Clustered Index，會執行RID Lookup 這裡的RID是指向真實資料位子RowID RID Lookup資料表沒有Clustered Index且使用Index所有查詢欄位不包含在Converting Index中就會透過RID Lookup查找確切Page上的Row(藉由Row-Id) RID Key的大小8 byte lookup會消耗Disk I/O，所以消耗成本相對會比較大. 沒有Clustered Index的資料表我們稱為Heap資料表 Key LookupNonClustered Index中會存放此Row在Clustered Index相對位置，假如單單靠搜尋Non-Clustered Index沒有辦法滿足所有查詢需要資料就會去Key Lookup(by Clustered key)回找Clustered Index取出相對應的資料. 範例演示我們先準備10000筆樣本資料 12345678910CREATE TABLE T( Id INT identity(1,1), UserId INT, UserGroup INT)INSERT INTO T (UserId,UserGroup)SELECT TOP 10000 1.0 + floor(10000 * RAND(convert(varbinary, newid()))), (1.0 + floor(10000 * RAND(convert(varbinary, newid())))/1000)+1FROM sys.all_columns t1 CROSS JOIN sys.all_columns t2 建立完資料後我們利用下面條件來查找資料. 123SELECT *FROM dbo.TWHERE id = 10000 因為沒有建立Index，導致我明明只需要撈取一筆資料,但資料庫卻全表掃描 建立一個 NonClustered Index我們在表中建立了一個NonClustered Index，並利用相同查詢語法查詢資料 123CREATE NONCLUSTERED INDEX IX_T_Id on dbo.T( id) 建立完NonClustered Index後從原本的全表掃描變成RID Lookup和Index Seek，因為NonClustered Index的B+ Tree沒有包含所有需要撈取的資料.所以透過RID回去Heap資料表查找出所需要的欄位 RID Lookup在執行計畫中呈現如下圖， 再建立一個 Clustered Index我們在T資料表中建立一個Clustered Index，並且執行相同查詢 123CREATE CLUSTERED INDEX CIX_T_UserId on dbo.T( UserId) 能看到執行計畫的不同了，已經透過Key Lookup回去查找資料，原因是目前資料表已經有Clustered Index但此查詢使用條件使用NonClustered Index所以導致需要Lookup回去Clustered Index的B+ Tree查找資料 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/DBIndex-1/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>DataBase</category>
        <category>Turning</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
        <tag>Turning</tag>
        <tag>Sql-server</tag>
        <tag>Index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Null Object Pattern]]></title>
    <url>%2FNullObjectPattern%2F</url>
    <content type="text"><![CDATA[前言:假如在系統中null散佈在有許多地方且null有相對應的邏輯或行為.這時候就很適合使用NullObject Pattern來解決，已Null Object取代null邏輯. Null可能引申出來問題我們知道在.Net或Java中大部分都是參考類型,而null是參考類型的預設值，我們來看看以下程式. 12Person p = null;Console.WriteLine(p.Age); 如果物件p指向null且取得p.Age時就會throw NullReferenceException，所以我們在使用一些參考類型物件前都會先判斷此物件是否為null，在執行後續邏輯. 在系統中某一兩個地方這樣判斷還好，但如果一直重複這樣的判斷會造成程式碼不必要的膨脹…. 相較於「不帶有null邏輯」的程式碼，面對null邏輯往往需要花費更多心力. 範例程式下面有段程式碼在calculate方法中會判斷CartModel物件是否為null並執行相對應邏輯 12345678910111213141516public class PaymentServiceNormal&#123; public decimal calculate(CartModel model) &#123; decimal result = 0m; if (model == null) return result; result = model.Items.Sum(x =&gt; x.Price); if (result &gt; 400m) result *= 0.8m; return result; &#125;&#125; 我們可以將calculate方法提取出一個介面並對於null部份提取成一個類別實現此介面 能看到NullPayment這個類別已經被賦予相對應動作操作. 12345678910111213141516171819202122232425public interface IPaymentService&#123; decimal calculate(CartModel model);&#125;public class PaymentService : IPaymentService&#123; public decimal calculate(CartModel model) &#123; decimal result = model.Items.Sum(x =&gt; x.Price); if (result &gt; 400m) result *= 0.8m; return result; &#125;&#125;public class NullPayment : IPaymentService&#123; public decimal calculate(CartModel model) &#123; return 0m; &#125;&#125; 在使用時我們就可統一判斷是否為null來給予相對應物件 這邊有點像是策略者模式(Strategy pattern)，判斷要使用哪個邏輯，邏輯統一封裝到類別中. 123456789101112131415161718class Program&#123; static void Main(string[] args) &#123; CartModel model = null; Console.WriteLine(Calculate(model)); Console.ReadKey(); &#125; static decimal Calculate(CartModel model) &#123; var paymentService = model == null ? (IPaymentService) new NullPayment() : new PaymentService(); return paymentService.calculate(model); &#125;&#125; NullObject Pattern缺點:如果團隊工程師不知道目前程式碼已經存在NullObject實作，會寫出多餘的null測試.如果目前系統只是需要少量對於null做判斷，這時導入NullObject會導致程式碼變得複雜. 小結:假如系統中有許多地方需要判斷null並處理相對應的動作就很適合使用NullObject Pattern，但如果判斷null地方不是很多還是判斷就好了 程式碼範例 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/NullObjectPattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>NullObjectPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鐵人賽完賽＆總結 (第30天)]]></title>
    <url>%2FIthelp-day30%2F</url>
    <content type="text"><![CDATA[Agenda 完賽感想 感謝這次的夥伴 [IT成長團] 學習到新知識 (Expression表達式) 設計模式運用在實戰中 透過MVC某區塊概念,引發建立開源專案想法 文章目錄 01 ~ 08 Day 介紹Http請求到MVC前Asp.net做了些什麼事情 09 ~ 25 Day 介紹MVC原始碼 26 ~ 29 Day 對於MVC進行擴充改造 完賽感想這三十天無法對於MVC全部原始碼做詳細介紹,我盡量在這三十篇講述MVC執行過程中重要知識點,閱讀MVC原始碼真不是很簡單事情. 但閱讀完後我對於OOP和如何合理撰寫程式碼一個系統有更深入了解(因為MVC很多地方很好運用OOP概念原則) 希望大家經過閱讀這三十篇文章可以對於IIS託管和Asp.net MVC原理有更深入了解. Http對於IIS Server請求如何導向Asp.net MVC執行 Asp.net MVC原始碼有基本了解和知道哪幾個重要類別,了解後能依照系統需要替換改寫. Asp.net MVC用到很多設計技巧,希望大家能更了解設計模式如何運用在實戰中 可以嘗試閱讀其他知名的開源框架(Dapper,AutoMapper,Autofac,Json.net…..) 如果想要了解Dapper原理讀者我推薦去閱讀,我隊友暐翰系列文章進階學習 ADO.NET、Dapper、Entity Framework 系列寫得很詳細且有影片教學大推!! 感謝這次的夥伴 [IT成長團]感謝這次可以跟IT成長團的大家一起參與並完成It邦幫忙鐵人活動. 這三十天大家一起鼓勵,互相叮嚀鼓勵.這種感覺真的很棒 :) 下面是隊友們寫的優質系列文章,推薦大家一同去閱讀. 小魚 :Laravel從入門到放棄…………原生PHP (疑? 暐翰 :進階學習 ADO.NET、Dapper、Entity Framework Peter學程式 :超緊繃!30天Vue.js學習日記 神Q超人 :在 React 生態圈內打滾的一年 feat. TypeScript Victor :使用 Laravel 打造 RESTful API 希望明年還有機會可以跟大家一起在參加鐵人賽衝一波,寫文章. 學習到新知識 (Expression表達式)以前碰到動態建立物件或動作,我都是使用反射技巧來完成,透過了解ActionMethodDispatcher類別原始碼探討為何MVC不使用反射卻,而使用Expression表達式完成動態呼叫需求. 查了資料進而了解到Expression表達式用法且他想解決的問題,對於未來有多了一項武器可以運用. 設計模式運用在實戰中設計模式不是紙上談兵,某些問題會使用某些方法來解決. 筆者對於設計模式也略有研究,對於DesignPattern有一個Repository做介紹,陸陸續續會補上我對於Design Pattern在現實生活上理解 MVC使用的許多設計模式和技巧,使用這些模式為了可讓程式變得好理解有意義 商業邏輯讓程式變複雜是必然,我們能做的是讓程式碼變得不會太難理解可以更好擴充 每個設計模式都有適合使用場景. 工廠模式: 將使用動作和產生物件做一個區隔(依賴一個抽象). 代理模式: 提供一個代理人不用對於原有程式碼進行修改(AOP就是利用此模式概念) 裝飾者模式: 適合在需要一直改變物件狀態的情境 建立者模式: 提供一個建立管道讓使用的提供要建立物件,最後可透過此模式來方便替換 還有許多模式就不一一介紹 像我很久之前就學過組合模式,只是對於此模式運用場景一直找不到. 直到看到複雜模型和簡單模型綁定如何將組合模式運用在實戰中. 透過MVC某區塊概念,引發建立開源專案想法筆者看完Filter機制後就有感而發,這麼好用的方式可否運用在Service或其他地方(非Asp.net MVC,Web API區域). 我就依照上面標籤概念建立一個AwesomeProxy.NetAOP框架基於RealProxy這個物件. 想知道詳細資訊的讀者可自行查閱AwesomeProxy.Net的Readme.md. 看完三十篇分享文後,希望台灣會有越來越多大大投入開源社群,我個人感觸是投入社群後我觸碰,接觸事物比我想想遠遠多很多. 文章目錄此系列文分成三大部分 01 ~ 08 Day 介紹Http請求到MVC前Asp.net做了些什麼事情[Day01] (開賽)Http 請求 Asp.net IIS伺服器架構 [Day02] Asp.Net支柱 IHttpMoudle &amp; IHttphandler [Day03] 啟動吧!Asp.Net IsapiRunTime &amp; HttpRuntime [Day04] 掌控HttpApplication物件建立 - HttpApplicationFactory [Day05] Asp.Net重要物件HttpApplication(一) 初始化建立IHttpMoudule [Day06] Asp.Net重要物件HttpApplication(二) 建置執行管道 [Day07] Asp.Net重要物件HttpApplication(三) 取得執行的IHttpHandler [Day08] 揭密Mvc使用IHttpHandler by UrlRoutingModule-4.0 09 ~ 25 Day 介紹MVC原始碼[Day09] 進入MVC原始碼世界 Route &amp; RouteTable 原始碼解析 [Day10] 透過MvcRouteHandler取得呼叫IHttphandler [Day11] Asp.net MVC Controller是怎麼被建立(原始碼揭密) [Day12] 談談Controller幾個重要成員 [Day13] Asp.net MVC如何實現IOC解析器 [Day14] 反轉起來~透過IOC解析來執行依賴反轉 [Day15] Action方法如何被執行InvokeAction(一) [Day16] MVC Filter 機制解密 [Day17] Action方法如何被執行InvokeAction(二) [Day18] 提供ModelBing幾個重要功臣(Model) [Day19] Http參數如何綁定到Action參數上(簡單和複雜模型綁定探討) [Day20] 探討Model上客製化標籤如何被解析使用 [Day21] Model 探討驗證標籤(ValidationAttribute) [Day22] View是如何被建立(一) [Day23] 6個基本(ActionResult) View是如何被建立(二) [Day24] 探討ViewEngine機制 View是如何被建立(三) [Day25] 動態產生程式碼(WebViewPage) View是如何被建立(四) 26 ~ 29 Day 對於MVC進行擴充改造[Day26] 動手DIY改造 Asp.net MVC- Route解析機制 [Day27] 動手DIY改造 Asp.net MVC- 自己動作建立一個DependencyResolver解析器(Autofac) [Day28] 動手DIY改造 Asp.net MVC- 建立自己ActionInvoker和Model綁定機制 [Day29] 動手DIY改造 Asp.net MVC- 擴充在擴充,強化WebViewPage製作多國貨幣機制 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day30/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[動手DIY改造 Asp.net MVC- 擴充在擴充,強化WebViewPage製作多國貨幣機制 (第29天)]]></title>
    <url>%2FIthelp-day29%2F</url>
    <content type="text"><![CDATA[Agenda 前言 多國路由設定 取得貨幣符號 擴充 WebViewPage RazorView使用擴充後WebViewPage 小結: 前言View頁面(razor,aspx…)都是繼承WebViewPage&lt;TModel&gt;頁面, 今天會帶大家寫一個範例完成透過Route判斷多國錢幣符號. 多國路由設定在Route設定上多一個{culture}區塊.如果使用者沒有輸入預設使用英文(en). 1234routes.MapRoute( name: "Default", url: "&#123;culture&#125;/&#123;controller&#125;/&#123;action&#125;", defaults: new &#123; controller = "Home", action = "Index", culture = "en" &#125;); 取得貨幣符號建立一個介面ICurrency裡面有個方法可以取得傳入國家貨幣符號. 在CurrencyProvider類別透過Routes.Values[&quot;culture&quot;]取得使用者傳遞語系國家. 透過此參數可以知道使用者想要使用哪個國家貨幣. 1234567891011121314151617181920212223242526272829public interface ICurrency&#123; string GetCurrencySymbol();&#125;public class CurrencyProvider : ICurrency&#123; public string GetCurrencySymbol() &#123; HttpContextBase contextWrapper = new HttpContextWrapper(HttpContext.Current); string culture = RouteTable.Routes.GetRouteData(contextWrapper)?.Values["culture"] as string; return GetSymbol(culture); &#125; private string GetSymbol(string culture) &#123; switch (culture) &#123; case "en": return "$"; case "eu": return "£"; default: return "$"; &#125; &#125;&#125; 擴充 WebViewPage在Autofac多註冊一個 12builder.RegisterType&lt;CurrencyProvider&gt;().As&lt;ICurrency&gt;();DependencyResolver.SetResolver(new CustomerDependencyResolver(builder.Build())); 最後在建立一個CountryViewPage&lt;TModel&gt;抽象類別繼承於WebViewPage&lt;TModel&gt;. 在此類別中建立一個ICurrency屬性,並在建構子中透過DependencyResolver.Current.GetService給值 因為這間已經替換成Autofac解析器,所以會吃Autofac註冊的類別. 12345678public abstract class CountryViewPage&lt;TModel&gt; : WebViewPage&lt;TModel&gt;&#123; public CountryViewPage() &#123; Currency = DependencyResolver.Current.GetService&lt;ICurrency&gt;(); &#125; public ICurrency Currency &#123; get; &#125;&#125; RazorView使用擴充後WebViewPage在View上使用新WebViewPage&lt;TModel&gt;只需要在最上面加@inherits CountryViewPage&lt;object&gt;.我們就可以透過@呼叫Currency物件. 12345678910@inherits CountryViewPage&lt;object&gt;@&#123; ViewBag.Title = "About";&#125;&lt;h2&gt;@ViewBag.Title.&lt;/h2&gt;&lt;h3&gt;@ViewBag.Message @Currency.GetCurrencySymbol()&lt;/h3&gt;&lt;p&gt;Use this area to provide additional information.&lt;/p&gt; 如果每個頁面都需要使用新的WebViewPage&lt;TModel&gt;可以透過web.config新增加一個&lt;pages pageBaseType=&quot;CountryViewPage&quot;&gt;將Razor產生的C#程式碼繼承於此類別 12345678910&lt;system.web.webPages.razor&gt; &lt;pages pageBaseType="CountryViewPage"&gt; &lt;namespaces&gt; &lt;add namespace="System.Web.Mvc" /&gt; &lt;add namespace="System.Web.Mvc.Ajax" /&gt; &lt;add namespace="System.Web.Mvc.Html" /&gt; &lt;add namespace="System.Web.Routing" /&gt; &lt;/namespaces&gt; &lt;/pages&gt;&lt;/system.web.webPages.razor&gt; 小結:其實我們也可以繼承WebViewPage&lt;TModel&gt;來擴充View多變性 這邊有一個題目提供讀者來完成透過上面概念完成多國語系,這裡提供一條方法完成 寫一個string transfer(string key)透過Resource檔案來完成; Github範例程式原始碼 CustomerWebViewPage分支上 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day29/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[動手DIY改造 Asp.net MVC- 建立自己ActionInvoker和Model綁定機制 (第28天)]]></title>
    <url>%2FIthelp-day28%2F</url>
    <content type="text"><![CDATA[Agenda 前言 建立自己的IActionInvoker(CustomerActionInvoker) 進行呼叫測試 改進GetValueTypeInstance方法(建立ValueProvider) 建立一個ValueProviderBase抽象類別 似成相識IValueProvider介面 小結: 前言今天要分享對於ActionInvoker進行替換成自己客制化的IActionInvoker 在MVC原始碼中有個CreateActionInvoker方法來取得一個IActionInvoker物件,可以看到她會先透過Resolver.GetService從解析器中取得我們的IActionInvoker如果沒有在new一個AsyncControllerActionInvoker物件. 123456789101112131415161718protected virtual IActionInvoker CreateActionInvoker()&#123; IAsyncActionInvokerFactory asyncActionInvokerFactory = Resolver.GetService&lt;IAsyncActionInvokerFactory&gt;(); if (asyncActionInvokerFactory != null) &#123; return asyncActionInvokerFactory.CreateInstance(); &#125; IActionInvokerFactory actionInvokerFactory = Resolver.GetService&lt;IActionInvokerFactory&gt;(); if (actionInvokerFactory != null) &#123; return actionInvokerFactory.CreateInstance(); &#125; // Note that getting a service from the current cache will return the same instance for every request. return Resolver.GetService&lt;IAsyncActionInvoker&gt;() ?? Resolver.GetService&lt;IActionInvoker&gt;() ?? new AsyncControllerActionInvoker();&#125; 我們解析器一樣使用Autofac容器來幫我們完成(程式碼會基於昨天Autofac範例往上擴充) 建立自己的IActionInvoker(CustomerActionInvoker)在取得IActionInvoker首先會透過Resolver解析器來取得,這就提供我們一個可替換接口. 藉由這個機制讓我們可以重寫自己ActionInvoker物件. 我們自行撰寫的CustomerActionInvoker支援簡單模型綁定(這個版本支援由Request.Form和Request.QueryString參數綁定) 首先利用反射先取得呼叫Action方法資訊,我再呼叫BindModel利用linq對於Action方法需要參數進行動態綁定 BindModel方法中先判斷目前參數型別是否是字串型別,如果是透過GetValueTypeInstance從ValueProvider(Request.Form和Request.QueryString)取值,如果方法使用參數非簡單型別參數就會呼叫SimpleModelBinding方法 SimpleModelBinding利用反射動態建立此物件,取得此物件屬性資訊並一一把值給填充到屬性上. 在SimpleModelBinding會判斷屬性型別和可否寫入!property.CanWrite || IsSimpleType(property)來填值. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class CustomerActionInvoker : IActionInvoker&#123; public bool InvokeAction(ControllerContext controllerContext, string actionName) &#123; //取得執行Action方法 MethodInfo method = controllerContext.Controller .GetType() .GetMethods() .First(m =&gt; string.Compare(actionName, m.Name, StringComparison.OrdinalIgnoreCase) == 0); //取得Action使用的參數,並利用反射將值填充 var parameters = method.GetParameters().Select(parameter =&gt; BindModel(controllerContext, parameter.Name, parameter.ParameterType)); ActionResult actionResult = method.Invoke(controllerContext.Controller, parameters.ToArray()) as ActionResult; actionResult.ExecuteResult(controllerContext); return true; &#125; private object BindModel(ControllerContext controllerContext,string modelName, Type modelType) &#123; if (modelType.IsValueType || typeof(string) == modelType) &#123; object instance; if (GetValueTypeInstance(controllerContext, modelName, modelType, out instance)) &#123; return instance; &#125; return Activator.CreateInstance(modelType); &#125; return SimpleModelBinding(controllerContext, modelType); &#125; private object SimpleModelBinding(ControllerContext controllerContext, Type modelType) &#123; object modelInstance = Activator.CreateInstance(modelType); foreach (PropertyInfo property in modelType.GetProperties()) &#123; //針對基本型別或string型別給值 if (!property.CanWrite || IsSimpleType(property)) &#123; object propertyValue; if (GetValueTypeInstance(controllerContext, property.Name, property.PropertyType, out propertyValue)) &#123; property.SetValue(modelInstance, propertyValue); &#125; &#125; &#125; return modelInstance; &#125; private bool GetValueTypeInstance(ControllerContext controllerContext, string modelName, Type modelType, out object value) &#123; var form = controllerContext.RequestContext.HttpContext.Request.Form; var queryString = controllerContext.RequestContext.HttpContext.Request.QueryString; string key = form.AllKeys.FirstOrDefault(x =&gt; string.Compare(x, modelName, StringComparison.OrdinalIgnoreCase) == 0); if (key != null) &#123; value = Convert.ChangeType(form[key], modelType); return true; &#125; string queryKey = queryString.AllKeys.FirstOrDefault(x =&gt; string.Compare(x, modelName, StringComparison.OrdinalIgnoreCase) == 0); if (queryKey != null) &#123; value = Convert.ChangeType(queryString[queryKey], modelType); return true; &#125; value = null; return false; &#125; private static bool IsSimpleType(PropertyInfo property) &#123; return property.PropertyType == typeof(string) || property.PropertyType.IsValueType; &#125;&#125; 最後在Autofac中多註冊一組IActionInvoker,MVC就會使用CustomerActionInvoker而不是原本的ControllerActionInvoker 1builder.RegisterType&lt;CustomerActionInvoker&gt;().As&lt;IActionInvoker&gt;(); 進行呼叫測試我在HomeController下新增一個About方法傳入一個Person類別. 後面請求 http:xxx/Home/About?name=daniel 我們就可以看到方法使用p參數已經可以成功填值瞜 1234567891011public class Person&#123; public string Name&#123; get; set; &#125;&#125;public ActionResult About(Person p)&#123; ViewBag.Message = $"Member &#123;p?.Name??string.Empty&#125; Balance &#123; _service.GetMemberBalance(123)&#125;"; return View();&#125; 改進GetValueTypeInstance方法(建立ValueProvider)在GetValueTypeInstance方法中透過Http上請求獲取資料目前有兩種方式Request.Form和Request.QueryString,我們可以看到上面的方法有許多重複程式碼 這次要做動作是重構把上面重複程式碼提取到一個父類別(長出父類別或介面). 我覺得在物件導向程式設計介面和父類別是長出來,寫一寫code發現有重複的部分就可以考慮提取方法或提取成父類別. 首先我們先對於GetValueTypeInstance進行分析. 1234567891011121314151617181920212223private bool GetValueTypeInstance(ControllerContext controllerContext, string modelName, Type modelType, out object value)&#123; var form = controllerContext.RequestContext.HttpContext.Request.Form; var queryString = controllerContext.RequestContext.HttpContext.Request.QueryString; string key = form.AllKeys.FirstOrDefault(x =&gt; string.Compare(x, modelName, StringComparison.OrdinalIgnoreCase) == 0); if (key != null) &#123; value = Convert.ChangeType(form[key], modelType); return true; &#125; string queryKey = queryString.AllKeys.FirstOrDefault(x =&gt; string.Compare(x, modelName, StringComparison.OrdinalIgnoreCase) == 0); if (queryKey != null) &#123; value = Convert.ChangeType(queryString[queryKey], modelType); return true; &#125; value = null; return false;&#125; 發現到下面這段程式碼基本是重複的除了一個是透過form,另一個是透過queryString取得比對取得使用key. 123456string key = form.AllKeys.FirstOrDefault(x =&gt; string.Compare(x, modelName, StringComparison.OrdinalIgnoreCase) == 0);if (key != null)&#123; value = Convert.ChangeType(form[key], modelType); return true;&#125; 看到重複動作就可以考慮提取成抽象並把特徵交給子類別來實現或提供. 建立一個ValueProviderBase抽象類別在下面有一個GetValue方法我們把上面重複的程式碼放進裡面,提供一個abstract NameValueCollection nameValueCollection抽象屬性給自類別提供實現. 因為QueryString和Form都是NameValueCollection型態的集合. 1234567891011121314151617181920212223public abstract class ValueProviderBase&#123; protected ControllerContext _controllerContext; public ValueProviderBase(ControllerContext controllerContext) &#123; _controllerContext = controllerContext; &#125; protected abstract NameValueCollection nameValueCollection &#123; get; &#125; public object GetValue(string modelName,Type modelType) &#123; string key = nameValueCollection.AllKeys.FirstOrDefault(x =&gt; string.Compare(x, modelName, StringComparison.OrdinalIgnoreCase) == 0); if (key != null) &#123; return Convert.ChangeType(nameValueCollection[key], modelType); &#125; return null; &#125;&#125; 建立兩個類別FormValueProvider,QueryStringValueProvider繼承於ValueProviderBase並實現NameValueCollection抽象屬性 FormValueProvider:提供Request.Form QueryStringValueProvider:提供Request.QueryString 1234567891011121314151617public class FormValueProvider : ValueProviderBase&#123; public FormValueProvider(ControllerContext controllerContext) : base(controllerContext) &#123; &#125; protected override NameValueCollection nameValueCollection =&gt; _controllerContext.RequestContext.HttpContext.Request.Form;&#125;public class QueryStringValueProvider : ValueProviderBase&#123; public QueryStringValueProvider(ControllerContext controllerContext) : base(controllerContext) &#123; &#125; protected override NameValueCollection nameValueCollection =&gt; _controllerContext.RequestContext.HttpContext.Request.QueryString;&#125; 最後在GetValueTypeInstance方法會改寫成 123456789101112131415161718private bool GetValueTypeInstance(ControllerContext controllerContext, string modelName, Type modelType, out object value)&#123; List&lt;ValueProviderBase&gt; _valueProvider = new List&lt;ValueProviderBase&gt;() &#123; new FormValueProvider(controllerContext), new QueryStringValueProvider(controllerContext) &#125;; foreach (var valueProvider in _valueProvider) &#123; value = valueProvider.GetValue(modelName, modelType); if (value != null) return true; &#125; value = null; return false;&#125; 建立一個列表存放ValueProvider集合並使用迴圈來一個一個判斷是否有值匹配到. 改寫完後有沒有發覺GetValueTypeInstance方法比上面版本更好理解呢? 我把細部邏輯都封裝到類別中,閱讀上也變得更容易. 似成相識IValueProvider介面還記得之前我們有介紹到一個IValueProvider介面提供一個重要方法GetValue如何從Http請求中取得資料藉由傳入key. 123456789101112131415/// &lt;summary&gt;/// Defines the methods that are required for a value provider in ASP.NET MVC./// &lt;/summary&gt;public interface IValueProvider&#123; /// &lt;summary&gt; /// Determines whether the collection contains the specified prefix. /// &lt;/summary&gt; bool ContainsPrefix(string prefix); /// &lt;summary&gt; /// Retrieves a value object using the specified key. /// &lt;/summary&gt; ValueProviderResult GetValue(string key);&#125; 這次重構IValueProvider很類似之前介紹的IValueProvider介面,上面List&lt;ValueProviderBase&gt;就是之前介紹ValueProviderFactories工廠. 小結:今天利用一個範例建立自己的簡單模型綁定ActionInvoker向大家分享如何建立自己的ActionInvoker只需要透過一個Resolver解析器和繼承IActionInvoker即可完成. 後面再利用重構技巧優化本次程式.希望今天使用到的技巧對於大家有所幫助 設計模式不是把程式碼變簡單而是整理得更有條理(程式碼可能會更複雜但卻很合理,更好去理解複雜邏輯) 一個房間很亂經過整理後東西不會變少(排除丟掉東西),但物品位置會變得更有條理 Github範例程式原始碼 customerActionInvoker分支上 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day28/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[動手DIY改造 Asp.net MVC- 自己動作建立一個DependencyResolver解析器(Autofac) (第27天)]]></title>
    <url>%2FIthelp-day27%2F</url>
    <content type="text"><![CDATA[Agenda 前言 Aufofac依賴注入容器 IDependencyResolver介面 建立CustomerDependencyResolver(IDependencyResolver) CustomerControllerActivator(IControllerActivator) 在Application_Start中MVC替換成自己的解析器 在Controller使用注入 小結： 前言產生Controller物件相關物件關係如下面UML圖 透過ControllerFactory建立一個Controller控制器物件.而ControllerFactory依賴IControllerActivator物件產生Controller. 上面IControllerActivator可以透過建立使用我們的依賴注入容器來替換原本反射產生物件. DependencyResolver是MVC提供的一個可替換物注入點,今天我們會藉由他來我們實現注入MVC方式. Aufofac依賴注入容器在實現自己的DependencyResolver前先談談Autofac容器做甚麼用的? 我之前有寫一篇IOC(控制反轉)，DI(依賴注入) 深入淺出~~,講述IOC(控制反轉)，DI(依賴注入)這兩個設計技巧的理念核心. 言簡意賅可以統一交由容器來幫忙管理物件生命週期和建立方式,也管理物件相依性,兩個重點我們使得只需要提供使用類別的特徵(型別或其他可辨別特徵),容器就提供給我們相對應的物件. 在Autofac有需多使用方式這裡就不一一介紹,有興趣讀者可以上網google或是查閱Autofac官方文件 IDependencyResolver介面DependencyResolver是一個靜態物件,MVC application使用同一個解析器(DefaultDependencyResolver)而他有一個SetResolver方法可以替換成其他DependencyResolver IDependencyResolver有兩個方法需要實現. 12345public interface IDependencyResolver&#123; object GetService(Type serviceType); IEnumerable&lt;object&gt; GetServices(Type serviceType);&#125; MVC依賴於GetService和GetServices,取得物件實例並提供一個抽象提供外部提供修改或擴充. 預設使用(DefaultDependencyResolver)這個解析器來取得我們物件(DefaultDependencyResolver解析器使用Activator.CreateInstance(serviceType);建立物件) 建立CustomerDependencyResolver(IDependencyResolver)這邊我們利用autofac來完成建立物件動作,先建立一個ILifetimeScope _container由建構子注入此物件. 12345678910111213141516171819202122public class CustomerDependencyResolver : IDependencyResolver&#123; private readonly ILifetimeScope _container; public CustomerDependencyResolver(ILifetimeScope container) &#123; if (container == null) throw new ArgumentNullException(nameof (container)); _container = container; &#125; public object GetService(Type serviceType) &#123; return _container.ResolveOptional(serviceType); &#125; public IEnumerable&lt;object&gt; GetServices(Type serviceType) &#123; return (IEnumerable&lt;object&gt;) _container.ResolveOptional(typeof (IEnumerable&lt;&gt;).MakeGenericType(serviceType)); &#125;&#125; 在GetService呼叫ResolveOptional方法透過Type到容器中搜尋匹配的物件並返回. CustomerControllerActivator(IControllerActivator)IControllerActivator有一個Create方法,ControllerFacotry靠它來幫我們產生使用Controller物件,而我們在這邊建立自己IControllerActivator並在Create方法中實現自己得邏輯.透過DependencyResolver來產生物件(替換成CustomerDependencyResolver) 1234567public class CustomerControllerActivator : IControllerActivator&#123; public IController Create(RequestContext requestContext, Type controllerType) &#123; return (IController) DependencyResolver.Current.GetService(controllerType); &#125;&#125; 我們會在Autofac容器註冊目前Assembly所有繼承IController物件. 12//注入typeof(MvcApplication).Assembly 中所有繼承IController物件.builder.RegisterControllers(typeof(MvcApplication).Assembly); 在上面CustomerControllerActivator.Create會透Autofac解析器幫我們建立Controller 在Application_Start中MVC替換成自己的解析器 首先利用ControllerBuilder的SetControllerFactory方法,重新替換使用ControllerFacotry. 在利用builder.RegisterControllers注入typeof(MvcApplication).Assembly中所有繼承IController物件. 註冊IMemberService介面物件(裡面有一個int GetMemberBalance(int memberId);方法來模擬取得會員餘額) DependencyResolver.SetResolver(new CustomerDependencyResolver(builder.Build()))替換成我們使用的解析器 因為ControllerFacotry預設使用DefaultControllerActivator,而我們需要替換成自己建立得CustomerControllerActivator並利用容器來幫我們注入. 12345678910111213141516171819202122public class MvcApplication : HttpApplication&#123; protected void Application_Start() &#123; RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); //把DefaultControllerFactory 中的IControllerActivator替換成我們自己寫的CustomerControllerActivator ControllerBuilder.Current.SetControllerFactory( new DefaultControllerFactory(new CustomerControllerActivator())); AutofacRegister(); &#125; private static void AutofacRegister() &#123; ContainerBuilder builder = new ContainerBuilder(); //注入typeof(MvcApplication).Assembly 中所有繼承IController物件. builder.RegisterControllers(typeof(MvcApplication).Assembly); builder.RegisterType&lt;MemberService&gt;().As&lt;IMemberService&gt;(); //替換成自己的DependencyResolver DependencyResolver.SetResolver(new CustomerDependencyResolver(builder.Build())); &#125;&#125; 在Controller使用注入HomeController控制器中在建構子注入,並呼叫IMemberService.GetMemberBalance方法 執行專案請求Home/About頁面可以看到ViewBag.Message已經成功顯示一個HardCode餘額了. 12345678910111213141516public class HomeController : Controller&#123; private readonly IMemberService _service; public HomeController(IMemberService service) &#123; _service = service; &#125; public ActionResult About() &#123; ViewBag.Message = $"Member Balance &#123; _service.GetMemberBalance(123)&#125;"; return View(); &#125;&#125; 小結：DefaultControllerActivator使用反射建立一個Controller物件 然而IControllerActivator提供一個產生Controller接口,而我們可以藉由實現此介面並使用DependencyResolver靜態物件產生Controller物件(藉由容器框架產生). 最後會把Controller依賴物件藉由依賴注入容器注入進去. Github範例程式原始碼 CustomerContainer分支上 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day27/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[動手DIY改造 Asp.net MVC- Route解析機制 (第26天)]]></title>
    <url>%2FIthelp-day26%2F</url>
    <content type="text"><![CDATA[Agenda 前言 RouteData 建立自己Route機制 小結: 前言UrlRoutingModule對於OnPostResolveRequestCache事件添加一個對於MVC很重要的動作,透過RouteCollection取得此次請求匹配RouteData物件. 利用此RouteData取得要使用的IHttpHandler來執行它. 1RouteData routeData = RouteCollection.GetRouteData(context); RouteCollection是全域路由註冊表.我們在一開始使用MapRoute註冊與之匹配Controller和Action RouteCollection是基於RouteBase物件集合,所以它可以存放所有繼承RouteBase物件,RouteBase這個類別有一個重要的方法來取得RouteData,RouteData封裝此次Http請求的Controller,Action…等資訊 對於每個Http請求依序找尋第一個匹配路由規則 12345routes.MapRoute( name: "Default", url: "&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;", defaults: new &#123; controller = "Home", action = "Index", id = UrlParameter.Optional &#125;); RouteData在RouteData類別中有幾個重要屬性. RouteHandler:存放IRouteHandler物件(提供IHttpHander並呼叫執行物件) Values: 一個字典集合,存放Key為Controller和Action,Value是URL參數值相對位置參數 GetRequiredString:利用傳入string參數對於Values字典取匹配名稱. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class RouteData&#123; private RouteValueDictionary _values = new RouteValueDictionary(); private RouteValueDictionary _dataTokens = new RouteValueDictionary(); private IRouteHandler _routeHandler; /// &lt;summary&gt; /// 使用指定的路由及路由處理常式，初始化 &lt;see cref="T:System.Web.Routing.RouteData" /&gt; 類別的新執行個體。 /// &lt;/summary&gt; /// &lt;param name="route"&gt;此物件會定義路由。&lt;/param&gt; /// &lt;param name="routeHandler"&gt;處理要求的物件。&lt;/param&gt; public RouteData(RouteBase route, IRouteHandler routeHandler) &#123; this.Route = route; this.RouteHandler = routeHandler; &#125; /// &lt;summary&gt; /// 取得自訂值集合，當 ASP.NET 路由判斷路由是否符合要求時，會將這些值傳遞至路由處理常式但不會使用。 /// &lt;/summary&gt; public RouteValueDictionary DataTokens &#123; get &#123; return this._dataTokens; &#125; &#125; /// &lt;summary&gt;取得或設定代表路由的物件。&lt;/summary&gt; public RouteBase Route &#123; get; set; &#125; /// &lt;summary&gt;取得或設定處理要求路由的物件。&lt;/summary&gt; public IRouteHandler RouteHandler &#123; get &#123; return this._routeHandler; &#125; set &#123; this._routeHandler = value; &#125; &#125; /// &lt;summary&gt;取得 URL 參數值和預設路由值的集合。&lt;/summary&gt; public RouteValueDictionary Values &#123; get &#123; return this._values; &#125; &#125; /// &lt;summary&gt;擷取具有指定識別項的值。&lt;/summary&gt; public string GetRequiredString(string valueName) &#123; object obj; if (this.Values.TryGetValue(valueName, out obj)) &#123; string str = obj as string; if (!string.IsNullOrEmpty(str)) return str; &#125; throw new InvalidOperationException(string.Format((IFormatProvider) CultureInfo.CurrentUICulture, System.Web.SR.GetString("RouteData_RequiredValue"), new object[1] &#123; (object) valueName &#125;)); &#125;&#125; RouteData主要把Client傳送Http請求資訊經解析後存放在Values中. RouteBase中有個GetRouteData方法，藉由我們的路由設定去解析當前是否匹配到路由規則，如果有就回傳一個RouteData物件，否則回傳Null 建立自己Route機制一般使用Route這個物件是使用/當作註冊對應的規則 {Controller}/{Action}在Domian後用/當作分隔 第一個區塊字串被當作ControllerName 第二個區塊字串被當作ActionName 因為在Asp.net MVC透過RouteData.GetRequiredString傳入ControllerName或ActionName取得相對應的值. 這次例子我們希望可以透過QueryString來製作Route對應規則 {domain}?controller=home&amp;action=about 透過上面URL期望呼叫HomeController.About方法 廢話不多說我們來看一下這個QueryStringRoute是如何被實現 123456789101112131415161718192021222324252627282930313233343536373839public class QueryStringRoute : RouteBase&#123; public string Url &#123; get; set; &#125; private bool Match(NameValueCollection queryString, out IDictionary&lt;string, string&gt; variables) &#123; variables = new Dictionary&lt;string, string&gt;(); var para = Url.Split('&amp;'); if (!para.All(x=&gt;queryString.AllKeys.Contains(x))) return false; variables = para.ToDictionary(x =&gt; x, y =&gt; queryString[y]); return true; &#125; public override RouteData GetRouteData(HttpContextBase httpContext) &#123; IDictionary&lt;string, string&gt; value; if (Match(httpContext.Request.QueryString,out value)) &#123; RouteData routeData = new RouteData(this, new MvcRouteHandler()); foreach (var dict in value) routeData.Values.Add(dict.Key,dict.Value); return routeData; &#125; return null; &#125; public override VirtualPathData GetVirtualPath(RequestContext requestContext, RouteValueDictionary values) &#123; return null; &#125;&#125; 我們實現RouteBase抽象類別兩個方法 GetRouteData GetVirtualPath 其中GetRouteData是我們主要要實作方法 Request.QueryString這個集合封裝Http QueryString的資訊. 首先我們先判斷此次請求QueryString是否由傳Controller,Action資料過來,如果有把值填入RouteData.Values字典集合中,反之不匹配此Route規則就回傳NULL. MVC從RouteData.Values取得對應的資料. 使用上就可透過RouteCollection.Add將Route添加到集合中 1234567public static void RegisterRoutes(RouteCollection routes)&#123; routes.Add("customer",new QueryStringRoute() &#123; Url = "controller&amp;action" &#125;);&#125; Http請求就會依序找尋第一個匹配Route來執行. 小結:透過繼承RouteBase抽象類別並實現GetRouteData方法透過返回RouteData物件對於Http請求資訊封裝到RouteData.Values字典集合.(在MVC框架中會對於Values字典中取Key為Controller和Action的值.) 最後再把新建立RouteBase物件加入到全域RouteCollection中. 希望大家看完這篇後可以了解並自行擴充自己Route機制. 本次範例程式碼Git Sample(CustomerRoute Branch) 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day26/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[動態產生程式碼(WebViewPage) View是如何被建立(四) (第25天)]]></title>
    <url>%2FIthelp-day25%2F</url>
    <content type="text"><![CDATA[Agenda 前言 WebViewPage 呼叫WebViewPage.ExecutePageHierarchy方法時機 ApplicationStartPage and WebPageRenderingBase WebViewPage vs WebViewPage 小結： 前言上一篇說到最終會透過一個實現IView物件(Razor是透過RazorView)來完成,RenderView方法將BuildManagerCompiledView方法取得物件轉換型別成WebViewPage. .cshtml最終會編譯成一個繼承WebViewPage檔案. 本篇會來解析View編譯原理 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. WebViewPageWebViewPage繼承樹最頂層有個WebPageExecutingBase抽象類別,他擁有一個抽象方法Execute,View轉成c#程式會建立一個類別就會繼承於WebViewPage並把使用者頁面程式碼實現在Execute方法. 1public abstract void Execute(); 先來看一下View產生的DLL檔案會放在哪裡 透過在View檔案上寫@GetType().Assembly.Location. 在頁面上顯示DLL存放位置,一般會放在Temp資料夾區中 可以根據顯示路徑找到View編譯成DLL 123456789101112131415public class _Page_Views_Shared__Layout_cshtml : WebViewPage&lt;object&gt;&#123; protected global_asax ApplicationInstance &#123; get &#123; return (global_asax)this.get_Context().ApplicationInstance; &#125; &#125; public override void Execute() &#123; //... user print logic &#125;&#125; 我使用JustDecomplie反編譯工具,查看原始碼. 下圖對於View檔案產生DLL反編譯 透過反編譯工具可以看到原始碼,每個頁面都會產生相對應的類別並繼承於WebViewPage&lt;object&gt;類別(會因為使用泛型,因為有一個@Model) Page_Views_Home_About_cshtml類別命名有個規則.Page_Views_{ViewfolderName}_{ViewFileName}_{ExtensionFileName} 我目前看到的是一個About的cshtml檔案(About.cshtml). 看到override void Execute()將我們頁面上的邏輯透過WriteLiteral將資料寫到Output上,在ApplicationStartPage有WriteLiteral實作方式. 1234public override void WriteLiteral(object value)&#123; Output.Write(value);&#125; 呼叫WebViewPage.ExecutePageHierarchy方法時機在RazorView類別中的RenderView方法最下面有一段程式碼. 先判斷是否取得StartPage在呼叫ExecutePageHierarchy方法進行頁面的渲染. 123456WebPageRenderingBase startPage = null;if (RunViewStartPages)&#123; startPage = StartPageLookup(webViewPage, RazorViewEngine.ViewStartFileName, ViewStartFileExtensions);&#125;webViewPage.ExecutePageHierarchy(new WebPageContext(context: viewContext.HttpContext, page: null, model: null), writer, startPage); ApplicationStartPage and WebPageRenderingBaseWebViewPage類別關係圖如下,WebViewPage擁有個複雜繼承樹. 主要分為兩派,在微軟官網有張圖來表示上面兩個比較 ApplicationStartPage:當站台被啟動時會使用WebPageHttpModule(IHttpModule)初始化並呼叫ApplicationStartPage的ExecuteStartPageInternal找尋_appstart.cshtml檔案來執行.ASP.NET Web Pages (Razor) 網站的自訂全網站行為 _AppStart.cshtml頁面上運作。 當要求傳入頁面中，和如果這是第一個要求任何頁面在網站中，ASP.NET會先檢查是否 _AppStart.cshtml頁面存在。 如果是的話，任何程式碼中 _AppStart.cshtml頁面上執行，並執行要求的頁面。 WebPageRenderingBase:透過ExecutePageHierarchy呼叫BaseLayout頁面或執行請求Execute方法 WebPageBase類別中ExecutePageHierarchy重載實作,透過ExecutePageHierarchy呼叫開發者實現Execute方法(Page_Views_Home_About_cshtml.Execute方法). 123456789101112131415161718192021222324252627282930313233public override void ExecutePageHierarchy()&#123; if (WebPageHttpHandler.ShouldGenerateSourceHeader(Context)) &#123; try &#123; string vp = VirtualPath; if (vp != null) &#123; string path = Context.Request.MapPath(vp); if (!path.IsEmpty()) &#123; PageContext.SourceFiles.Add(path); &#125; &#125; &#125; catch &#123; // we really don't care if this ever fails, so we swallow all exceptions &#125; &#125; TemplateStack.Push(Context, this); try &#123; // Execute the developer-written code of the WebPage Execute(); &#125; finally &#123; TemplateStack.Pop(Context); &#125;&#125; WebViewPage vs WebViewPagec# 有一個關鍵字new對於類別成員修飾詞 new關鍵字做為宣告修飾詞使用時，會明確隱藏繼承自基底類別的成員。當您隱藏繼承的成員時，該成員的衍生版本就會取代基底類別版本 new 修飾詞 (C# 參考) 我覺得這個關鍵字有點打壞物件導向的概念,因為他會把父類別原本的成員隱藏起來.強制替換成子類. 但我看到WebViewPage&lt;TModel&gt;實作時覺得new原來可以這麼好用 WebViewPage&lt;TModel&gt;很巧妙使用new把View重點成員物件轉成泛型.可以讓我們在Razor或aspx可以更方便使用. 123456789101112131415161718192021222324252627public abstract class WebViewPage&lt;TModel&gt; : WebViewPage&#123; private ViewDataDictionary&lt;TModel&gt; _viewData; public new AjaxHelper&lt;TModel&gt; Ajax &#123; get; set; &#125; public new HtmlHelper&lt;TModel&gt; Html &#123; get; set; &#125; public new TModel Model &#123; get &#123; return ViewData.Model; &#125; &#125; [SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Justification = "This is the mechanism by which the ViewPage gets its ViewDataDictionary object.")] public new ViewDataDictionary&lt;TModel&gt; ViewData &#123; get &#123; if (_viewData == null) &#123; SetViewData(new ViewDataDictionary&lt;TModel&gt;()); &#125; return _viewData; &#125; set &#123; SetViewData(value); &#125; &#125;&#125; 所以之後如果有遇到類似情況(需要使用泛型替代父類別object類型成員可以考慮使用new) 小結：View頁面程式會轉成一個類別繼承於WebViewPage抽象類別,並把我們撰寫邏輯填充在Execute方法中.讓Asp.net MVC來呼叫. 這裡設計非常巧妙透過一個抽象類別和一個動態編譯程式,讓View更有彈性可以透過Razor語法實現View邏輯(更人性化). WebViewPage&lt;TModel&gt;很巧妙使用new把View重點成員物件轉成泛型.可以讓我們在Razor或aspx可以更方便使用. 最後透過呼叫ActionResult.ExecuteResult方法將資料塞到Response物件中,提供回傳給Client端,最後執行資源Release動作. 後面幾篇會利用前面所學來改寫MVC框架. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day25/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探討ViewEngine機制 View是如何被建立(三) (第24天)]]></title>
    <url>%2FIthelp-day24%2F</url>
    <content type="text"><![CDATA[Agenda 前言 ViewResultBase.ExecuteResult IView BuildManagerCompiledView RazorView IViewEngine VirtualPathProviderViewEngine RazorViewEngine ViewEngines and ViewEngineCollection 提升執行效率小技巧 移除不必要ViewEngine提升執行效率 只允許某個View副檔名 小結: 前言繼承ActiontResult類別中ViewResultBase最為複雜,因為ViewResultBase要找到實現IViewEngine物件取得取得View檔案,在透過實現IView物件把頁面渲染出來. 這篇會跟大家分享值型上面動作核心類別. 個人覺得MVC運用很多物件導向概念和用法,在讀程式時有件事情很重要是理解類別負責的工作和類別之間關係.就像現實生活中人與人的關係要了解清楚. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. ViewResultBase.ExecuteResult因為ExecuteResult是最終被呼叫方法,我們來解析ViewResultBase.ExecuteResult方法邏輯. 透過子類別實現FindView取得View相關資料. 呼叫實現IView物件Render方法,並將渲染出來資料透過Response.Output輸出到Client端 123456789101112131415161718192021222324252627282930public override void ExecuteResult(ControllerContext context)&#123; if (context == null) &#123; throw new ArgumentNullException("context"); &#125; if (String.IsNullOrEmpty(ViewName)) &#123; ViewName = context.RouteData.GetRequiredString("action"); &#125; ViewEngineResult result = null; if (View == null) &#123; result = FindView(context); View = result.View; &#125; TextWriter writer = context.HttpContext.Response.Output; ViewContext viewContext = new ViewContext(context, View, ViewData, TempData, writer); View.Render(viewContext, writer); if (result != null) &#123; result.ViewEngine.ReleaseView(context, View); &#125;&#125;protected abstract ViewEngineResult FindView(ControllerContext context); 這張UML表示ViewResultBase繼承關係圖. 我們在Controller呼叫的View()和PartailView()方法就是建立PartialViewResult和ViewResult方法並且呼叫ExecuteResult進行View頁面渲染. IViewView是一個實現了IView介面物件。IView定義非常簡單，僅僅具有唯一Render方法根據指定ViewContext和TextWriter物件達成對於View渲染顯示 1234public interface IView&#123; void Render(ViewContext viewContext, TextWriter writer);&#125; BuildManagerCompiledViewBuildManagerCompiledView類別實現Render對於View如何被渲染呈現. 主要透過下面幾個步驟. .cshtml,.aspx頁面程式碼會轉成編譯成一個繼承WebViewPage類別的dll檔案.BuildManagerWrapper靜態方法GetCompiledType依據指定View檔案虛擬路徑得到編譯後WebPageView類型 IViewPageActivator(DefaultViewPageActivator)利用反射建立WebPageView物件由頁面程式產生的View物件 最後再呼叫由子類實現RenderView方法 BuildManagerCompiledView屬性ViewPath表示的就是View文件虛擬路徑. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class BuildManagerCompiledView : IView&#123; internal IViewPageActivator ViewPageActivator; private IBuildManager _buildManager; private ControllerContext _controllerContext; internal IBuildManager BuildManager &#123; get &#123; if (_buildManager == null) &#123; _buildManager = new BuildManagerWrapper(); &#125; return _buildManager; &#125; set &#123; _buildManager = value; &#125; &#125; public string ViewPath &#123; get; protected set; &#125; public virtual void Render(ViewContext viewContext, TextWriter writer) &#123; if (viewContext == null) &#123; throw new ArgumentNullException("viewContext"); &#125; object instance = null; //取得view型態 Type type = BuildManager.GetCompiledType(ViewPath); if (type != null) &#123; instance = ViewPageActivator.Create(_controllerContext, type); &#125; if (instance == null) &#123; throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture, MvcResources.CshtmlView_ViewCouldNotBeCreated, ViewPath)); &#125; RenderView(viewContext, writer, instance); &#125; protected abstract void RenderView(ViewContext viewContext, TextWriter writer, object instance);&#125; RazorViewRazorView繼承BuildManagerCompiledView,RazorView具有三個只讀屬性 LayoutPath：View佈局檔案虛擬路徑 ViewStartFileExtensions：表示開始頁面文件的擴展名,對於Razor引擎默認創建RazorView,通過_ViewStart.cshtml檔案定義開始頁面相關資訊. RunViewStartPages:這個bool掌控執行開始頁面判斷 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class RazorView : BuildManagerCompiledView&#123; public string LayoutPath &#123; get; private set; &#125; public bool RunViewStartPages &#123; get; private set; &#125; public IEnumerable&lt;string&gt; ViewStartFileExtensions &#123; get; private set; &#125; protected override void RenderView(ViewContext viewContext, TextWriter writer, object instance) &#123; if (writer == null) &#123; throw new ArgumentNullException("writer"); &#125; WebViewPage webViewPage = instance as WebViewPage; if (webViewPage == null) &#123; throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture, MvcResources.CshtmlView_WrongViewBase, ViewPath)); &#125; webViewPage.OverridenLayoutPath = LayoutPath; webViewPage.VirtualPath = ViewPath; webViewPage.ViewContext = viewContext; webViewPage.ViewData = viewContext.ViewData; webViewPage.InitHelpers(); if (VirtualPathFactory != null) &#123; webViewPage.VirtualPathFactory = VirtualPathFactory; &#125; if (DisplayModeProvider != null) &#123; webViewPage.DisplayModeProvider = DisplayModeProvider; &#125; WebPageRenderingBase startPage = null; if (RunViewStartPages) &#123; startPage = StartPageLookup(webViewPage, RazorViewEngine.ViewStartFileName, ViewStartFileExtensions); &#125; webViewPage.ExecutePageHierarchy(new WebPageContext(context: viewContext.HttpContext, page: null, model: null), writer, startPage); &#125;&#125; RenderView方法執行幾個步驟. RenderView方法將BuildManagerCompiledView方法取得instance物件轉換型別成WebViewPage 資料初始化(建立UrlHelp,….)物件 判斷是否使用Razor共用樣板 呼叫ExecutePageHierarchy,進行頁面渲染,最主要呼叫Execute方法來執行子類別實現邏輯. 下面是IView類別關係圖 最後由WebFormView,RazorView實現頁面的渲染工作. IViewEngine這個介面提供找尋使用ViewEngineResult,View和ViewEngine屬性找到View物件和使用的ViewEngine物件,SearchedLocations屬性表示在獲取目標搜索過程中使用的搜索位置列表 123456789101112131415public interface IViewEngine&#123; ViewEngineResult FindPartialView(ControllerContext controllerContext, string partialViewName, bool useCache); ViewEngineResult FindView(ControllerContext controllerContext, string viewName, string masterName, bool useCache); void ReleaseView(ControllerContext controllerContext, IView view);&#125;public class ViewEngineResult&#123; public IEnumerable&lt;string&gt; SearchedLocations &#123; get; private set; &#125; public IView View &#123; get; private set; &#125; public IViewEngine ViewEngine &#123; get; private set; &#125;&#125; VirtualPathProviderViewEngineVirtualPathProviderViewEngine這個抽象類別,實現FindPartialView和FindView方法,另外提供一個抽象方法CreateView和CreatePartialView提供子類(WebFormViewEngine,RazorViewEngine)來實現. 下面是FindView原始碼. 123456789101112131415161718public virtual ViewEngineResult FindView(ControllerContext controllerContext, string viewName, string masterName, bool useCache)&#123; //.... string[] viewLocationsSearched; string[] masterLocationsSearched; string controllerName = controllerContext.RouteData.GetRequiredString("controller"); string viewPath = GetPath(controllerContext, ViewLocationFormats, AreaViewLocationFormats, "ViewLocationFormats", viewName, controllerName, CacheKeyPrefixView, useCache, out viewLocationsSearched); string masterPath = GetPath(controllerContext, MasterLocationFormats, AreaMasterLocationFormats, "MasterLocationFormats", masterName, controllerName, CacheKeyPrefixMaster, useCache, out masterLocationsSearched); if (String.IsNullOrEmpty(viewPath) || (String.IsNullOrEmpty(masterPath) &amp;&amp; !String.IsNullOrEmpty(masterName))) &#123; return new ViewEngineResult(viewLocationsSearched.Union(masterLocationsSearched)); &#125; return new ViewEngineResult(CreateView(controllerContext, viewPath, masterPath), this);&#125; RazorViewEngine前面有提到VirtualPathProviderViewEngine提供一個抽象類別給子類來實現如何建立一個IView物件. RazorViewEngine透過上面資訊建立一個RazorView(此類別實現IView介面),最終ViewBaseResult就是呼叫IView的Render方法. RazorViewEngine就是建立到時候要Render到OutputStream物件. 123456789protected override IView CreateView(ControllerContext controllerContext, string viewPath, string masterPath)&#123; var view = new RazorView(controllerContext, viewPath, layoutPath: masterPath, runViewStartPages: true, viewStartFileExtensions: FileExtensions, viewPageActivator: ViewPageActivator) &#123; DisplayModeProvider = DisplayModeProvider &#125;; return view;&#125; ViewEngines and ViewEngineCollection透過ViewEngines.Engines可以取得目前可以使用View引擎. ASP.NET MVC為我們提供了兩種View引擎(RazorViewEngine,WebFormViewEngine)， 提供傳統Web Form引擎，.aspx頁面一致WebFormViewEngine， 另一種預設使用也是推薦使用Razor引擎RazorViewEngine。 12345678910111213public static class ViewEngines&#123; private static readonly ViewEngineCollection _engines = new ViewEngineCollection &#123; new WebFormViewEngine(), new RazorViewEngine(), &#125;; public static ViewEngineCollection Engines &#123; get &#123; return _engines; &#125; &#125;&#125; ViewEngine類別關係圖如下 這邊以RazorViewEngine來介紹 ViewLocationFormats:預設找尋View實體檔案位置 PartialViewLocationFormats:預設找尋PartialView實體檔案位置 FileExtensions:Razor使用附檔名. 提升執行效率小技巧這裡有個小技巧可提高MVC執行效率. 移除不必要ViewEngine提升執行效率MVC藉由ViewEngineCollection這個集合來判斷使用ViewEngine,且它預設有兩個ViewEngines提供給我們使用(RazorViewEngine,WebFormViewEngine)一般來說我們只使用一個ViewEngine另一個就不會用到. 如果我們只使用RazorViewEngine就可在Global.cs上撰寫這段程式碼,主要是把不必要ViewEngine移除只關注在我們使用ViewEngine 12ViewEngines.Engines.Clear();ViewEngines.Engines.Add(new RazorViewEngine()); 只允許某個View副檔名在Razor有支援兩個副檔名 vbhtml:vb使用 cshtml:c#使用 如果我們想強制這個專案都使用C#的Razor撰寫view,可藉由幾個屬性來幫我們限制完成. 1234567891011121314151617181920212223242526272829303132333435363738ViewEngines.Engines.Add(new RazorViewEngine()&#123; AreaViewLocationFormats = new[] &#123; "~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.cshtml", "~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.cshtml", &#125;, AreaMasterLocationFormats = new[] &#123; "~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.cshtml", "~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.cshtml", &#125;, AreaPartialViewLocationFormats = new[] &#123; "~/Areas/&#123;2&#125;/Views/&#123;1&#125;/&#123;0&#125;.cshtml", "~/Areas/&#123;2&#125;/Views/Shared/&#123;0&#125;.cshtml" &#125;, ViewLocationFormats = new[] &#123; "~/Views/&#123;1&#125;/&#123;0&#125;.cshtml", "~/Views/Shared/&#123;0&#125;.cshtml", &#125;, MasterLocationFormats = new[] &#123; "~/Views/&#123;1&#125;/&#123;0&#125;.cshtml", "~/Views/Shared/&#123;0&#125;.cshtml" &#125;, PartialViewLocationFormats = new[] &#123; "~/Views/&#123;1&#125;/&#123;0&#125;.cshtml", "~/Views/Shared/&#123;0&#125;.cshtml" &#125;, FileExtensions = new[] &#123; "cshtml", &#125;&#125;); 小結:本篇大致上把產生View頁面使用到的幾個核心介面和類別介紹完了,我們主要會使用繼承ViewResultBase物件並透過,相對應實現IView物件來進行畫面渲染,如何取得使用的IView物件就透過ViewEngines集合. 上面介紹了三個抽象類別和介面,每個都有自己核心職責並且和其他物件有清晰關係 ViewResultBase:實現ActionResult提供Controller呼叫產生頁面ExecuteResult方法. IView:提供如何渲染頁面 IViewEngine:透過虛擬路徑找到要執行頁面(透過一些機制). 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day24/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6個基本(ActionResult) View是如何被建立(二) (第23天)]]></title>
    <url>%2FIthelp-day23%2F</url>
    <content type="text"><![CDATA[Agenda 前言 6種基本的ActionResult ContentResult RedirectResult &amp; RedirectToRouteResult EmptyResult FileResult FileContentResult FilePathResult 小結: 前言上一篇介紹到CreateActionResult方法會產生一個ActionResult物件利用MethodInfo資訊. 最後透過InvokeActionResult來呼叫ExecuteResult方法來執行ActionResult的ExecuteResult方法,基本上MVC找到且執行Action方法後面就沒再做甚麼特別的事情了(後面做資源釋放…) 1234protected virtual void InvokeActionResult(ControllerContext controllerContext, ActionResult actionResult)&#123; actionResult.ExecuteResult(controllerContext);&#125; 本篇來介紹常用的ActionResult其內部運作程式碼 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. 6種基本的ActionResult下面這六個類別是直接繼承於ActionResult的類別(其中有標註Base class代表這是抽象類別另外有類別繼承它) ContentResult:回傳一組字串,利用response.Write方法 EmptyResult:什麼都不動作(當Action回傳void使用) FileResult(Base class):把檔案當作回傳 HttpStatusCodeResult:回傳HTTP狀態碼 RedirectResult &amp; RedirectToRouteResult:使用Response.Redirect轉導到其他頁面 ViewResultBase(Base class):會找尋相對應View檔案(cshtml會編譯成一個DLL)來執行 ViewResultBase會在另一篇介紹(因為機制比較複雜) ContentResult在ContentResult有三個屬性 Content:響應內容. ContentType:設置Http Header攔位ContentType ContentEncoding:設置Encoding方式 12345678910111213141516171819202122232425262728293031public class ContentResult : ActionResult&#123; public string Content &#123; get; set; &#125; public Encoding ContentEncoding &#123; get; set; &#125; public string ContentType &#123; get; set; &#125; public override void ExecuteResult(ControllerContext context) &#123; if (context == null) &#123; throw new ArgumentNullException("context"); &#125; HttpResponseBase response = context.HttpContext.Response; if (!String.IsNullOrEmpty(ContentType)) &#123; response.ContentType = ContentType; &#125; if (ContentEncoding != null) &#123; response.ContentEncoding = ContentEncoding; &#125; if (Content != null) &#123; response.Write(Content); &#125; &#125;&#125; ContentResult操作很簡單透過response.Write把內容Print出來 RedirectResult &amp; RedirectToRouteResultRedirectResult這個ActionResult如其名就是導轉頁面. Permanent:屬性判斷是否需要Permanently導轉頁面(Http-Code:RedirectPermanent=301,Redirect=302) Url:轉導的URL透過UrlHelper.GenerateContentUrl產生URL.(在GenerateContentUrl會判斷第一個字元是否是~波浪號,如果是代表站內導轉.) 最後利用Permanent布林判斷使用RedirectPermanent還是Redirect方法. 123456789101112131415161718192021222324252627282930public class RedirectResult : ActionResult&#123; public bool Permanent &#123; get; private set; &#125; public string Url &#123; get; private set; &#125; public override void ExecuteResult(ControllerContext context) &#123; if (context == null) &#123; throw new ArgumentNullException("context"); &#125; if (context.IsChildAction) &#123; throw new InvalidOperationException(MvcResources.RedirectAction_CannotRedirectInChildAction); &#125; string destinationUrl = UrlHelper.GenerateContentUrl(Url, context.HttpContext); context.Controller.TempData.Keep(); if (Permanent) &#123; context.HttpContext.Response.RedirectPermanent(destinationUrl, endResponse: false); &#125; else &#123; context.HttpContext.Response.Redirect(destinationUrl, endResponse: false); &#125; &#125;&#125; RedirectToRouteResult基本流程跟上面一樣只是透過UrlHelper.GenerateUrl產生要導轉URL EmptyResultEmptyResult這個類別很有趣,只有override ExecuteResult方法但沒有實做,上篇小結有提到這裡使用一個設計模式null object pattern. 12345678910111213public class EmptyResult : ActionResult&#123; private static readonly EmptyResult _singleton = new EmptyResult(); internal static EmptyResult Instance &#123; get &#123; return _singleton; &#125; &#125; public override void ExecuteResult(ControllerContext context) &#123; &#125;&#125; FileResultFileResult是一個抽象類別,提供一個抽象方法給abstract void WriteFile(HttpResponseBase response)子類提供覆寫. 有兩個類別繼承於FileResult抽象類別 FilePathResult FileContentResult FileResult抽象類別在ExecuteResult設置傳輸檔案需要的前置作業(設置Content-Type…),最後的資料傳輸透過各個子類別去實現. 其中headerValue實做Http回應擋頭對於RFC規範. 123456// From RFC 2183, Sec. 2.3:// The sender may want to suggest a filename to be used if the entity is// detached and stored in a separate file. If the receiving MUA writes// the entity to a file, the suggested filename should be used as a// basis for the actual filename, where possible.string headerValue = ContentDispositionUtil.GetHeaderValue(FileDownloadName); 1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class FileResult : ActionResult&#123; private string _fileDownloadName; protected FileResult(string contentType) &#123; if (String.IsNullOrEmpty(contentType)) &#123; throw new ArgumentException(MvcResources.Common_NullOrEmpty, "contentType"); &#125; ContentType = contentType; &#125; public string ContentType &#123; get; private set; &#125; public string FileDownloadName &#123; get &#123; return _fileDownloadName ?? String.Empty; &#125; set &#123; _fileDownloadName = value; &#125; &#125; public override void ExecuteResult(ControllerContext context) &#123; if (context == null) &#123; throw new ArgumentNullException("context"); &#125; HttpResponseBase response = context.HttpContext.Response; response.ContentType = ContentType; if (!String.IsNullOrEmpty(FileDownloadName)) &#123; string headerValue = ContentDispositionUtil.GetHeaderValue(FileDownloadName); context.HttpContext.Response.AddHeader("Content-Disposition", headerValue); &#125; WriteFile(response); &#125; protected abstract void WriteFile(HttpResponseBase response); &#125;&#125; FileContentResultFileContentResult將檔案已位元組方式轉存給Client端. 透過HttpResponseBase.OutputStream.Write方法. 1234567891011121314151617181920public class FileContentResult : FileResult&#123; public FileContentResult(byte[] fileContents, string contentType) : base(contentType) &#123; if (fileContents == null) &#123; throw new ArgumentNullException("fileContents"); &#125; FileContents = fileContents; &#125; public byte[] FileContents &#123; get; private set; &#125; protected override void WriteFile(HttpResponseBase response) &#123; response.OutputStream.Write(FileContents, 0, FileContents.Length); &#125;&#125; FilePathResultFilePathResult透過檔案名稱FileName將檔案提供給Client 藉由HttpResponseBase.TransmitFile方法. 1234567891011121314151617181920public class FilePathResult : FileResult&#123; public FilePathResult(string fileName, string contentType) : base(contentType) &#123; if (String.IsNullOrEmpty(fileName)) &#123; throw new ArgumentException(MvcResources.Common_NullOrEmpty, "fileName"); &#125; FileName = fileName; &#125; public string FileName &#123; get; private set; &#125; protected override void WriteFile(HttpResponseBase response) &#123; response.TransmitFile(FileName); &#125;&#125; 小結:本篇介紹了幾個實現ActionResult類別,跟其內部程式碼,這裡能了解到MVC返回結果機於ActionResult方法.(這個概念我運用在Web Api服務,建立ResponseBase共同簽章,因為在做服務串接每個服務都有自己的加解密,回傳格式攔位.我可以統一透過一個ResponseBase類別裝載資料再藉由過濾器來幫忙組成相對應的資料回傳….) 下篇會來介紹繼承ActionResult最複雜的ViewResultBase相關程式碼. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day23/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View是如何被建立(一) (第22天)]]></title>
    <url>%2FIthelp-day22%2F</url>
    <content type="text"><![CDATA[Agenda 前言 Action方法是如何被呼叫(快速整理) ActionMethodDispatcher 取得(執行Action方法) Expression動態產生呼叫Action方法 (GetExecutor) GetExecutor方法 Expression產生呼叫程式碼解說 DispatcherCache CreateActionResult 小結: 前言不知道大家有沒有點暈頭轉向XD,MVC的Model綁定機制真的蠻複雜,希望大家有跟上來 透過DefaultModelBinder的BindComplexElementalModel方法綁定複雜模型的值. 在BindProperty方法時填充子節點ModelMetadata的Model屬性,透過(DefaultModelBinder)再次綁定物件動作如下 ModelMetadata是簡單模型就會把值填充給此次ModelMetadata.Model ModelMetadata是複雜模型就建立一個物件後呼叫BindProperty直到找到最後的簡單模型. 在BindComplexElementalModel方法做幾個主要動作 BindProperties:透過MetaData取得屬性資訊並利用反射把值添加上去. OnModelUpdated:找尋Model上MetaData的ModelValidator進行屬性驗證,如果驗證失敗會把資料資訊加到ModelState.AddModelError(ModelStateDictionary)可在View搭配顯示error訊息 12345678910internal void BindComplexElementalModel(ControllerContext controllerContext, ModelBindingContext bindingContext, object model)&#123; ModelBindingContext newBindingContext = CreateComplexElementalModelBindingContext(controllerContext, bindingContext, model); if (OnModelUpdating(controllerContext, newBindingContext)) &#123; BindProperties(controllerContext, newBindingContext); OnModelUpdated(controllerContext, newBindingContext); &#125;&#125; 如果前面幾篇看不懂的小夥伴沒關係只要記得,主要透過GetParameterValues方法取得IDictionary&lt;string, object把Http傳送過來參數綁定到MVC使用Model參數上 字典Key就是Model傳入名稱 字典object就是Model的值 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. Action方法是如何被呼叫(快速整理)前幾篇有說過InvokeActionMethodWithFilters方法，執行會產生要執行ActionResult物件並使用字典當作參數傳入 InvokeActionMethodWithFilters方法中透過InvokeActionMethod方法來產生要執行的ActionResult ActionExecutingContext這個物件比其他過濾器參數多了一個重要的成員IDictionary&lt;string, object&gt; parameters,有這個成員我們可以針對呼叫Action參數處理. 12345678910111213protected virtual ActionExecutedContext InvokeActionMethodWithFilters(ControllerContext controllerContext, IList&lt;IActionFilter&gt; filters, ActionDescriptor actionDescriptor, IDictionary&lt;string, object&gt; parameters)&#123; ActionExecutingContext preContext = new ActionExecutingContext(controllerContext, actionDescriptor, parameters); Func&lt;ActionExecutedContext&gt; continuation = () =&gt; new ActionExecutedContext(controllerContext, actionDescriptor, false /* canceled */, null /* exception */) &#123; Result = InvokeActionMethod(controllerContext, actionDescriptor, parameters) &#125;; //preContext 執行前Context next執行後Context Func&lt;ActionExecutedContext&gt; thunk = filters.Reverse().Aggregate(continuation,(next, filter) =&gt; () =&gt; InvokeActionMethodFilter(filter, preContext, next)); return thunk();&#125; 在InvokeActionMethod這個方法主要透過ActionDescriptor來回傳此次使用ActionResult物件 123456protected virtual ActionResult InvokeActionMethod(ControllerContext controllerContext, ActionDescriptor actionDescriptor, IDictionary&lt;string, object&gt; parameters)&#123; object returnValue = actionDescriptor.Execute(controllerContext, parameters); ActionResult result = CreateActionResult(controllerContext, actionDescriptor, returnValue); return result;&#125; 上面呼叫的是ReflectedActionDescriptor.Execute ExtractParameterFromDictionary主要透過字典的TryGetValue方法取值(另外還做參數型別驗證) 12345678910111213141516public override object Execute(ControllerContext controllerContext, IDictionary&lt;string, object&gt; parameters)&#123; //..... ParameterInfo[] parameterInfos = MethodInfo.GetParameters(); object[] parametersArray = new object[parameterInfos.Length]; for (int i = 0; i &lt; parameterInfos.Length; i++) &#123; ParameterInfo parameterInfo = parameterInfos[i]; object parameter = ExtractParameterFromDictionary(parameterInfo, parameters, MethodInfo); parametersArray[i] = parameter; &#125; ActionMethodDispatcher dispatcher = DispatcherCache.GetDispatcher(MethodInfo); object actionReturnValue = dispatcher.Execute(controllerContext.Controller, parametersArray); return actionReturnValue;&#125; ActionMethodDispatcher 取得(執行Action方法)ActionMethodDispatcher原始碼能看到在建構子有一個GetExecutor方法(使用Expression表達式產生委派物件).產生ActionExecutor委派物件 裡面有幾個重要的成員 ActionExecutor:執行Action方法有回傳值 VoidActionExecutor:執行Action方法回傳值是void 透過GetExecutor組成要使用方法委派,等待外部呼叫Execute方法. 1234567891011121314151617181920212223242526272829303132333435internal sealed class ActionMethodDispatcher&#123; private ActionExecutor _executor; public ActionMethodDispatcher(MethodInfo methodInfo) &#123; _executor = GetExecutor(methodInfo); MethodInfo = methodInfo; &#125; private delegate object ActionExecutor(ControllerBase controller, object[] parameters); private delegate void VoidActionExecutor(ControllerBase controller, object[] parameters); public MethodInfo MethodInfo &#123; get; private set; &#125; public object Execute(ControllerBase controller, object[] parameters) &#123; return _executor(controller, parameters); &#125; private static ActionExecutor GetExecutor(MethodInfo methodInfo) &#123; //... &#125; private static ActionExecutor WrapVoidAction(VoidActionExecutor executor) &#123; return delegate(ControllerBase controller, object[] parameters) &#123; executor(controller, parameters); return null; &#125;; &#125;&#125; 前篇有說過在.net原始碼為了確保執行ResultFilter順序在InvokeActionResultWithFilters方法使用遞迴呼叫. Expression動態產生呼叫Action方法 (GetExecutor)MVC透過Route機制解析我們要呼叫Controller跟Action方法,但在呼叫時動態去判斷要呼叫哪個Action方法,說到動態呼叫方法,有點經驗的人就會想到使用反射(reflection). 反射固然好用,但反射對於效能來說有些不太好(因為要動態到dll metadata找尋取得資訊). .net MVC工程師也知道上面問題所以這邊他們使用另一種設計方式來避免此問題 使用Expression表達式動態產生呼叫程式碼(也可以使用Emit)並呼叫使用. 先來看看Expreesion產生呼叫HomeController中Index方法的程式碼吧. Expression表達式沒有帶參數Action方法 12345.Lambda #Lambda1&lt;System.Web.Mvc.ActionMethodDispatcher+ActionExecutor&gt;( System.Web.Mvc.ControllerBase $controller, System.Object[] $parameters) &#123; (System.Object).Call ((Asp.net_MVC_Debuger.Controllers.HomeController)$controller).Index()&#125; Expression表達式有帶參數Action方法 12345678.Lambda #Lambda1&lt;System.Web.Mvc.ActionMethodDispatcher+ActionExecutor&gt;( System.Web.Mvc.ControllerBase $controller, System.Object[] $parameters) &#123; (System.Object).Call ((Asp.net_MVC_Debuger.Controllers.HomeController)$controller).Index ( (Asp.net_MVC_Debuger.Models.MessageViewModel)$parameters[0] )&#125; 下面會對於GetExecutor方法透過Expression產生呼叫程式碼解說 GetExecutor方法 Expression產生呼叫程式碼解說下面是GetExecutor原始碼,讓我一步一步大家分析如何運行吧(介紹Expression表達式和原始碼是如何對照). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private static ActionExecutor GetExecutor(MethodInfo methodInfo)&#123; // Parameters to executor ParameterExpression controllerParameter = Expression.Parameter(typeof(ControllerBase), "controller"); ParameterExpression parametersParameter = Expression.Parameter(typeof(object[]), "parameters"); // Build parameter list List&lt;Expression&gt; parameters = new List&lt;Expression&gt;(); ParameterInfo[] paramInfos = methodInfo.GetParameters(); for (int i = 0; i &lt; paramInfos.Length; i++) &#123; ParameterInfo paramInfo = paramInfos[i]; BinaryExpression valueObj = Expression.ArrayIndex(parametersParameter, Expression.Constant(i)); UnaryExpression valueCast = Expression.Convert(valueObj, paramInfo.ParameterType); parameters.Add(valueCast); &#125; // Call method UnaryExpression instanceCast = (!methodInfo.IsStatic) ? Expression.Convert(controllerParameter, methodInfo.ReflectedType) : null; MethodCallExpression methodCall = methodCall = Expression.Call(instanceCast, methodInfo, parameters); // methodCall is "((TController) controller) method((T0) parameters[0], (T1) parameters[1], ...)" // Create function if (methodCall.Type == typeof(void)) &#123; Expression&lt;VoidActionExecutor&gt; lambda = Expression.Lambda&lt;VoidActionExecutor&gt;(methodCall, controllerParameter, parametersParameter); VoidActionExecutor voidExecutor = lambda.Compile(); return WrapVoidAction(voidExecutor); &#125; else &#123; // must coerce methodCall to match ActionExecutor signature UnaryExpression castMethodCall = Expression.Convert(methodCall, typeof(object)); Expression&lt;ActionExecutor&gt; lambda = Expression.Lambda&lt;ActionExecutor&gt;(castMethodCall, controllerParameter, parametersParameter); return lambda.Compile(); &#125;&#125;private static ActionExecutor WrapVoidAction(VoidActionExecutor executor)&#123; return delegate(ControllerBase controller, object[] parameters) &#123; executor(controller, parameters); return null; &#125;;&#125; 第一步、先宣告兩個Parameter表達式 controller parameters:是一個陣列物件 lambda表達式呼叫方法參數 123#Lambda1&lt;System.Web.Mvc.ActionMethodDispatcher+ActionExecutor&gt;( System.Web.Mvc.ControllerBase $controller, System.Object[] $parameters) 第二步、透過for loop建立要傳入Action方法參數陣列 產生完後加入List&lt;Expression&gt;集合中 123(Asp.net_MVC_Debuger.Models.MessageViewModel)$parameters[0],(Asp.net_MVC_Debuger.Models.MessageViewModel1)$parameters[1]//.... 第三步、將controllerParameter強轉型成呼叫使用Controller型別 1((Asp.net_MVC_Debuger.Controllers.HomeController)$controller) 第四步、使用Expression.Call產生呼叫Action方法動作 1234(System.Object).Call ((Asp.net_MVC_Debuger.Controllers.HomeController)$controller).Index( (Asp.net_MVC_Debuger.Models.MessageViewModel)$parameters[0]) 第五步、判斷呼叫方法是否有回傳值(Void),compile成不同程式碼 透過Expression.Lambda將上面程式碼,變成Lambda委派方法提供Execute方法呼叫使用. 12345.Lambda #Lambda1&lt;System.Web.Mvc.ActionMethodDispatcher+ActionExecutor&gt;( System.Web.Mvc.ControllerBase $controller, System.Object[] $parameters) &#123; (System.Object).Call ((Asp.net_MVC_Debuger.Controllers.HomeController)$controller).Index()&#125; 能看到上面程式碼如果使用反射可以很輕易完成,但性能就沒有使用Expression或emit來得好 Expression表達式比起emit更簡單了解,所以我會優先使用Expression表達式 DispatcherCache在取得ActionMethodDispatcher透過一個DispatcherCache屬性. 這是為什麼呢? 12ActionMethodDispatcher dispatcher = DispatcherCache.GetDispatcher(MethodInfo);object actionReturnValue = dispatcher.Execute(controllerContext.Controller, parametersArray); 在上面有分享ActionMethodDispatcher透過Expression表達式產生呼叫方法 但Http請求很頻繁,雖然透過Expression表達式動態產生程式碼呼叫比反射效能來好,但一直重複產生程式碼也需要很多效能. MVC使用一個Cache來保存已經呼叫過資訊DispatcherCache 主要邏輯判斷此MethodInfo是否已經有存入快取字典中.如果沒有建立一個新ActionMethodDispatcher(產生一個新Expression) 123456789101112internal sealed class ActionMethodDispatcherCache : ReaderWriterCache&lt;MethodInfo, ActionMethodDispatcher&gt;&#123; public ActionMethodDispatcherCache() &#123; &#125; public ActionMethodDispatcher GetDispatcher(MethodInfo methodInfo) &#123; // Frequently called, so ensure delegate remains static return FetchOrCreateItem(methodInfo, (MethodInfo methodInfoInner) =&gt; new ActionMethodDispatcher(methodInfoInner), methodInfo); &#125;&#125; CreateActionResultCreateActionResult判斷剛剛產生的ActionResult物件進行下面簡單處理 actionReturnValue如果是NULL(回傳值是void)就回傳一個EmptyResult(什麼都不做) 是否是回傳ActionResult物件,如果不是就利用ContentResult來將結果包起來. 1234567891011protected virtual ActionResult CreateActionResult(ControllerContext controllerContext, ActionDescriptor actionDescriptor, object actionReturnValue)&#123; if (actionReturnValue == null) &#123; return new EmptyResult(); &#125; ActionResult actionResult = (actionReturnValue as ActionResult) ?? new ContentResult &#123; Content = Convert.ToString(actionReturnValue, CultureInfo.InvariantCulture) &#125;; return actionResult;&#125; 最後透過ControllerActionInvoker.InvokeActionResult來呼叫ActionResult抽象方法ExecuteResult(ControllerContext context). 1234protected virtual void InvokeActionResult(ControllerContext controllerContext, ActionResult actionResult)&#123; actionResult.ExecuteResult(controllerContext);&#125; 小結:本篇介紹了在ReflectedActionDescriptor.Execute方法產生一個ActionResult物件. ActionMethodDispatcher這個類別負責產生要呼叫ActionResult方法(透過RouteData的ActionNmae和反射取得Controller的MethInfo最後透過Expression表達式組成一個呼叫委派方法) 利用DispatcherCache屬性對於每個呼叫過的ActionMethodDispatcher進行快取增加使用效率. 上面使用Expreesion動態產生程式碼並使用Cache這個構想很適合應用在高併發且吃效率情境上.值得我們學習 最後利用CreateActionResult判斷來產生要執行ActionResult CreateActionResult方法有用到一個設計技巧null object pattern 這個模式用意是為了讓NULL或預設情況也有物件來執行(因為NULL也有屬於它的處理情境) 今天介紹MVC如何運用Expression表達式,對於Expression表達式之後有機會在跟大家做更詳細分享介紹 至於有那些ActionResult可以呼叫我們在下篇會再詳細介紹 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day22/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探討Model驗證標籤(ValidationAttribute) (第21天)]]></title>
    <url>%2FIthelp-day21%2F</url>
    <content type="text"><![CDATA[Agenda 前言 ValidationAttribute ModelValidatorProviders ModelValidator CompositeModelValidator DataAnnotationsModelValidator DataAnnotationsModelValidatorProvider 小結: 前言CachedDataAnnotationsMetadataAttributes這個類別攔截某些標籤可被攔截驗證. 本篇會介紹另一個可以客製化驗證ValidationAttribute,常用驗證標籤並講述是如何參數屬性是如何取得這個標籤和使用過程. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. ValidationAttributeValidationAttribute類別在System.ComponentModel.DataAnnotations命名空間下. 我們可以建立一個類別繼承ValidationAttribute並bool IsValid(object value)重載方法來製做我們客制化驗證機制. IsValid方法有一個Bool回傳值回傳true代表驗證通過false反之 12345678public abstract class ValidationAttribute : Attribute&#123; //... public virtual bool IsValid(object value) &#123; &#125; //....&#125; RegularExpressionAttribute StringLengthAttribute RangeAttribute 如果查看上面幾個標籤原始碼可發現這幾個標籤都是繼承於一個ValidationAttribute類別(這也是為什麼我們可以透過繼承ValidationAttribute來擴充自己驗證方式). ModelValidatorProvidersModelValidatorProviders提供 DataAnnotationsModelValidatorProvider DataErrorInfoModelValidatorProvider ClientDataTypeModelValidatorProvider ModelValidatorProviderCollection是一個ModelValidatorProvider集合,可對於此集合加入ModelValidatorProvider物件. 123456789101112131415161718public static class ModelValidatorProviders&#123; private static readonly ModelValidatorProviderCollection _providers = new ModelValidatorProviderCollection() &#123; new DataAnnotationsModelValidatorProvider(), new DataErrorInfoModelValidatorProvider(), new ClientDataTypeModelValidatorProvider() &#125;; public static ModelValidatorProviderCollection Providers &#123; get &#123; return _providers; &#125; &#125;&#125;public class ModelValidatorProviderCollection : Collection&lt;ModelValidatorProvider&gt;&#123; //...&#125; 如果我們需要加入一個客製化ModelValidatorProvider，可以直接將相應物件新增到ModelValidatorProviders的Providers集合中。 ModelValidator所有的參數驗證都繼承自抽像類型ModelValidator,這個抽象類別有幾個重要成員. IsRequired:表示該ModelValidator是否是對目標屬性進行必要性驗證，默認是False GetClientValidationRules方法：ModelClientValidationRule是對客戶端驗證規則的封裝，我們會在進行客戶端驗證時對其進行詳細介紹。 Validate方法:對於屬性實施驗證,驗證完後回傳一個ModelValidationResult的集合物件. 123456789public abstract class ModelValidator&#123; ///.... public abstract IEnumerable&lt;ModelValidationResult&gt; Validate(object container); public virtual IEnumerable&lt;ModelClientValidationRule&gt; GetClientValidationRules(); public virtual bool IsRequired &#123; get; &#125;&#125; CompositeModelValidator從類別名稱可看出CompositeModelValidator,實並不是一個真正對Model物件實施驗證ModelValidator，它是一系列ModelValidator組合,根據基於Model本身類型及其屬性的Model元數據動態的取得ModelValidator（通過調用ModelMetadata.GetValidators方法）對Model參數實施驗證。 1234567891011121314151617181920212223242526272829303132333435private class CompositeModelValidator : ModelValidator&#123; //... public override IEnumerable&lt;ModelValidationResult&gt; Validate(object container) &#123; bool propertiesValid = true; ModelMetadata[] properties = Metadata.PropertiesAsArray; for (int propertyIndex = 0; propertyIndex &lt; properties.Length; propertyIndex++) &#123; ModelMetadata propertyMetadata = properties[propertyIndex]; foreach (ModelValidator propertyValidator in propertyMetadata.GetValidators(ControllerContext)) &#123; foreach (ModelValidationResult propertyResult in propertyValidator.Validate(Metadata.Model)) &#123; propertiesValid = false; yield return CreateSubPropertyResult(propertyMetadata, propertyResult); &#125; &#125; &#125; if (propertiesValid) &#123; foreach (ModelValidator typeValidator in Metadata.GetValidators(ControllerContext)) &#123; foreach (ModelValidationResult typeResult in typeValidator.Validate(container)) &#123; yield return typeResult; &#125; &#125; &#125; &#125;&#125; 下圖是ModelValidator、ModelValidatorProvider、ModelValidatorProvidersUML關係圖 DataAnnotationsModelValidatorModelValidator物件是用於進行Model參數驗證的模組類別中的ValidationAttribute透過建構子設定檢驗的標籤. 12345678910111213141516171819202122232425public class DataAnnotationsModelValidator : ModelValidator&#123; public DataAnnotationsModelValidator(ModelMetadata metadata, ControllerContext context, ValidationAttribute attribute); protected internal ValidationAttribute Attribute &#123; get; private set; &#125; public override bool IsRequired &#123; get &#123; return Attribute is RequiredAttribute; &#125; &#125; internal static ModelValidator Create(ModelMetadata metadata, ControllerContext context, ValidationAttribute attribute) &#123; return new DataAnnotationsModelValidator(metadata, context, attribute); &#125; public override IEnumerable&lt;ModelClientValidationRule&gt; GetClientValidationRules() &#123; //.... &#125; public override IEnumerable&lt;ModelValidationResult&gt; Validate(object container) &#123; //.... &#125;&#125; ### DataAnnotationsModelValidator DataAnnotationsModelValidator&lt;TAttribute&gt;這個泛型類別有一個合約TAttribute必須為ValidationAttribute DataAnnotationsModelValidator&lt;TAttribute&gt;的子類。當我們將這些ValidationAttribute應用到Model型別時，真正用於Model參數驗證是ModelValidator的轉接器類別 在這裡使用轉接器模式把每個繼承ValidationAttribute標籤適配給一個ModelValidator物件. 例如下面程式碼每個ModelValidator都有自己的轉接器類別. RangeAttributeAdapter = RangeAttribute RequiredAttributeAdapter = RequiredAttribute StringLengthAttributeAdapter = StringLengthAttribute RegularExpressionAttributeAdapter = RegularExpressionAttribute 1234567891011121314151617181920212223242526public classDataAnnotationsModelValidator&lt;TAttribute&gt; : DataAnnotationsModelValidatorwhere TAttribute : ValidationAttribute&#123; //....&#125;public class RequiredAttributeAdapter : DataAnnotationsModelValidator&lt;RequiredAttribute&gt;&#123; //....&#125; public class RangeAttributeAdapter : DataAnnotationsModelValidator&lt;RangeAttribute&gt;&#123; //....&#125; public class RegularExpressionAttributeAdapter : DataAnnotationsModelValidator&lt; RegularExpressionAttribute&gt;&#123; //....&#125; public class StringLengthAttributeAdapter : DataAnnotationsModelValidator&lt; StringLengthAttribute&gt;&#123; //....&#125; DataAnnotationsModelValidatorProvider有一個委派DataAnnotationsModelValidationFactory主要可以存放一個執行動作且回傳一個ModelValidator 123public delegate ModelValidator DataAnnotationsModelValidationFactory(ModelMetadata metadata, ControllerContext context, ValidationAttribute attribute);public delegate ModelValidator DataAnnotationsValidatableObjectAdapterFactory(ModelMetadata metadata, ControllerContext context); AttributeFactories：一個字典集合從屬性載入預設擁有ValidationAttribute標籤(上面介紹的轉接器RegularExpressionAttributeAdapter….) DefaultAttributeFactory：如果從AttributeFactories這個字典無法取得繼承ValidationAttribute標籤(自己客製化)就藉由DataAnnotationsModelValidator取得. 123456789101112131415161718192021222324252627282930313233internal static DataAnnotationsModelValidationFactory DefaultAttributeFactory = (metadata, context, attribute) =&gt; new DataAnnotationsModelValidator(metadata, context, attribute);internal static DataAnnotationsValidatableObjectAdapterFactory DefaultValidatableFactory = (metadata, context) =&gt; new ValidatableObjectAdapter(metadata, context);internal static Dictionary&lt;Type, DataAnnotationsModelValidationFactory&gt; AttributeFactories = BuildAttributeFactoriesDictionary();protected override IEnumerable&lt;ModelValidator&gt; GetValidators(ModelMetadata metadata, ControllerContext context, IEnumerable&lt;Attribute&gt; attributes)&#123; //.. foreach (ValidationAttribute attribute in attributes.OfType&lt;ValidationAttribute&gt;()) &#123; DataAnnotationsModelValidationFactory factory; if (!AttributeFactories.TryGetValue(attribute.GetType(), out factory)) &#123; factory = DefaultAttributeFactory; &#125; results.Add(factory(metadata, context, attribute)); &#125; // Produce a validator if the type supports IValidatableObject if (typeof(IValidatableObject).IsAssignableFrom(metadata.ModelType)) &#123; DataAnnotationsValidatableObjectAdapterFactory factory; if (!ValidatableFactories.TryGetValue(metadata.ModelType, out factory)) &#123; factory = DefaultValidatableFactory; &#125; results.Add(factory(metadata, context)); &#125; //....&#125; 最後從Model元數據中載入所有ValidationAttribute驗證標籤後就會在DefaultModelBinder.BindProperties呼叫方法時被觸發驗證 小結:在整個Model-Binding流程中,算是蠻複雜的石頭希望可以跟大家簡述一些綁定概念和做法. ValidationAttribute是舊有的類別,MVC利用一系列手法將她很好融入系統中. 原本ValidationAttribute被多個標籤繼承,透過DataAnnotationsModelValidator&lt;TAttribute&gt;設計(讓我驚豔),變成一個1對1關係(每個ValidationAttribute都有自己的轉接器物件),之後就可以在BuildAttributeFactoriesDictionary()更方便使用. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day21/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探討Model上客製化標籤如何被解析使用 (第20天)]]></title>
    <url>%2FIthelp-day20%2F</url>
    <content type="text"><![CDATA[Agenda 前言 IMetadataAware介面 AllowHtmlAttribute標籤 為何可以透過實現IMetadataAware介面來擴充對於metadata操作 CachedDataAnnotationsModelMetadataProvider CachedDataAnnotationsModelMetadata CachedDataAnnotationsMetadataAttributes 小結： 前言上一篇有介紹ModelMetadata和參數Model之間的關係. MVC提供我們一個IMetadataAware介面,讓我們可以對最終生成ModelMetadata進行自由設定. IMetadataAware介面在IMetadataAware介面有一個OnMetadataCreated方法 1234public interface IMetadataAware&#123; void OnMetadataCreated(ModelMetadata metadata);&#125; 在MVC有預設兩個實現IMetadataAware介面的標籤. AllowHtmlAttribute:標上的屬性可以攜帶Html資料. AdditionalMetadataAttribute:對於當前屬性的modelmetadata資訊的AdditionalValues添加資料(添加資料可透過ViewData.ModelMetadata.AdditionalValues取得資料) 如果你想要對於modelmetadata資訊做修改或新增資料可以製作自己IMetadataAware介面標籤. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. AllowHtmlAttribute標籤為了防止(Cross-site scripting)XSS攻擊通過在針對某些輸入框中寫入或注入HTML來攻擊我們Web應用 針對HTML標記驗證通過ModelMetadata的RequestValidationEnabled來控制，如下面程式碼顯示 這是一個布爾類型的可讀寫屬性。 1234public class ModelMetadata&#123; public virtual bool RequestValidationEnabled &#123; get; set; &#125; &#125; 此屬性在默認情況下為True進行驗證防護 ASP.NET MVC有一個預設標籤AllowHtmlAttribute在進行Model綁定之前會對對應請求資料進行驗證，確保沒有任何HTML標記包含其中。 如果在Input tag輸入有關Html資料就會出現下面錯誤.(這是MVC貼心幫我們開啟防護XSS攻擊的機制) 具有潛在危險Request.Form 的值已從用戶端 (xxxxxx) 偵測到。 如果查看AllowHtmlAttribute原始碼就很簡單只是把metadata.RequestValidationEnabled設成false允許使用者上傳Html資料. 12345678910111213[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]public sealed class AllowHtmlAttribute : Attribute, IMetadataAware&#123; public void OnMetadataCreated(ModelMetadata metadata) &#123; if (metadata == null) &#123; throw new ArgumentNullException("metadata"); &#125; metadata.RequestValidationEnabled = false; &#125;&#125; 我們就可以把Html資料傳送到AP端了 只是這個標籤請斟酌使用打開有一定風險. 為何可以透過實現IMetadataAware介面來擴充對於metadata操作在AssociatedMetadataProvider抽象類別中有個ApplyMetadataAwareAttributes方法. 參數物件上屬性進行反射取得使用到IMetadataAware的標籤,並呼叫他的OnMetadataCreated方法. 12345678910public abstract class AssociatedMetadataProvider : ModelMetadataProvider&#123; private static void ApplyMetadataAwareAttributes(IEnumerable&lt;Attribute&gt; attributes, ModelMetadata result) &#123; foreach (IMetadataAware awareAttribute in attributes.OfType&lt;IMetadataAware&gt;()) &#123; awareAttribute.OnMetadataCreated(result); &#125; &#125;&#125; CachedDataAnnotationsModelMetadataProvider在MVC Action傳入參數上可以標示許多標籤例如 12345678910111213141516171819202122public class VerifyCodeViewModel&#123; [Required] public string Provider &#123; get; set; &#125; [Required] [Display(Name = "代碼")] public string Code &#123; get; set; &#125; public string ReturnUrl &#123; get; set; &#125; [Display(Name = "記住此瀏覽器?")] public bool RememberBrowser &#123; get; set; &#125; public bool RememberMe &#123; get; set; &#125;&#125;public class ForgotViewModel&#123; [Required] [Display(Name = "電子郵件")] public string Email &#123; get; set; &#125;&#125; RequiredAttribute DisplayAttribute 還有其他一大堆,下面會跟大家介紹MVC是怎麼取得並使用這些標籤,ModelMetadataProviders這個類別會提供使用哪個ModelMetadataProvider 在原始碼建構子預設使用CachedDataAnnotationsModelMetadataProvider 123456789101112131415public class ModelMetadataProviders&#123; private static ModelMetadataProviders _instance = new ModelMetadataProviders(); private ModelMetadataProvider _currentProvider; private IResolver&lt;ModelMetadataProvider&gt; _resolver; internal ModelMetadataProviders(IResolver&lt;ModelMetadataProvider&gt; resolver = null) &#123; _resolver = resolver ?? new SingleServiceResolver&lt;ModelMetadataProvider&gt;( () =&gt; _currentProvider, new CachedDataAnnotationsModelMetadataProvider(), "ModelMetadataProviders.Current"); &#125; //....&#125; 在CachedDataAnnotationsModelMetadataProvider類別有一個CreateMetadataPrototype方法返回一個CachedDataAnnotationsModelMetadata物件,這個物件存放參數上屬性欄位使用標籤資訊. 123456789101112public class CachedDataAnnotationsModelMetadataProvider : CachedAssociatedMetadataProvider&lt;CachedDataAnnotationsModelMetadata&gt;&#123; protected override CachedDataAnnotationsModelMetadata CreateMetadataPrototype(IEnumerable&lt;Attribute&gt; attributes, Type containerType, Type modelType, string propertyName) &#123; return new CachedDataAnnotationsModelMetadata(this, containerType, modelType, propertyName, attributes); &#125; protected override CachedDataAnnotationsModelMetadata CreateMetadataFromPrototype(CachedDataAnnotationsModelMetadata prototype, Func&lt;object&gt; modelAccessor) &#123; return new CachedDataAnnotationsModelMetadata(prototype, modelAccessor); &#125;&#125; CachedDataAnnotationsModelMetadataCachedDataAnnotationsModelMetadata類別上有許多屬性,主要是方便日後來判斷使用MVC使用標籤 12345678910111213141516171819202122232425262728293031323334353637public class CachedDataAnnotationsModelMetadata : CachedModelMetadata&lt;CachedDataAnnotationsMetadataAttributes&gt;&#123; private bool _isEditFormatStringFromCache; public CachedDataAnnotationsModelMetadata(CachedDataAnnotationsModelMetadata prototype, Func&lt;object&gt; modelAccessor) : base(prototype, modelAccessor) &#123; &#125; public CachedDataAnnotationsModelMetadata(CachedDataAnnotationsModelMetadataProvider provider, Type containerType, Type modelType, string propertyName, IEnumerable&lt;Attribute&gt; attributes) : base(provider, containerType, modelType, propertyName, new CachedDataAnnotationsMetadataAttributes(attributes.ToArray())) &#123; &#125; protected override bool ComputeConvertEmptyStringToNull() &#123; return PrototypeCache.DisplayFormat != null ? PrototypeCache.DisplayFormat.ConvertEmptyStringToNull : base.ComputeConvertEmptyStringToNull(); &#125; protected override string ComputeDataTypeName() &#123; if (PrototypeCache.DataType != null) &#123; return PrototypeCache.DataType.ToDataTypeName(); &#125; if (PrototypeCache.DisplayFormat != null &amp;&amp; !PrototypeCache.DisplayFormat.HtmlEncode) &#123; return DataTypeUtil.HtmlTypeName; &#125; return base.ComputeDataTypeName(); &#125; //...&#125; 有一個蠻特別事情是CachedDataAnnotationsModelMetadata : CachedModelMetadata&lt;CachedDataAnnotationsMetadataAttributes&gt;他繼承一個泛型類別CachedDataAnnotationsMetadataAttributes存放取得物件標籤的資訊. CachedDataAnnotationsMetadataAttributesCachedDataAnnotationsMetadataAttributes類別主要把屬性上的某些標籤給值到類別的屬性上,方便CachedDataAnnotationsModelMetadata來操作使用. 這也是為什麼只有某些標籤掛在屬性上可以被使用.預設只有CachedDataAnnotationsMetadataAttributes才會被反射取得. 1234567891011121314151617181920212223242526272829303132public class CachedDataAnnotationsMetadataAttributes&#123; public CachedDataAnnotationsMetadataAttributes(Attribute[] attributes) &#123; DataType = attributes.OfType&lt;DataTypeAttribute&gt;().FirstOrDefault(); Display = attributes.OfType&lt;DisplayAttribute&gt;().FirstOrDefault(); DisplayColumn = attributes.OfType&lt;DisplayColumnAttribute&gt;().FirstOrDefault(); DisplayFormat = attributes.OfType&lt;DisplayFormatAttribute&gt;().FirstOrDefault(); DisplayName = attributes.OfType&lt;DisplayNameAttribute&gt;().FirstOrDefault(); Editable = attributes.OfType&lt;EditableAttribute&gt;().FirstOrDefault(); HiddenInput = attributes.OfType&lt;HiddenInputAttribute&gt;().FirstOrDefault(); ReadOnly = attributes.OfType&lt;ReadOnlyAttribute&gt;().FirstOrDefault(); Required = attributes.OfType&lt;RequiredAttribute&gt;().FirstOrDefault(); ScaffoldColumn = attributes.OfType&lt;ScaffoldColumnAttribute&gt;().FirstOrDefault(); //..... &#125; public DataTypeAttribute DataType &#123; get; protected set; &#125; public DisplayAttribute Display &#123; get; protected set; &#125; public DisplayColumnAttribute DisplayColumn &#123; get; protected set; &#125; public DisplayFormatAttribute DisplayFormat &#123; get; protected set; &#125; public DisplayNameAttribute DisplayName &#123; get; protected set; &#125; public EditableAttribute Editable &#123; get; protected set; &#125; public HiddenInputAttribute HiddenInput &#123; get; protected set; &#125; //.....&#125; 小結：ModelMetaData是一個Model Binding很重要物件,裡面存放許多調用參數的資訊. MVC提供一個IMetadataAware介面可以改變ModelMetaData中資訊,提高更高的彈性. 這篇也介紹了IMetadataAware介面是在哪邊做攔截. 另外也分享常掛在屬性上標籤取得的類別跟機制 DisplayNameAttribute RequiredAttribute DisplayAttribute 透過CachedDataAnnotationsModelMetadataProvider這個類別來取得以上標籤,並在日後做判斷. 下篇會和大家分享另一種屬性標籤ValidationAttribute的取得和呼叫過程. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day20/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http參數如何綁定到Action參數上(簡單和複雜模型綁定探討) (第19天)]]></title>
    <url>%2FIthelp-day19%2F</url>
    <content type="text"><![CDATA[Agenda 前言 ModelMetadata 元數據儲存參數資料 BindSimpleModel 簡單模型綁定 BindComplexModel 複雜模型綁定 小結： 簡單模型綁定 vs 複雜模型綁定 前言IValueProvider物件透過一個ValueProviderFactory工廠來產生 Action方法綁定Model参数由實現IModelBinder的介面ModelBinder（DefaultModelBinder）物件來實現 在IModelBinder介面中有一個重要的方法object BindModel取得Model參數資料. 但在Http請求傳送參數極為複雜是如何將參數動態綁定在Action參數上呢? 最常見的Json參數透過POST Body傳到AP端,經由MVC BindModel來取得參數物件資料. 如下方資料. 12345&#123; "Key":"123", "value":"", "Adress":["test133","e2424"]&#125; 123456public class RootObject&#123; public string Key &#123; get; set; &#125; public string value &#123; get; set; &#125; public List&lt;string&gt; Adress &#123; get; set; &#125;&#125; 網路上有個工具可方便使用Json字串取得c# 對應ModelJson to c# model 本篇就和大家分享這個機制是如何達成的 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. ModelMetadata 元數據儲存參數資料Model參數類型可能是一個簡單字串或者是一個值類型，也可能是一個複雜類型物件。 對於一個複雜類型物件，基於類型本身和物件成員元數據通過一個ModelMetadata類別來達成 某個成員又可能是一個複雜類型物件，通過ModelMetadata物件表示Model狀態,所以ModelMetadata(元數據)實際上具有一個樹形層次化的資料結構. 12345678910111213141516171819202122232425public class ModelMetadata&#123; public Type ModelType &#123; get; &#125; public virtual bool IsComplexType &#123; get; &#125; public bool IsNullableValueType &#123; get; &#125; public Type ContainerType &#123; get; &#125; public object Model &#123; get; set; &#125; public string PropertyName &#123; get; &#125; public virtual Dictionary&lt;string, object&gt; AdditionalValues &#123; get; &#125; protected ModelMetadataProvider Provider &#123; get; set; &#125; public virtual IEnumerable&lt;ModelMetadata&gt; Properties &#123; get &#123; if (_properties == null) &#123; IEnumerable&lt;ModelMetadata&gt; originalProperties = Provider.GetMetadataForProperties(Model, RealModelType); _propertiesInternal = SortProperties(originalProperties.AsArray()); _properties = new ReadOnlyCollection&lt;ModelMetadata&gt;(_propertiesInternal); &#125; return _properties; &#125; &#125;&#125; 在ModelMetadata類別中有幾個重要的屬性. Provider(ModelMetadataProvider):存放當前物件下面一個ModelMetadataProvider資訊,ModelMetadataProvider主要是提供ModelMetadata是如何被產生(一般使用CachedDataAnnotationsModelMetadataProvider這個類別使用MemoryCache存放資訊) IEnumerable&lt;ModelMetadata&gt;:用來表示當前物件所使用屬性資訊ModelMetadata集合 IsComplexType:判斷是否是複雜模型. ContainerType:父節點類別型態(可以看做樹狀結構,可當作存放根結點類型) ModelType:目前屬性或參數的類型. Model:綁定完使用的參數 假如這邊有兩個類別Person,AddressInfo且一個Person可以擁有多個地址 這裡就會呈現一對多關係如下圖 就像大樹支點和葉子,這個屬性可能是葉子也可能是別人的支點. 12345678910public class Person&#123; public int Age&#123; get; set; &#125; public string Name &#123; get; set; &#125; public IEnumerable&lt;AddressInfo&gt; Address &#123; get; set; &#125;&#125;public class AddressInfo&#123; public string Name &#123; get; set; &#125;&#125; 上面類別關係圖就是簡單表示複雜模型 通過上面的介紹我們知道表示Model元數據ModelMetadata具有一個樹形層次結構 在每個ModelMetadata內部都有一個型別為IEnumerable&lt;ModelMetadata&gt;的Properties屬性來引用它的下級ModelMetadata，這就形成了一個無限巢狀的後設資料表示結構. 此圖可以表示ModelMetadata跟Person類別屬性的關係. BindSimpleModel 簡單模型綁定在上面介紹了ModelMetadata這個類別儲存了參數的各個資訊. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960internal object BindSimpleModel( ControllerContext controllerContext, ModelBindingContext bindingContext, ValueProviderResult valueProviderResult )&#123; bindingContext.ModelState.SetModelValue(bindingContext.ModelName, valueProviderResult); if (bindingContext.ModelType.IsInstanceOfType(valueProviderResult.RawValue)) &#123; return valueProviderResult.RawValue; &#125; if (bindingContext.ModelType != typeof(string)) &#123; if (bindingContext.ModelType.IsArray) &#123; object modelArray = ConvertProviderResult(bindingContext.ModelState, bindingContext.ModelName, valueProviderResult, bindingContext.ModelType); return modelArray; &#125; Type enumerableType = TypeHelpers.ExtractGenericInterface(bindingContext.ModelType, typeof(IEnumerable&lt;&gt;)); if (enumerableType != null) &#123; object modelCollection = CreateModel(controllerContext, bindingContext, bindingContext.ModelType); Type elementType = enumerableType.GetGenericArguments()[0]; Type arrayType = elementType.MakeArrayType(); object modelArray = ConvertProviderResult(bindingContext.ModelState, bindingContext.ModelName, valueProviderResult, arrayType); Type collectionType = typeof(ICollection&lt;&gt;).MakeGenericType(elementType); if (collectionType.IsInstanceOfType(modelCollection)) &#123; CollectionHelpers.ReplaceCollection(elementType, modelCollection, modelArray); &#125; return modelCollection; &#125; &#125; object model = ConvertProviderResult(bindingContext.ModelState, bindingContext.ModelName, valueProviderResult, bindingContext.ModelType); return model;&#125;private static object ConvertProviderResult( ModelStateDictionary modelState, string modelStateKey, ValueProviderResult valueProviderResult, Type destinationType )&#123; try &#123; object convertedValue = valueProviderResult.ConvertTo(destinationType); return convertedValue; &#125; catch (Exception ex) &#123; modelState.AddModelError(modelStateKey, ex); return null; &#125;&#125; 透過ConvertProviderResult來將類型轉換成簡單模型綁定使用的參數實例. 在BindSimpleModel中依照下面幾個規則來做參數物件建立. Array:如果此參數是陣列,判斷此陣列型別並利用ValueProviderResult.ConvertTo()建立陣列 IEnumerable&lt;&gt;:如果此參數是IEnumerable&lt;&gt;集合,判斷此IEnumerable&lt;&gt;型別ValueProviderResult.ConvertTo()建立集合 object:不是上面的型別就直接使用ValueProviderResult.ConvertTo()建立物件. ConvertTo()方法在簡單模型物件建立起到一個很大的作用 BindComplexModel 複雜模型綁定在BindModel方法中有一個BindComplexModel方法是針對複雜模型產生的方法. 一開始先判斷ModelBindingContext.Model是否為Null如果是就會建立一個物件實例返回. 會依照下面機制判斷產生物件 判斷參數類型是否Array產生一個相對應陣列集合 判斷參數類型是否IDictionary&lt;,&gt; and ICollection&lt;&gt;集合產生一個相對應陣列集合 判斷參數類型是否IEnumerable&lt;&gt;集合產生一個相對應陣列集合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182internal object BindComplexModel( ControllerContext controllerContext, ModelBindingContext bindingContext )&#123; object model = bindingContext.Model; Type modelType = bindingContext.ModelType; if (model == null &amp;&amp; modelType.IsArray) &#123; Type elementType = modelType.GetElementType(); Type listType = typeof(List&lt;&gt;).MakeGenericType(elementType); object collection = CreateModel(controllerContext, bindingContext, listType); ModelBindingContext arrayBindingContext = new ModelBindingContext() &#123; ModelMetadata = ModelMetadataProviders.Current.GetMetadataForType(() =&gt; collection, listType), ModelName = bindingContext.ModelName, ModelState = bindingContext.ModelState, PropertyFilter = bindingContext.PropertyFilter, ValueProvider = bindingContext.ValueProvider &#125;; IList list = (IList)UpdateCollection(controllerContext, arrayBindingContext, elementType); if (list == null) &#123; return null; &#125; Array array = Array.CreateInstance(elementType, list.Count); list.CopyTo(array, 0); return array; &#125; if (model == null) &#123; model = CreateModel(controllerContext, bindingContext, modelType); &#125; Type dictionaryType = TypeHelpers.ExtractGenericInterface(modelType, typeof(IDictionary&lt;,&gt;)); if (dictionaryType != null) &#123; Type[] genericArguments = dictionaryType.GetGenericArguments(); Type keyType = genericArguments[0]; Type valueType = genericArguments[1]; ModelBindingContext dictionaryBindingContext = new ModelBindingContext() &#123; ModelMetadata = ModelMetadataProviders.Current.GetMetadataForType(() =&gt; model, modelType), ModelName = bindingContext.ModelName, ModelState = bindingContext.ModelState, PropertyFilter = bindingContext.PropertyFilter, ValueProvider = bindingContext.ValueProvider &#125;; object dictionary = UpdateDictionary(controllerContext, dictionaryBindingContext, keyType, valueType); return dictionary; &#125; Type enumerableType = TypeHelpers.ExtractGenericInterface(modelType, typeof(IEnumerable&lt;&gt;)); if (enumerableType != null) &#123; Type elementType = enumerableType.GetGenericArguments()[0]; Type collectionType = typeof(ICollection&lt;&gt;).MakeGenericType(elementType); if (collectionType.IsInstanceOfType(model)) &#123; ModelBindingContext collectionBindingContext = new ModelBindingContext() &#123; ModelMetadata = ModelMetadataProviders.Current.GetMetadataForType(() =&gt; model, modelType), ModelName = bindingContext.ModelName, ModelState = bindingContext.ModelState, PropertyFilter = bindingContext.PropertyFilter, ValueProvider = bindingContext.ValueProvider &#125;; object collection = UpdateCollection(controllerContext, collectionBindingContext, elementType); return collection; &#125; &#125; BindComplexElementalModel(controllerContext, bindingContext, model); return model;&#125; 最後呼叫BindComplexElementalModel方法將剛剛建立值(model物件)透過ValueProvider把參數給值. 有分簡單綁定和複雜綁定,最後都還是會呼叫使用簡單綁定來值綁定給物件. 在BindProperty方法時填充子節點ModelMetadata的Model屬性. GetPropertyValue透過(DefaultModelBinder)再次綁定物件動作如下 ModelMetadata是簡單模型就會把值填充給此次ModelMetadata.Model ModelMetadata是複雜模型就建立一個物件後呼叫BindProperty直到找到最後的簡單模型. 123456789101112131415161718192021222324252627282930protected virtual void BindProperty(ControllerContext controllerContext, ModelBindingContext bindingContext, PropertyDescriptor propertyDescriptor)&#123; //... IModelBinder propertyBinder = Binders.GetBinder(propertyDescriptor.PropertyType); object originalPropertyValue = propertyDescriptor.GetValue(bindingContext.Model); ModelMetadata propertyMetadata = bindingContext.PropertyMetadata[propertyDescriptor.Name]; propertyMetadata.Model = originalPropertyValue; ModelBindingContext innerBindingContext = new ModelBindingContext() &#123; ModelMetadata = propertyMetadata, ModelName = fullPropertyKey, ModelState = bindingContext.ModelState, ValueProvider = bindingContext.ValueProvider &#125;; object newPropertyValue = GetPropertyValue(controllerContext, innerBindingContext, propertyDescriptor, propertyBinder); propertyMetadata.Model = newPropertyValue; //...&#125;protected virtual object GetPropertyValue(ControllerContext controllerContext, ModelBindingContext bindingContext, PropertyDescriptor propertyDescriptor, IModelBinder propertyBinder)&#123; object value = propertyBinder.BindModel(controllerContext, bindingContext); if (bindingContext.ModelMetadata.ConvertEmptyStringToNull &amp;&amp; Equals(value, String.Empty)) &#123; return null; &#125; return value;&#125; 小結：MVC ModelBinding 使用到一個設計模式(組合模式),當我發現時覺得十分興奮. 因為在現實專案中我較少看到(組合模式),發輝良好的作用而在這個案例上發揮的淋漓盡致. 組合模式關係圖如下 參考圖片連結 組合模式基本上分為兩個部分葉(Left)和組件(component)他們都依賴於一個抽象,組件實現取得動作的抽象只為了獲得下面的葉,真正有動作只會在葉有動作 組合模式很適合用在樹狀的資料結構且需求對於葉和組件要做大量不一樣判斷. 在模型綁定中他依靠兩個東西完成上面說的依賴關聯 ModelBindingContext物件 object CreateModel方法 簡單模型綁定 vs 複雜模型綁定 簡單模型綁定:透過ModelBindingContext找到參數使用型別並利用ValueProvider給值,最後返回物件 複雜模型綁定:透過ModelBindingContext建立參數利用ValueProvider給值,往下繼續重複動作直到呼叫簡單模型綁定方法,就不會繼續往下呼叫object方法. 這裡很巧妙的利用ModelBinderDictionary取得當前參數型別並取得相對應IModelBinder實現物件. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day19/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提供ModelBing幾個重要功臣(Model) (第18天)]]></title>
    <url>%2FIthelp-day18%2F</url>
    <content type="text"><![CDATA[Agenda 前言 IModelBinder(DefaultModelBinder) ModelBinders ModelBinderDictionary IValueProvider 提供參數填值 ValueProvider工廠集合(ValueProviderFactories) ValueProviderFactory JsonValueProviderFactory 取得IValueProvider NameValueCollectionValueProvider 小結： 前言MVC的Model-Binding建立複雜物件(牽扯到複雜模型綁定.) 這篇會跟大家介紹MVC是如何把達成這個複雜的動作 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. IModelBinder(DefaultModelBinder)DefaultModelBinder將Http請求傳來資料轉換為強型別物件,DefaultModelBinder是如何取得使用Model資料呢? 實現IValueProvider來處理。 ModelBindersIModelBinder.BindModel方法使用兩個參數 1public object BindModel(ControllerContext controllerContext, ModelBindingContext bindingContext) ControllerContext:Controller資訊， ModelBindingContext:當前參數綁定資訊 BindModel方法機於Http請求傳送資料進行Model綁定(對於Action方法使用參數),其中ModelBindingContext參數會提供綁定使用的重要物件成員. 關於ModelBindingContext建立我們會在後續部分進行的單獨介紹. 在IModelBinder.BindModel方法中主要透過兩個重要internal方法. BindComplexModel:複雜參數綁定 BindSimpleModel:簡單參數綁定 下圖可以表示SimpleModel和ComplexModel ComplexModel一個人可擁有多個房子,所以Person類別擁有HouseCollection引用.取得使用ModelBinder機制。 取得ModelBinder會依照下面順序 參數掛有ModelBinderAttribute標籤並將BinderType屬性指向一個繼承IModelBinder型別. 參數掛有繼承CustomModelBinderAttribute類型 透過ModelBinderProviderCollection(預設MVC沒有提供ModelBinderProvider) 預設DefaultModelBinder 下面兩個使用ModelBinder都是DefaultModelBinder,但一個是使用第一點,另一個使用第四點. 123public ActionResult HttpModules(Person p)public ActionResult HttpModules([ModelBinder(typeof(DefaultModelBinder))]Person p) 在Global.cs可透過ModelBinders.Binders.Add方法註冊綁定類型. 如下面程式碼. 1ModelBinders.Binders.Add(typeof(Arg),new FooModelBinder()); ModelBinderDictionary一般參數透過DefaultModelBinder來幫我們完成參數綁定. 但有些特別的資料需要透過ModelBinderDictionary取得使用ModelBinder,例如上傳檔案,我們可以使用HttpPostedFileBase來取得檔案資訊流. 那是因為在ModelBinderDictionary有註冊一個HttpPostedFileBaseModelBinder來幫我們做解析. 1234567891011private static ModelBinderDictionary CreateDefaultBinderDictionary()&#123; ModelBinderDictionary binders = new ModelBinderDictionary() &#123; &#123; typeof(HttpPostedFileBase), new HttpPostedFileBaseModelBinder() &#125;, &#123; typeof(byte[]), new ByteArrayModelBinder() &#125;, &#123; typeof(Binary), new LinqBinaryModelBinder() &#125;, &#123; typeof(CancellationToken), new CancellationTokenModelBinder() &#125; &#125;; return binders;&#125; IValueProvider 提供參數填值IValueProvider介面有一個重要方法GetValue會返回ValueProviderResult物件對於ValueProvider參數封裝 1ValueProviderResult GetValue(string key) ValueProvider工廠集合(ValueProviderFactories)在ControllerBase類別中有一個屬性ValueProvider設定參數填值動作 123456789101112public IValueProvider ValueProvider&#123; get &#123; if (_valueProvider == null) &#123; _valueProvider = ValueProviderFactories.Factories.GetValueProvider(ControllerContext); &#125; return _valueProvider; &#125; set &#123; _valueProvider = value; &#125;&#125; Http傳送參數可能又多種模式(Post Form,Query String,Ajax….) 1234567891011121314151617public static class ValueProviderFactories&#123; private static readonly ValueProviderFactoryCollection _factories = new ValueProviderFactoryCollection() &#123; new ChildActionValueProviderFactory(), new FormValueProviderFactory(), new JsonValueProviderFactory(), new RouteDataValueProviderFactory(), new QueryStringValueProviderFactory(), new HttpFileCollectionValueProviderFactory(), &#125;; public static ValueProviderFactoryCollection Factories &#123; get &#123; return _factories; &#125; &#125;&#125; ChildActionValueProviderFactory：取得另一個呼叫`@Html.Action`傳來Model資料 FormValueProviderFactory：取得HTTP POST送來的資料 JsonValueProviderFactory：取得JSON資料(Content-Type = application/json) RouteDataValueProviderFactory：取得從網址路徑取得到路由參數值 QueryStringValueProviderFactory：取得從Http請求的Query String資料 HttpFileCollectionValueProviderFactory：取得檔案上傳功能傳來檔案 如果此次請求匹配到多個ValueProvider機制會怎處理? 會按照上面ProviderFactory設定順序來排執行優先順序來填值 ValueProviderFactoryMVC利用工廠模式透過ValueProviderFactory實現的工廠來IValueProvider填值提供者物件. JsonValueProviderFactory在ValueProviderFactoryIValueProvider GetValueProvider 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public sealed class JsonValueProviderFactory : ValueProviderFactory&#123; private static void AddToBackingStore(EntryLimitedDictionary backingStore, string prefix, object value) &#123; IDictionary&lt;string, object&gt; d = value as IDictionary&lt;string, object&gt;; if (d != null) &#123; foreach (KeyValuePair&lt;string, object&gt; entry in d) &#123; AddToBackingStore(backingStore, MakePropertyKey(prefix, entry.Key), entry.Value); &#125; return; &#125; IList l = value as IList; if (l != null) &#123; for (int i = 0; i &lt; l.Count; i++) &#123; AddToBackingStore(backingStore, MakeArrayKey(prefix, i), l[i]); &#125; return; &#125; // primitive backingStore.Add(prefix, value); &#125; private static object GetDeserializedObject(ControllerContext controllerContext) &#123; if (!controllerContext.HttpContext.Request.ContentType.StartsWith("application/json", StringComparison.OrdinalIgnoreCase)) &#123; // not JSON request return null; &#125; StreamReader reader = new StreamReader(controllerContext.HttpContext.Request.InputStream); string bodyText = reader.ReadToEnd(); if (String.IsNullOrEmpty(bodyText)) &#123; // no JSON data return null; &#125; JavaScriptSerializer serializer = new JavaScriptSerializer(); object jsonData = serializer.DeserializeObject(bodyText); return jsonData; &#125; public override IValueProvider GetValueProvider(ControllerContext controllerContext) &#123; if (controllerContext == null) &#123; throw new ArgumentNullException("controllerContext"); &#125; object jsonData = GetDeserializedObject(controllerContext); if (jsonData == null) &#123; return null; &#125; Dictionary&lt;string, object&gt; backingStore = new Dictionary&lt;string, object&gt;(StringComparer.OrdinalIgnoreCase); EntryLimitedDictionary backingStoreWrapper = new EntryLimitedDictionary(backingStore); AddToBackingStore(backingStoreWrapper, String.Empty, jsonData); return new DictionaryValueProvider&lt;object&gt;(backingStore, CultureInfo.CurrentCulture); &#125; //....&#125; 取得IValueProvider透過ValueProviderFactory返回相對應的IValueProvider物件. 下面介紹幾個實現ValueProvider物件 NameValueCollectionValueProviderNameValueCollectionValueProvider可從NameValueCollection集合取得參數. 因為Request.Form和Request.QueryString都是NameValueCollection類型集合. 這個方法很巧妙利用一個共同參數類型簽章來達成多態轉折點 123456789101112131415public virtual NameValueCollection Form&#123; get &#123; //.... &#125;&#125;public virtual NameValueCollection QueryString&#123; get &#123; //.... &#125;&#125; Http傳值到Server有許多方式,這裡介紹MVC利用哪個ValueProvider將Form跟QueryString填值到物件上,很巧妙使用NameValueCollectionValueProvider建構子參數NameValueCollection決定是要使用Form或QueryString填充值到參數. 1234567891011121314151617181920212223242526public sealed class FormValueProvider : NameValueCollectionValueProvider&#123; public FormValueProvider(ControllerContext controllerContext) : this(controllerContext, new UnvalidatedRequestValuesWrapper(controllerContext.HttpContext.Request.Unvalidated)) &#123; &#125; internal FormValueProvider(ControllerContext controllerContext, IUnvalidatedRequestValues unvalidatedValues) : base(controllerContext.HttpContext.Request.Form, unvalidatedValues.Form, CultureInfo.CurrentCulture) &#123; &#125;&#125;public sealed class QueryStringValueProvider : NameValueCollectionValueProvider&#123; public QueryStringValueProvider(ControllerContext controllerContext) : this(controllerContext, new UnvalidatedRequestValuesWrapper(controllerContext.HttpContext.Request.Unvalidated)) &#123; &#125; internal QueryStringValueProvider(ControllerContext controllerContext, IUnvalidatedRequestValues unvalidatedValues) : base(controllerContext.HttpContext.Request.QueryString, unvalidatedValues.QueryString, CultureInfo.InvariantCulture) &#123; &#125;&#125; 實現IValueProvider物件主要會依靠GetValue方法取得ValueProviderResult. 1234567891011121314151617181920212223242526272829303132333435363738394041424344[Serializable]public class ValueProviderResult&#123; private static readonly CultureInfo _staticCulture = CultureInfo.InvariantCulture; private CultureInfo _instanceCulture; protected ValueProviderResult() &#123; &#125; public ValueProviderResult(object rawValue, string attemptedValue, CultureInfo culture) &#123; RawValue = rawValue; AttemptedValue = attemptedValue; Culture = culture; &#125; public string AttemptedValue &#123; get; protected set; &#125; public CultureInfo Culture &#123; get &#123; if (_instanceCulture == null) &#123; _instanceCulture = _staticCulture; &#125; return _instanceCulture; &#125; protected set &#123; _instanceCulture = value; &#125; &#125; public object RawValue &#123; get; protected set; &#125; public object ConvertTo(Type type) &#123; return ConvertTo(type, null /* culture */); &#125; public virtual object ConvertTo(Type type, CultureInfo culture) &#123; //.... &#125;&#125; ValueProviderResult對於ValueProvider物件做封裝，一般存放Http參數擁有兩個只讀屬性 RawValue表示物件值 AttemptedValue主要用於顯示 ValueProviderResult提供兩個ConvertTo重載方法實現向指定目標類型轉換。 某些類型格式化依賴於相應的語言文化（比如時間、日期和貨幣等），這個語言文化通過Culture屬性來達成. 最終會呼叫一個UnwrapPossibleArrayType方法來建立物件 小結：在ControllerActionInvoker.GetParameterValue取得參數方法,ModelBing動作有兩個重要的屬性 IValueProvider:提供如何填值 IModelBinder:建立物件(綁定關聯) 預設使用DefaultModelBinder類別. 目前分享的IValueProvider和IModelBinder UML類別關聯圖如下 下篇會介紹ModelBind模型綁定重點邏輯,有分簡單參數綁定和複雜參數綁定 BindComplexModel BindSimpleModel 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day18/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Action方法如何被執行InvokeAction(二) (第17天)]]></title>
    <url>%2FIthelp-day17%2F</url>
    <content type="text"><![CDATA[Agenda 前言 ControllerActionInvoker方法 重要InvokeAction方法 取得ControllerDescriptor(ReflectedControllerDescriptor) ActionDescriptor(ReflectedActionDescriptor) ReflectedActionDescriptor 取得ActionMethod參數資訊 取得Action方法執行參數 小結: 前言上篇揭開MVC常用的過濾器如何被獲取呼叫跟基本介紹. 前幾篇有介紹ControllerDescriptor,ActionDescriptor兩個物件,今天會來細部探討他們裡面有哪些重要成員. 本篇會繼續分析呼叫Action方法邏輯和在過程中有用到重要物件跟動作. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. ControllerActionInvoker方法 重要InvokeAction方法前面有說ControllerActionInvoker類別最重要的就是InvokeAction方法,因為主要透過他去呼叫ActionResult抽象類別ExecuteResult方法. InvokeAction有兩個參數 ControllerContext:對於RequestContext,RouteData,使用Controller資訊封裝. actionName:此次呼叫方法(從RouteData取得action值) 1public virtual bool InvokeAction(ControllerContext controllerContext, string actionName) InvokeAction方法除了呼叫ExecuteResult方法外還做了其他事情,對於藉由ControllerContext封裝兩個物件. ControllerDescriptor ActionDescriptor 這兩個物件在此方法中很重要. 12ControllerDescriptor controllerDescriptor = GetControllerDescriptor(controllerContext);ActionDescriptor actionDescriptor = FindAction(controllerContext, controllerDescriptor, actionName); 取得ControllerDescriptor(ReflectedControllerDescriptor)GetControllerDescriptor會返回一個ReflectedControllerDescriptor物件. 123456789protected virtual ControllerDescriptor GetControllerDescriptor(ControllerContext controllerContext)&#123; Type controllerType = controllerContext.Controller.GetType(); ControllerDescriptor controllerDescriptor = DescriptorCache.GetDescriptor( controllerType: controllerType, creator: (Type innerType) =&gt; new ReflectedControllerDescriptor(innerType), state: controllerType); return controllerDescriptor;&#125; ReflectedControllerDescriptor裡面有許多重要資訊,我會列出其重要成員和代表含意. ControllerType此次執行Controller類型 (重要)FindAction透過此方法取得ActionDescriptor物件. GetFilterAttributes方法會透過此物件取得AcitonFilter(掛載在Controller上) 12345678910111213141516171819202122232425262728293031323334353637public abstract class ControllerDescriptor : ICustomAttributeProvider, IUniquelyIdentifiable&#123; public virtual string ControllerName &#123; get &#123; string typeName = ControllerType.Name; if (typeName.EndsWith("Controller", StringComparison.OrdinalIgnoreCase)) &#123; return typeName.Substring(0, typeName.Length - "Controller".Length); &#125; return typeName; &#125; &#125; public abstract Type ControllerType &#123; get; &#125; public abstract ActionDescriptor FindAction(ControllerContext controllerContext, string actionName); public abstract ActionDescriptor[] GetCanonicalActions(); public virtual IEnumerable&lt;FilterAttribute&gt; GetFilterAttributes(bool useCache) &#123; return GetCustomAttributes(typeof(FilterAttribute), inherit: true).Cast&lt;FilterAttribute&gt;(); &#125; public virtual bool IsDefined(Type attributeType, bool inherit) &#123; if (attributeType == null) &#123; throw new ArgumentNullException("attributeType"); &#125; return false; &#125;&#125; ReflectedControllerDescriptor實現FindAction抽象方法. 主要透過反射取得此Controller物件中相對應Action名稱的方法,並把他封裝到ReflectedActionDescriptor類別中返回. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public override ActionDescriptor FindAction(ControllerContext controllerContext, string actionName)&#123; if (controllerContext == null) &#123; throw new ArgumentNullException("controllerContext"); &#125; if (String.IsNullOrEmpty(actionName)) &#123; throw new ArgumentException(MvcResources.Common_NullOrEmpty, "actionName"); &#125; MethodInfo matched = _selector.FindActionMethod(controllerContext, actionName); if (matched == null) &#123; return null; &#125; return new ReflectedActionDescriptor(matched, actionName, this);&#125;``` ## ActionDescriptor(ReflectedActionDescriptor)執行每一個`Action`方法會通過`ActionDescriptor`物件,所以`ActionDescriptor`是另一個對於`InovkeAction`方法來說很重要物件在`ActionDescriptor`抽象類別中有許多重要的成員* `Execute`:`Action`執行呼叫方法,其中裡面的`parameters`參數就是調用`Controller`上`Action`方法鎖使用的參數.* `GetFilterAttributes`:回傳在`Action`方法上的所有`Filter`標籤* `GetFilters`:返回一個`FilterInfo`物件,這個物件可以得到應用在該`Action`方法上所有`filter`* `ActionName`:`Action`方法名稱```csharppublic abstract class ActionDescriptor : ICustomAttributeProvider, IUniquelyIdentifiable&#123; //.... public virtual bool IsDefined(Type attributeType, bool inherit); public virtual IEnumerable&lt;FilterAttribute&gt; GetFilterAttributes(bool useCache); public abstract ParameterDescriptor[] GetParameters(); public abstract object Execute(ControllerContext controllerContext, IDictionary&lt;string, object&gt; parameters); public virtual FilterInfo GetFilters(); public abstract string ActionName &#123; get; &#125; public abstract ControllerDescriptor ControllerDescriptor &#123; get; &#125; public virtual string UniqueId &#123; get; &#125;&#125; 繼承這個抽象類的子類就會擁有一種特性描述此次執行Action方法特徵和如何去使用Execute方法. ReflectedActionDescriptor 取得ActionMethod參數資訊上面提到ReflectedControllerDescriptor的ActionDescriptor FindAction(ControllerContext controllerContext, string actionName)預設使用ReflectedActionDescriptor. ReflectedActionDescriptor類別顧名思義就是依靠反射來取得Action的資訊 切入重點我們來看看ReflectedActionDescriptor如何實現Execute方法的吧 MethodInfo是從ReflectedControllerDescriptor利用反射取得執行Action方法資訊. 利用ExtractParameterFromDictionary方法將IDictionary&lt;string, object&gt; parameters傳入參數轉成可傳入方法物件. 透過ActionMethodDispatcher物件Execute方法執行Action方法(ActionMethodDispatcher透過Expression表達式動態建立方法並呼叫) ActionMethodDispatcher的Expression表達式詳解會在後面做介紹 123456789101112131415161718public MethodInfo MethodInfo &#123; get; private set; &#125;public override object Execute(ControllerContext controllerContext, IDictionary&lt;string, object&gt; parameters)&#123; //.... ParameterInfo[] parameterInfos = MethodInfo.GetParameters(); object[] parametersArray = new object[parameterInfos.Length]; for (int i = 0; i &lt; parameterInfos.Length; i++) &#123; ParameterInfo parameterInfo = parameterInfos[i]; object parameter = ExtractParameterFromDictionary(parameterInfo, parameters, MethodInfo); parametersArray[i] = parameter; &#125; ActionMethodDispatcher dispatcher = DispatcherCache.GetDispatcher(MethodInfo); object actionReturnValue = dispatcher.Execute(controllerContext.Controller, parametersArray); return actionReturnValue;&#125; actionReturnValue 是Action方法的回傳值. 取得Action方法執行參數上面提到Action使用參數會轉換到一個IDictionary&lt;string, object&gt;裡面. key：參數名稱 value：參數值 在ActionFitlerAttribute.OnActionExcuting重載方法,參數ActionExecutingContext物件中有一個屬性public virtual IDictionary&lt;string, object&gt; ActionParameters { get; set; }他透過IValueProvider解析完傳入字串轉換成一個存放參數字典. 讓我們了解一下這部分是如何完成. 1234567891011protected virtual IDictionary&lt;string, object&gt; GetParameterValues(ControllerContext controllerContext, ActionDescriptor actionDescriptor)&#123; Dictionary&lt;string, object&gt; parametersDict = new Dictionary&lt;string, object&gt;(StringComparer.OrdinalIgnoreCase); ParameterDescriptor[] parameterDescriptors = actionDescriptor.GetParameters(); foreach (ParameterDescriptor parameterDescriptor in parameterDescriptors) &#123; parametersDict[parameterDescriptor.ParameterName] = GetParameterValue(controllerContext, parameterDescriptor); &#125; return parametersDict;&#125; 在呼叫GetParameters方法返回一個ParameterDescriptor[]陣列(ParameterDescriptor存放參數相關資訊),主要呼叫ActionDescriptorHelper.GetParameters,利用反射取得MethodInfo.GetParameters在將裡面資訊封裝到ReflectedParameterDescriptor物件中. 1234567891011121314151617181920public override ParameterDescriptor[] GetParameters()&#123; return ActionDescriptorHelper.GetParameters(this, MethodInfo, ref _parametersCache);&#125;public static ParameterDescriptor[] GetParameters(ActionDescriptor actionDescriptor, MethodInfo methodInfo, ref ParameterDescriptor[] parametersCache)&#123; ParameterDescriptor[] parameters = LazilyFetchParametersCollection(actionDescriptor, methodInfo, ref parametersCache); return (ParameterDescriptor[])parameters.Clone();&#125;private static ParameterDescriptor[] LazilyFetchParametersCollection(ActionDescriptor actionDescriptor, MethodInfo methodInfo, ref ParameterDescriptor[] parametersCache)&#123; return DescriptorUtil.LazilyFetchOrCreateDescriptors( cacheLocation: ref parametersCache, initializer: (CreateDescriptorState state) =&gt; state.MethodInfo.GetParameters(), converter: (ParameterInfo parameterInfo, CreateDescriptorState state) =&gt; new ReflectedParameterDescriptor(parameterInfo, state.ActionDescriptor), state: new CreateDescriptorState() &#123; ActionDescriptor = actionDescriptor, MethodInfo = methodInfo &#125;);&#125; ReflectedParameterDescriptor包含幾個重要屬性 ParameterType:參數類型 ParameterName:參數名稱 DefaultValue:參數預設值 上面幾個為Action參數元數據資料. 利用ReflectedParameterDescriptor之前封裝方法參數資訊對於GetParameterValue方法執行物件建立. GetParameterValue方法中有幾個重要的Field IModelBinder使用DefaultModelBinder來綁定使用參數 IValueProvider依靠ValueProviderFactories來取使用哪個Provider得並綁訂傳入參數資料. 123456789101112131415161718192021protected virtual object GetParameterValue(ControllerContext controllerContext, ParameterDescriptor parameterDescriptor)&#123; Type parameterType = parameterDescriptor.ParameterType; IModelBinder binder = GetModelBinder(parameterDescriptor); IValueProvider valueProvider = controllerContext.Controller.ValueProvider; string parameterName = parameterDescriptor.BindingInfo.Prefix ?? parameterDescriptor.ParameterName; Predicate&lt;string&gt; propertyFilter = GetPropertyFilter(parameterDescriptor); ModelBindingContext bindingContext = new ModelBindingContext() &#123; FallbackToEmptyPrefix = (parameterDescriptor.BindingInfo.Prefix == null), // only fall back if prefix not specified ModelMetadata = ModelMetadataProviders.Current.GetMetadataForType(null, parameterType), ModelName = parameterName, ModelState = controllerContext.Controller.ViewData.ModelState, PropertyFilter = propertyFilter, ValueProvider = valueProvider &#125;; object result = binder.BindModel(controllerContext, bindingContext); return result ?? parameterDescriptor.DefaultValue;&#125; 小結:介紹Action參數綁定使用點和前置動作(這邊會發現很多Interface和abstract class,因為MVC提供許多可以替換點給開發人員擴充) InvokeAction方法很重要,他的職責是執行使用者請求的Action方法,在此方法中有兩個核心物件. ControllerDescriptor ActionDescriptor 這兩個物件封裝後續呼叫Action需要的資訊,特別是ActionDescriptor裡面有一個Execute方法(靠他來呼叫Action方法) 另外也簡單介紹IDictionary&lt;string, object&gt;這個字典封裝了傳入Action方法的參數, 最後帶了點Model綁訂相關使用類別 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day17/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC Filter 機制解密 (第16天)]]></title>
    <url>%2FIthelp-day16%2F</url>
    <content type="text"><![CDATA[Agenda 前言 揭密取得過濾器(Filter)機制AOP AOP(Aspect-Oriented Programming)核心概念Proxy Pattern 五種過濾器(Filter)介面 AuthorizationFilter IAuthenticationFilter and AuthenticationContext InvokeAuthenticationFilters方法 IAuthorizationFilter and AuthorizationContext AuthorizationContext類別 IActionFilter方法執行前,後的過濾器 InvokeActionResult 動作執行前,後過濾器 IExceptionFilter錯誤過濾器 小結： 前言上篇和大家介紹Filter去是如何取得且我們可以透過IOC容器註冊IFilterProvider來擴充取得Filter注入點. 在ASP.NET MVC的Filter，在執行目標前後彈性擴充額外操作(繼承ActionFilter並掛Attribute)，這是一種典型的AOP設計模式 本篇會和大家繼續分享InvokeAction後續動作. 為什麼我們在Action方法和Controller類別放置一個繼承（AuthorizationFilter、ActionFilter、ResultFilter,ExceptionFilter）標籤(Attribute)對應介面(IAuthorizationFilter、IActionFilter、IResultFilter,IExceptionFilter),程式幫我們自動載入MVC生命週期中並執行? 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. 揭密取得過濾器(Filter)機制AOPAOP 是 OOP(物件導向)一個變化程式撰寫思想。（非取代OOP而是擴充） 導入AOP幫助： 可幫我們分離核心邏輯跟非核心邏輯代碼，很好降低模組間耦合性，已便日後擴充。 非核心邏輯代碼像：(日誌記錄，性能統計，安全控制，事務處理，異常處理等代碼從業務邏輯代碼中劃分出來) 原本寫法把寫日誌相關程式寫入，業務邏輯方法中。導致此方法非單一職則。我們可以把程式重構改寫成(右圖)，將寫日誌方法抽離出來更有效達成模組化。 AOP(Aspect-Oriented Programming)核心概念Proxy PatternAOP是擴充Proxy Pattern(代理模式)概念，為每個方法提供一個代理人，可為執行前或執行後提供擴展機制，並由代理類別來呼叫真正呼叫使用方法． 如果想要更多了解代理模式可以參考我之前寫的ProxyPattern代理模式(二) 五種過濾器(Filter)介面在Asp.net MVC有五個過濾器實現AOP架構 下面順序案照執行呼叫執行順序來介紹 IAuthenticationFilter：最一開始執行驗證使用過濾器,這個介面有一個void OnAuthentication(AuthenticationContext filterContext)方法.如果驗證失敗可以對於filterContext.Result設值來結束這次請求. IAuthorizationFilter：執行過程和IAuthenticationFilter過濾器基本上一樣 IActionFilter：提供方法執行前,後的動作. IResultFilter：提供方法執行結果前,後的動作. IExceptionFilter：在執行此方法有錯誤時觸發的過濾器. MVC上面幾個過濾器,讓開發者可以很有彈性擴充自己的系統且不用動到核心原始碼.很好達到開放封閉原則 AuthorizationFilterAuthorizationFilter在ActionInvoker執行前第一項工作，因為後續工作（參數模型綁定，參數模型驗證，呼叫方法）只有在驗證成功的基礎上才會有意義。 IAuthenticationFilter and AuthenticationContext一開始呼叫InvokeAuthenticationFilters方法來取得AuthenticationContext物件,在判斷authenticationContext.Result是否有給值.如果有當作驗證失敗不用在執行後面流程. 12345678910111213141516try&#123; AuthenticationContext authenticationContext = InvokeAuthenticationFilters(controllerContext, filterInfo.AuthenticationFilters, actionDescriptor); if (authenticationContext.Result != null) &#123; AuthenticationChallengeContext challengeContext = InvokeAuthenticationFiltersChallenge( controllerContext, filterInfo.AuthenticationFilters, actionDescriptor, authenticationContext.Result); InvokeActionResult(controllerContext, challengeContext.Result ?? authenticationContext.Result); &#125; else &#123; //..... &#125;&#125; InvokeAuthenticationFilters方法123456789101112131415161718192021222324252627282930protected virtual AuthenticationContext InvokeAuthenticationFilters( ControllerContext controllerContext, IList&lt;IAuthenticationFilter&gt; filters, ActionDescriptor actionDescriptor)&#123; //.... AuthenticationContext context = new AuthenticationContext(controllerContext, actionDescriptor, originalPrincipal); foreach (IAuthenticationFilter filter in filters) &#123; filter.OnAuthentication(context); // short-circuit evaluation when an error occurs if (context.Result != null) &#123; break; &#125; &#125; IPrincipal newPrincipal = context.Principal; if (newPrincipal != originalPrincipal) &#123; Contract.Assert(context.HttpContext != null); context.HttpContext.User = newPrincipal; Thread.CurrentPrincipal = newPrincipal; &#125; return context;&#125; AuthenticationContext中重要的一個屬性是 public ActionResult Result { get; set; } 只要這個物件不為null就會直接返回此次請求. 在方法中我封裝一個AuthenticationContext物件,把它當作參數傳入IAuthenticationFilter.OnAuthentication方法中(這就是我們在繼承AuthenticationFilter使用AuthenticationContext物件) 值得一提程式會判斷context.Result是否為null來當作迴圈中斷點. 1234if (context.Result != null)&#123; break;&#125; 這個邏輯是我們對於Authentication驗證失敗後想要直接返回請求可以透過把context.Result給一個值(ActionResult物件),外面會照authenticationContext.Result是否為null為依據判斷是否繼續執行後面動作. IAuthorizationFilter and AuthorizationContext下一個步驟是檢驗IAuthorizationFilter過濾器,執行過程和IAuthenticationFilter過濾器基本上一樣 依照物件內Result屬性是否為null來當作後續執行依據. 12345678910111213AuthorizationContext authorizationContext = InvokeAuthorizationFilters(controllerContext, filterInfo.AuthorizationFilters, actionDescriptor);if (authorizationContext.Result != null)&#123; AuthenticationChallengeContext challengeContext = InvokeAuthenticationFiltersChallenge( controllerContext, filterInfo.AuthenticationFilters, actionDescriptor, authorizationContext.Result); InvokeActionResult(controllerContext, challengeContext.Result ?? authorizationContext.Result);&#125;public interface IAuthorizationFilter&#123; void OnAuthorization(AuthorizationContext filterContext);&#125; AuthorizationContext類別12345678public class AuthorizationContext : ControllerContext&#123; //..... public virtual ActionDescriptor ActionDescriptor &#123; get; set; &#125; public ActionResult Result &#123; get; set; &#125;&#125; 既然IAuthenticationFilter和IAuthorizationFilter過濾器驗證東西都很類似為什麼要分成兩個呢? 仔細比較會發現IAuthenticationFilter多了(設置Principal)，檢驗方式。 ActionDescriptor(使用ReflectedActionDescriptor)這個物件存放目前執行Action相關的資訊(裡面有一個Execute抽象方法,靠他來做Action呼叫使用) 1234protected virtual void InvokeActionResult(ControllerContext controllerContext, ActionResult actionResult)&#123; actionResult.ExecuteResult(controllerContext);&#125; 如果判斷權限錯誤或Filter需提前返回Result就會執行InvokeActionResult方法,來執行返回工作. IActionFilter方法執行前,後的過濾器有在寫Asp.net MVC的人一定對於下面這個介面不陌生,這個過濾器在InvokeActionMethodFilter使用時被呼叫. ActionExecutingContext也有一個Result物件用此判斷是否有執行後續請求.一般也是NULL ActionExecutingContext這個物件比其他過濾器參數多了一個重要的成員IDictionary&lt;string, object&gt; parameters,有這個成員我們可以針對呼叫Action參數處理. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface IActionFilter&#123; void OnActionExecuting(ActionExecutingContext filterContext); void OnActionExecuted(ActionExecutedContext filterContext);&#125;internal static ActionExecutedContext InvokeActionMethodFilter(IActionFilter filter, ActionExecutingContext preContext, Func&lt;ActionExecutedContext&gt; continuation)&#123; //執行Action 過濾器 filter.OnActionExecuting(preContext); //如果有Result 直接返回 if (preContext.Result != null) &#123; return new ActionExecutedContext(preContext, preContext.ActionDescriptor, true /* canceled */, null /* exception */) &#123; Result = preContext.Result &#125;; &#125; bool wasError = false; ActionExecutedContext postContext = null; try &#123; postContext = continuation(); &#125; catch (ThreadAbortException) &#123; postContext = new ActionExecutedContext(preContext, preContext.ActionDescriptor, false /* canceled */, null /* exception */); //執行Action後 過濾器 filter.OnActionExecuted(postContext); throw; &#125; catch (Exception ex) &#123; wasError = true; postContext = new ActionExecutedContext(preContext, preContext.ActionDescriptor, false /* canceled */, ex); filter.OnActionExecuted(postContext); if (!postContext.ExceptionHandled) &#123; throw; &#125; &#125; if (!wasError) &#123; filter.OnActionExecuted(postContext); &#125; return postContext;&#125; 其中有一段continuation這個委派是InvokeActionMethod這個方法,這個方法取得使用Action方法. 123456protected virtual ActionResult InvokeActionMethod(ControllerContext controllerContext, ActionDescriptor actionDescriptor, IDictionary&lt;string, object&gt; parameters)&#123; object returnValue = actionDescriptor.Execute(controllerContext, parameters); ActionResult result = CreateActionResult(controllerContext, actionDescriptor, returnValue); return result;&#125; 1234try&#123; postContext = continuation();&#125; ActionExecutedContext物件中的Result屬性就是執行Action方法後的結果 InvokeActionResult 動作執行前,後過濾器呼叫InvokeActionResult過濾器藉由InvokeActionResultFilterRecursive方法 這個方法使用遞迴方式看之前的使用for loop執行過濾器方式有所不同,幸好在原始碼有註解. 主要是因為下面原因 OnResultExecuting事件必須按正向順序觸,發然後必須觸發InvokeActionResult(執行Action動作方法),OnResultExecuted事件必須以相反的順序觸發 1234567891011121314151617181920212223242526272829303132333435363738394041424344private ResultExecutedContext InvokeActionResultFilterRecursive(IList&lt;IResultFilter&gt; filters, int filterIndex, ResultExecutingContext preContext, ControllerContext controllerContext, ActionResult actionResult)&#123; if (filterIndex &gt; filters.Count - 1) &#123; InvokeActionResult(controllerContext, actionResult); return new ResultExecutedContext(controllerContext, actionResult, canceled: false, exception: null); &#125; IResultFilter filter = filters[filterIndex]; filter.OnResultExecuting(preContext); if (preContext.Cancel) &#123; return new ResultExecutedContext(preContext, preContext.Result, canceled: true, exception: null); &#125; bool wasError = false; ResultExecutedContext postContext = null; try &#123; int nextFilterIndex = filterIndex + 1; postContext = InvokeActionResultFilterRecursive(filters, nextFilterIndex, preContext, controllerContext, actionResult); &#125; catch (ThreadAbortException) &#123; postContext = new ResultExecutedContext(preContext, preContext.Result, canceled: false, exception: null); filter.OnResultExecuted(postContext); throw; &#125; catch (Exception ex) &#123; wasError = true; postContext = new ResultExecutedContext(preContext, preContext.Result, canceled: false, exception: ex); filter.OnResultExecuted(postContext); if (!postContext.ExceptionHandled) &#123; throw; &#125; &#125; if (!wasError) &#123; filter.OnResultExecuted(postContext); &#125; return postContext;&#125; 在OnResultExecuting方法的ResultExecutingContext可以藉由Canceled這個屬性來最後控制是否要執行Action方法,如果不要將這個值設定為false. 1public virtual bool Canceled &#123; get; set; &#125; IExceptionFilter錯誤過濾器最後介紹錯誤時呼叫的過濾器IExceptionFilter 可以看到在執行方法的最前面使用了一個try....catch而最後catch程式碼如下. 在這個方法中有一個重要的屬性是bool ExceptionHandled,如果在錯誤時設定為true她就會執行Result的結果(因為最後呼叫了InvokeActionResult方法. 1234567891011121314151617181920212223//....catch (Exception ex)&#123; // 錯誤處理過濾器 ExceptionContext exceptionContext = InvokeExceptionFilters(controllerContext, filterInfo.ExceptionFilters, ex); //如果需要自己處理錯誤 exceptionContext.ExceptionHandled 設為true if (!exceptionContext.ExceptionHandled) &#123; throw; &#125; InvokeActionResult(controllerContext, exceptionContext.Result);&#125;protected virtual ExceptionContext InvokeExceptionFilters(ControllerContext controllerContext, IList&lt;IExceptionFilter&gt; filters, Exception exception)&#123; ExceptionContext context = new ExceptionContext(controllerContext, exception); foreach (IExceptionFilter filter in filters.Reverse()) &#123; filter.OnException(context); &#125; return context;&#125; 小結：過濾器這部分原始碼很值得大家探討,因為在主流IOC容器框架有支援AOP概念. AOP有很大優點是可做到設計五大原則的其中兩項 單一職責原則 開放封閉原則 使程式碼耦合性變低 執行Action方法前,如何取得權限過濾器並呼叫檢驗,另外在呼叫方法前可以看到會把用到的資訊封裝到一個Context物件中. IAuthenticationFilter和IAuthorizationFilter基本上都是權限驗證的過濾器 但有先後順序,這點需注意!! 先執行IAuthenticationFilter後IAuthorizationFilter 看了MVC過濾器原始碼後有感而法,石頭就基於RealProxy這個類別做了一個AOP開源框架AwesomeProxy.Net. 下篇會繼續介紹Action參數如何建立,遇到複雜Model MVC是怎麼處理 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day16/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Action方法如何被執行InvokeAction(一) (第15天)]]></title>
    <url>%2FIthelp-day15%2F</url>
    <content type="text"><![CDATA[Agenda 前言 InvokeAction方法 在Controller類別中 重要方法ExecuteCore() 取得執行的ActionInvoker(AsyncControllerActionInvoker) ControllerActionInvoker呼叫InvokeAction方法 取得 ControllerDescriptor &amp; ActionDescriptor Asp.net AOP機制揭密(Filter) 預設使用FilterProviders(FilterProviderCollection) FilterAttributeFilterProvider(取得標籤的Filter) FilterProviderCollection的GetFilters方法(額外註冊過濾器) 小結 前言前面介紹完 Asp.net MVC解析器和IOC容器之間關係 本篇要介紹Controller如何去呼叫使用的Action方法. ExecuteCore是ControllerBase類別提供給Controller來實作Hook方法. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. InvokeAction方法之前說到MVC呼叫ControllerBase.Execute方法,其中這個方法做了幾件事情 VerifyExecuteCalledOnce方法對於同步請求做一個防呆機制(不允許同一時間處理相同請求) Initialize初始化資料 呼叫ExecuteCore抽象方法(由Controller實現) 在ControllerBase會InvokeAction來執行並叫Action方法. 12345678910111213141516171819202122public abstract class ControllerBase : IController&#123; //.... protected virtual void Execute(RequestContext requestContext) &#123; if (requestContext == null) &#123; throw new ArgumentNullException("requestContext"); &#125; if (requestContext.HttpContext == null) &#123; throw new ArgumentException(MvcResources.ControllerBase_CannotExecuteWithNullHttpContext, "requestContext"); &#125; VerifyExecuteCalledOnce(); Initialize(requestContext); using (ScopeStorage.CreateTransientScope()) &#123; ExecuteCore(); &#125; &#125;&#125; 在Controller類別中 重要方法ExecuteCore()在上面有說到ExecuteCore抽象方法由Controller來實現 12345678910111213141516protected override void ExecuteCore()&#123; PossiblyLoadTempData(); try &#123; string actionName = GetActionName(RouteData); if (!ActionInvoker.InvokeAction(ControllerContext, actionName)) &#123; HandleUnknownAction(actionName); &#125; &#125; finally &#123; PossiblySaveTempData(); &#125;&#125; 這個方法會呼叫GetActionName透過Route規則解析Action名稱,在呼叫ActionInvoker的InvokeAction方法判斷呼叫Action方法是否呼叫成功. 取得執行的ActionInvoker(AsyncControllerActionInvoker)ActionInvoker是一個在Controller屬性,一開始先判斷_actionInvoker是否為null如果是就會建立一個IActionInvoker物件. 123456789101112public IActionInvoker ActionInvoker&#123; get &#123; if (_actionInvoker == null) &#123; _actionInvoker = CreateActionInvoker(); &#125; return _actionInvoker; &#125; set &#123; _actionInvoker = value; &#125;&#125; 讓我們來看看CreateActionInvoker方法如何建立IActionInvoker物件吧! 123456789101112131415161718protected virtual IActionInvoker CreateActionInvoker()&#123; IAsyncActionInvokerFactory asyncActionInvokerFactory = Resolver.GetService&lt;IAsyncActionInvokerFactory&gt;(); if (asyncActionInvokerFactory != null) &#123; return asyncActionInvokerFactory.CreateInstance(); &#125; IActionInvokerFactory actionInvokerFactory = Resolver.GetService&lt;IActionInvokerFactory&gt;(); if (actionInvokerFactory != null) &#123; return actionInvokerFactory.CreateInstance(); &#125; // Note that getting a service from the current cache will return the same instance for every request. return Resolver.GetService&lt;IAsyncActionInvoker&gt;() ?? Resolver.GetService&lt;IActionInvoker&gt;() ?? new AsyncControllerActionInvoker();&#125; 透過CreateActionInvoker方法來取得執行IActionInvoker,取得順序如下 透過解析器找尋是否有實現AsyncActionInvokerFactory物件 透過解析器找尋是否有實現IActionInvokerFactory物件 透過解析器IAsyncActionInvoker物件 透過解析器IActionInvoker物件 建立一個AsyncControllerActionInvoker物件 所以預設是使用AsyncControllerActionInvoker這個非同步ActionInvoker ControllerActionInvoker呼叫InvokeAction方法 ControllerActionInvoker是同步版本 AsyncControllerActionInvoker是非同步版本 使用InvokeAction方法來調用我們使用的Action方法,並透過執行完回傳Bool辨別調用是否成功. 取得 ControllerDescriptor &amp; ActionDescriptor在InvokeAction方法一開始會先取得ControllerDescriptor和ActionDescriptor兩個物件(把得到資訊進行封裝). 12ControllerDescriptor controllerDescriptor = GetControllerDescriptor(controllerContext);ActionDescriptor actionDescriptor = FindAction(controllerContext, controllerDescriptor, actionName); GetControllerDescriptor取得Controller封裝後的資訊(同步使用ReflectedControllerDescriptor). 取得ActionDescriptor(ReflectedActionDescriptor)並在執行Execute方法要靠他來執行Action方法 FindAction返回一個ActionDescriptor. 這個物件對於日後呼叫Action方法有很重要地位. 1234567891011public override ActionDescriptor FindAction(ControllerContext controllerContext, string actionName)&#123; //...... MethodInfo matched = _selector.FindActionMethod(controllerContext, actionName); if (matched == null) &#123; return null; &#125; return new ReflectedActionDescriptor(matched, actionName, this);&#125; ReflectedControllerDescriptor利用反射取得要執行的Method資料(MethodInfo),並封裝到ReflectedActionDescriptor類別中. Asp.net AOP機制揭密(Filter)取得完ActionDescriptor物件後,會先判斷actionDescriptor是否建立成功,如果建立成功就會呼叫GetFilters方法取得目前所有註冊過濾器. 1234if (actionDescriptor != null)&#123; FilterInfo filterInfo = GetFilters(controllerContext, actionDescriptor); //.... 呼叫GetFilters方法會取得Asp.net MVC註冊的所有Filter物件(提供一個織布點方便開發人員彈性做擴充). 123456private Func&lt;ControllerContext, ActionDescriptor, IEnumerable&lt;Filter&gt;&gt; _getFiltersThunk = FilterProviders.Providers.GetFilters;protected virtual FilterInfo GetFilters(ControllerContext controllerContext, ActionDescriptor actionDescriptor)&#123; return new FilterInfo(_getFiltersThunk(controllerContext, actionDescriptor));&#125; _getFiltersThunk是一個委派物件,預設使用FilterProviders.Providers.GetFilters FilterProviderCollection這個集合對象在前一篇Asp.net MVC DI有介紹到,對於DI做一個擴充點(CombinedItems)屬性從容器中取得有對於IFilterProvider註冊Filter物件. 預設使用FilterProviders(FilterProviderCollection)MVC會透過FilterProviders.Providers取得預設使用FilterProvider,透過以下三個地方取得 GlobalFilterCollection(在Global擴充) ControllerInstanceFilterProvider(Controller自行Override) FilterAttributeFilterProvider(提供Attribute註冊最常用) 123456789101112131415/// &lt;summary&gt;/// 提供Filter AOP讀取的位置/// &lt;/summary&gt;public static class FilterProviders&#123; static FilterProviders() &#123; Providers = new FilterProviderCollection(); Providers.Add(GlobalFilters.Filters); Providers.Add(new FilterAttributeFilterProvider()); Providers.Add(new ControllerInstanceFilterProvider()); &#125; public static FilterProviderCollection Providers &#123; get; private set; &#125;&#125; FilterAttributeFilterProvider(取得標籤的Filter)IFilterProvider介面提供一個方法GetFilters取得過濾器集合 1234567891011121314151617181920212223public interface IFilterProvider&#123; IEnumerable&lt;Filter&gt; GetFilters(ControllerContext controllerContext, ActionDescriptor actionDescriptor);&#125;public class FilterAttributeFilterProvider : IFilterProvider&#123; //.... public virtual IEnumerable&lt;Filter&gt; GetFilters(ControllerContext controllerContext, ActionDescriptor actionDescriptor) &#123; if (controllerContext.Controller != null) &#123; foreach (FilterAttribute attr in GetControllerAttributes(controllerContext, actionDescriptor)) &#123; yield return new Filter(attr, FilterScope.Controller, order: null); &#125; foreach (FilterAttribute attr in GetActionAttributes(controllerContext, actionDescriptor)) &#123; yield return new Filter(attr, FilterScope.Action, order: null); &#125; &#125; &#125;&#125; 從程式碼得知 GetControllerAttributes從Controller取得,所有繼承FilterAttribute標籤. GetActionAttributes從Action取得,所有繼承FilterAttribute標籤. 我們最常把Filter寫在Controller或Action上就是透過FilterAttributeFilterProvider的GetFilters方法取得標籤並封裝成Filter物件返回,使用. FilterProviderCollection的GetFilters方法(額外註冊過濾器)GetFilters方法利用CombinedItems取得所有IFilterProvider物件,再利用GetFilters方法逐一取得註冊Filter物件. 12345678910111213141516171819202122public IEnumerable&lt;Filter&gt; GetFilters(ControllerContext controllerContext, ActionDescriptor actionDescriptor)&#123; //..... IFilterProvider[] providers = CombinedItems; List&lt;Filter&gt; filters = new List&lt;Filter&gt;(); for (int i = 0; i &lt; providers.Length; i++) &#123; IFilterProvider provider = providers[i]; foreach (Filter filter in provider.GetFilters(controllerContext, actionDescriptor)) &#123; filters.Add(filter); &#125; &#125; filters.Sort(_filterComparer); if (filters.Count &gt; 1) &#123; RemoveDuplicates(filters); &#125; return filters;&#125; 小結今天就先分享執行Action前執行動作,在InvokeAction方法中有兩個很重要的物件. ControllerDescriptor封裝Controller主要使用資訊 ActionDescriptor封裝Action主要使用資訊,並利用裡面的Execute方法執行Action. 另外一點我們也了解Asp.net MVC如何實現AOP編寫方式,透過Attribute + Filter,讓系統更有擴展性. 目前Filter類別跟ControllerActionInvoker類別UML圖關係如下 下篇會跟大家分享MVC Filter是在哪裡被呼叫且裡面Filter參數是如何被產生的. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day15/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反轉起來~透過IOC解析來執行依賴反轉 (第14天)]]></title>
    <url>%2FIthelp-day14%2F</url>
    <content type="text"><![CDATA[Agenda 前言 DefaultControllerActivator BuildManagerViewEngine FilterProviderCollection Autofac對於MVC擴充解析器AutofacDependencyResolver 小結： 前言前一篇介紹Asp.net MVC可透過DependencyResolver.SetResolver替換成IOC容器注入控制器物件. 要建立客製化的解析器可以實現IDependencyResolver介面並使用DependencyResolver.SetResolver替換DefaultDependencyResolver預設解析器 DependencyResolver,Controller和ControllerFactory的關係如下圖 本篇介紹DependencyResolver在Asp.net MVC中有哪些實際的應用. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. DefaultControllerActivator在DefaultControllerFactory建構子建立DefaultControllerActivator,而DefaultControllerActivator有一個Create方法使用他來建立Controller物件. 1234567891011121314internal DefaultControllerFactory(IControllerActivator controllerActivator, IResolver&lt;IControllerActivator&gt; activatorResolver, IDependencyResolver dependencyResolver)&#123; if (controllerActivator != null) &#123; _controllerActivator = controllerActivator; &#125; else &#123; _activatorResolver = activatorResolver ?? new SingleServiceResolver&lt;IControllerActivator&gt;( () =&gt; null, new DefaultControllerActivator(dependencyResolver), "DefaultControllerFactory constructor"); &#125;&#125; 如果我們沒透過DependencyResolver.SetResolver方法設定其他解析器,預設使用DefaultControllerActivator類別幫助我們建立Controller物件透過Create方法. 1234567891011121314151617181920212223242526272829303132333435363738private class DefaultControllerActivator : IControllerActivator&#123; private Func&lt;IDependencyResolver&gt; _resolverThunk; public DefaultControllerActivator() : this(null) &#123; &#125; public DefaultControllerActivator(IDependencyResolver resolver) &#123; if (resolver == null) &#123; _resolverThunk = () =&gt; DependencyResolver.Current; &#125; else &#123; _resolverThunk = () =&gt; resolver; &#125; &#125; public IController Create(RequestContext requestContext, Type controllerType) &#123; try &#123; return (IController)(_resolverThunk().GetService(controllerType) ?? Activator.CreateInstance(controllerType)); &#125; catch (Exception ex) &#123; throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture, MvcResources.DefaultControllerFactory_ErrorCreatingController, controllerType), ex); &#125; &#125;&#125; 因為DependencyResolver.Current建構子傳入參數IDependencyResolver resolver一般是NULL，所以會使用DependencyResolver.Current解析器. Create方法預設利用DefaultDependencyResolver.GetService創建物件(使用Activator.CreateInstance()) BuildManagerViewEngineBuildManagerViewEngine類別的詳細介紹會在之後的View如何產生有更細節的資訊. 這邊是提一下哪邊有用到IDependencyResolver解析器. 1234567891011121314151617181920212223242526272829303132333435363738394041internal class DefaultViewPageActivator : IViewPageActivator&#123; private Func&lt;IDependencyResolver&gt; _resolverThunk; public DefaultViewPageActivator() : this(null) &#123; &#125; public DefaultViewPageActivator(IDependencyResolver resolver) &#123; if (resolver == null) &#123; _resolverThunk = () =&gt; DependencyResolver.Current; &#125; else &#123; _resolverThunk = () =&gt; resolver; &#125; &#125; public object Create(ControllerContext controllerContext, Type type) &#123; try &#123; return _resolverThunk().GetService(type) ?? Activator.CreateInstance(type); &#125; catch (MissingMethodException exception) &#123; // Ensure thrown exception contains the type name. Might be down a few levels. MissingMethodException replacementException = TypeHelpers.EnsureDebuggableException(exception, type.FullName); if (replacementException != null) &#123; throw replacementException; &#125; throw; &#125; &#125;&#125; 一樣可以看到有一個Create方法.透過跟DefaultControllerActivator一樣的操作來使用IDependencyResolver解析器 預設使用DependencyResolver.Current FilterProviderCollection可以透過IOC容器注入客製化ProvideFilter使用行為. 預設ProvideFilter有三個(詳細資訊會在之後分享) GlobalFilterCollection(在Global擴充) ControllerInstanceFilterProvider(Controller自行Override) FilterAttributeFilterProvider(提供Attribute註冊最常用) MVC Filters With Dependency Injection文章有介紹如何使用 12345678910111213internal IFilterProvider[] CombinedItems&#123; get &#123; IFilterProvider[] combinedItems = _combinedItems; if (combinedItems == null) &#123; combinedItems = MultiServiceResolver.GetCombined&lt;IFilterProvider&gt;(Items, _dependencyResolver); _combinedItems = combinedItems; &#125; return combinedItems; &#125;&#125; Autofac對於MVC擴充解析器AutofacDependencyResolver上面有說如果要改變MVC使用解析器可以透過DependencyResolver.SetResolver方法傳入一個IDependencyResolver物件,Autofac對於使的是AutofacDependencyResolver 原始碼. 替換完成後MVC就會使用AutofacDependencyResolver.GetService取得物件. 這裡就不多敘述Autofac內部完成細節. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class AutofacDependencyResolver : IDependencyResolver&#123; private static Func&lt;AutofacDependencyResolver&gt; _resolverAccessor = DefaultResolverAccessor; private readonly Action&lt;ContainerBuilder&gt; _configurationAction; private readonly ILifetimeScope _container; private ILifetimeScopeProvider _lifetimeScopeProvider; public AutofacDependencyResolver(ILifetimeScope container) &#123; if (container == null) &#123; throw new ArgumentNullException(nameof(container)); &#125; this._container = container; &#125; public AutofacDependencyResolver(ILifetimeScope container, Action&lt;ContainerBuilder&gt; configurationAction) : this(container) &#123; if (configurationAction == null) &#123; throw new ArgumentNullException(nameof(configurationAction)); &#125; this._configurationAction = configurationAction; &#125; public AutofacDependencyResolver(ILifetimeScope container, ILifetimeScopeProvider lifetimeScopeProvider) : this(container) &#123; if (lifetimeScopeProvider == null) &#123; throw new ArgumentNullException(nameof(lifetimeScopeProvider)); &#125; this._lifetimeScopeProvider = lifetimeScopeProvider; &#125; public AutofacDependencyResolver(ILifetimeScope container, ILifetimeScopeProvider lifetimeScopeProvider, Action&lt;ContainerBuilder&gt; configurationAction) : this(container, lifetimeScopeProvider) &#123; if (configurationAction == null) &#123; throw new ArgumentNullException(nameof(configurationAction)); &#125; this._configurationAction = configurationAction; &#125; /// &lt;summary&gt; /// Gets the Autofac implementation of the dependency resolver. /// &lt;/summary&gt; public static AutofacDependencyResolver Current &#123; get &#123; return _resolverAccessor(); &#125; &#125; public ILifetimeScope ApplicationContainer &#123; get &#123; return this._container; &#125; &#125; public ILifetimeScope RequestLifetimeScope &#123; get &#123; if (this._lifetimeScopeProvider == null) &#123; this._lifetimeScopeProvider = new RequestLifetimeScopeProvider(this._container); &#125; return this._lifetimeScopeProvider.GetLifetimeScope(this._configurationAction); &#125; &#125; public static void SetAutofacDependencyResolverAccessor(Func&lt;AutofacDependencyResolver&gt; accessor) &#123; if (accessor == null) &#123; _resolverAccessor = DefaultResolverAccessor; &#125; else &#123; _resolverAccessor = accessor; &#125; &#125; public virtual object GetService(Type serviceType) &#123; return this.RequestLifetimeScope.ResolveOptional(serviceType); &#125; public virtual IEnumerable&lt;object&gt; GetServices(Type serviceType) &#123; var enumerableServiceType = typeof(IEnumerable&lt;&gt;).MakeGenericType(serviceType); var instance = this.RequestLifetimeScope.Resolve(enumerableServiceType); return (IEnumerable&lt;object&gt;)instance; &#125; private static AutofacDependencyResolver DefaultResolverAccessor() &#123; var currentResolver = DependencyResolver.Current; var autofacResolver = currentResolver as AutofacDependencyResolver; if (autofacResolver != null) &#123; return autofacResolver; &#125; var targetType = currentResolver.GetType().GetField("__target"); if (targetType != null &amp;&amp; targetType.FieldType == typeof(AutofacDependencyResolver)) &#123; return (AutofacDependencyResolver)targetType.GetValue(currentResolver); &#125; throw new InvalidOperationException(string.Format( CultureInfo.CurrentCulture, AutofacDependencyResolverResources.AutofacDependencyResolverNotFound, currentResolver.GetType().FullName, typeof(AutofacDependencyResolver).FullName)); &#125;&#125; 小結：本篇挑了幾個有使用到DependencyResolver的使用點 在DefaultControllerActivator建立Controller會利用當前使用的解析器來幫我們達成(預設DefaultDependencyResolver) 如果我們不想要使用預設解析器也可自行替換自己的解析器(像Autofac第三方容器)來控制我們自己如何產生物件. 能看到Asp.net MVC在設計上運用許多小巧思可讓系統可以更好的擴充且不用到到原本的程式碼 這些設計技巧很值得我們還學習效法. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day14/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net MVC如何實現IOC解析器 (第13天)]]></title>
    <url>%2FIthelp-day13%2F</url>
    <content type="text"><![CDATA[Agenda 前言 IOC介紹 程式碼介紹IOC by Autofac AutoFac IOC容器 和 Asp.net mvc關係 DependencyResolver 揭密 MVC 裡IDependencyResolver 小結: 前言IOC依賴反轉是oop重要程式設計思想。 Ioc—Inversion of Control 控制反轉 控制反轉是一個設計思想 ，把對於某個物件的控制權移轉給第三方容器. 詳細資訊可以查看小弟另一篇文章 IOC(控制反轉)，DI(依賴注入) 深入淺出~~ 有沒有人會很好奇說為什麼只需要透過DependencyResolver.SetResolver方法我就可以直接使用AutoFac或其他IOC容器? 1234//....// 建立相依解析器IContainer container = new builder.Build();DependencyResolver.SetResolver(container); 今天跟大家分享Asp.net MVC利用什麼設計技巧,讓外部IOC容器可以很方便融入系統中. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. IOC介紹 控制反轉是一個設計思想，把對於某個物件建立,生命週期控制權移轉給第三方統一管理在設計模組時建議依賴抽象，因為各個模組間不需要知道對方太多細節（實作），知道越多耦合越強。 A物件內部有使用到B物件 A,B物件中有依賴的成份控制反轉是把原本A對B控制權移交給第三方容器。降低A對B物件的耦合性，讓雙方都倚賴第三方容器。 上面說明太抽象嗎? 可以看一下下面這張圖. 最後對於使用者來說,我只需要認識這個第三方容器並跟這個容器取得我要A物件,至於A物件和其他物件關係使用者不用瞭解 IOC容器框架有很多種但基本上都有下面兩個功能 掌控物件生命週期 設定物件關係的註冊表(取用時會依照此註冊關係建立物件並自動注入相依物件) 程式碼介紹IOC by Autofac我們依照此圖做一個簡單範例by Autofac A物件會直接引用於B和C物件這導致A掌控B和C物件創建和銷毀 如下面程式碼,A物件需要掌控B和C生命週期和物件建立. 1234public class A&#123; public B BObject &#123;get;set;&#125; = new B(); public C CObject &#123;get;set;&#125; = new C();&#125; 如果透過IOC容器我們就不用擔心物件如何建立和他所依賴B和C物件,因為我們會在容器註表中指定他的關係,使用時只需要關注如何使用此物件. 1234567891011121314151617public class A&#123; public B BObject &#123;get;private set;&#125; public C CObject &#123;get;private set;&#125; public A(B b,C c)&#123; BObject = b; CObject = c; &#125;&#125;//autofac property injectionContainerBuilder builder = new ContainerBuilder();builder.RegisterType&lt;B&gt;();builder.RegisterType&lt;C&gt;();builder.RegisterType&lt;A&gt;().PropertiesAutowired();IContainer container = builder.Build();var a = container.Resolve&lt;A&gt;(); 這個程式碼是利用Autofac框架，比起上面多了一段註冊程式碼.主要告訴容器物件之間關係和如何掌控物件生命週期. 上面例子最後只需要利用container.Resolve&lt;T&gt;方法就可以跟容器來取想要的物件,至於引用的物件是如何注入或關係我們就不必關心. AutoFac IOC容器 和 Asp.net mvc關係如果Asp.net沒有搭配IOC容器(預設使用DefaultResolver)Asp.net MVC對於使用物件必須寫死在Controller類別中 無法使用建構子或屬性來決定使用哪個物件 如下面程式碼 1234567891011121314public class HomeController : Controller&#123; IUserService userService; public HomeController(IUserService userService)&#123; if(userService == null) userService = new UserService(); &#125; public ActionResult Index() &#123; return View(); &#125; //.... 如果在建構子使用參數會丟錯誤,在[Day11] Asp.net MVC Controller是怎麼被建立談到建立Controller物件透過DefaultControllerActivator預設使用反射建立Controller物件呼叫無參數的建構子方法. 因為Asp.net MVC建立Controller是透過Activator.CreateInstance方法， 如果我們想在建構子傳入參數或是想要統一管理注入的物件，就可以使用IOC容器來幫我完成 為什麼Asp.net MVC使用DependencyResolver.SetResolver方法替換成IOC容器就可輕易替換使用容器? 1234//....// 建立相依解析器IContainer container = new builder.Build();DependencyResolver.SetResolver(container); DependencyResolver 揭密DependencyResolver.SetResolver提供一個替換_current欄位的機制 123456789101112131415161718192021222324/// &lt;summary&gt;/// 可將第三方IOC容器設置/// &lt;/summary&gt;/// &lt;param name="resolver"&gt;&lt;/param&gt;public static void SetResolver(IDependencyResolver resolver)&#123; _instance.InnerSetResolver(resolver);&#125;public static void SetResolver(object commonServiceLocator)&#123; _instance.InnerSetResolver(commonServiceLocator);&#125;public void InnerSetResolver(IDependencyResolver resolver)&#123; if (resolver == null) &#123; throw new ArgumentNullException("resolver"); &#125; _current = resolver; _currentCache = new CacheDependencyResolver(_current);&#125; Asp.net MVC 提供一個介面 IDependencyResolver 讓第三方容器實現並擴充.IDependencyResolver介面有兩個方法 GetService返回一個物件 GetServices返回一個物件集合 主要透過這GetService方法取得使用Controller物件 12345public interface IDependencyResolver&#123; object GetService(Type serviceType); IEnumerable&lt;object&gt; GetServices(Type serviceType);&#125; MVC 裡IDependencyResolverAsp.net MVC依賴DependencyResolver.Current來幫我們建立一個Controller物件 這邊介紹一下在MVC中三個IDependencyResolver解析器 CacheDependencyResolver 快取解析器(利用ConcurrentDictionary是一個多執行緒安全的字典) DefaultDependencyResolver預設使用解析器(利用反射建立物件) DelegateBasedDependencyResolver委派解析器. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455prprivate sealed class CacheDependencyResolver : IDependencyResolver&#123; //ConcurrentDictionary 是一個多執行緒 安全的Dictionary private readonly ConcurrentDictionary&lt;Type, object&gt; _cache = new ConcurrentDictionary&lt;Type, object&gt;(); private readonly ConcurrentDictionary&lt;Type, IEnumerable&lt;object&gt;&gt; _cacheMultiple = new ConcurrentDictionary&lt;Type, IEnumerable&lt;object&gt;&gt;(); private readonly Func&lt;Type, object&gt; _getServiceDelegate; private readonly Func&lt;Type, IEnumerable&lt;object&gt;&gt; _getServicesDelegate; private readonly IDependencyResolver _resolver; public CacheDependencyResolver(IDependencyResolver resolver) &#123; _resolver = resolver; _getServiceDelegate = _resolver.GetService; _getServicesDelegate = _resolver.GetServices; &#125; public object GetService(Type serviceType) &#123; return _cache.GetOrAdd(serviceType, _getServiceDelegate); &#125; public IEnumerable&lt;object&gt; GetServices(Type serviceType) &#123; return _cacheMultiple.GetOrAdd(serviceType, _getServicesDelegate); &#125;&#125;private class DefaultDependencyResolver : IDependencyResolver&#123; public object GetService(Type serviceType) &#123; // Since attempting to create an instance of an interface or an abstract type results in an exception, immediately return null // to improve performance and the debugging experience with first-chance exceptions enabled. if (serviceType.IsInterface || serviceType.IsAbstract) &#123; return null; &#125; try &#123; return Activator.CreateInstance(serviceType); &#125; catch &#123; return null; &#125; &#125; public IEnumerable&lt;object&gt; GetServices(Type serviceType) &#123; return Enumerable.Empty&lt;object&gt;(); &#125;&#125; 建立Controller預設使用DefaultDependencyResolver這個解析器 第三方IOC容器利用DependencyResolver.SetResolver方法把DefaultDependencyResolver替換掉使用他們自己實現的解析器提供物件 不是透過DefaultDependencyResolver反射來建立物件喔~ 小結:我們了解為什麼Asp.net MVC可透過DependencyResolver.SetResolver替換成IOC容器注入控制器物件. 如果要建立客製化的解析器可以實現IDependencyResolver介面並使用DependencyResolver.SetResolver替換DefaultDependencyResolver預設解析器 DependencyResolver,Controller和ControllerFactory的關係如下圖 下篇會介紹DependencyResolver在Asp.net MVC中有哪些實際的應用. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day13/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[談談Controller幾個重要成員 (第12天)]]></title>
    <url>%2FIthelp-day12%2F</url>
    <content type="text"><![CDATA[Agenda 前言 ControllerBase(Controller基礎類別) SessionStateTempDataProvider 控制儲存TempData ControllerBase Excute方法 Controller ExecuteCore ControllerContext ControllerContext AuthorizationContext 小結： 前言上篇得知MVC預設透過DefaultControllerFactory反射方式動態建立Controller物件 本篇會分享我們常用到Controller基礎類別和相關物件. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. ControllerBase(Controller基礎類別)ControllerBase具有如下幾個重要的屬性 TempData：將設置資料存於Session中,生命週期除了當下請求, 導頁後仍可續存. ViewBag：儲存Controller向view傳遞資料或變數 (型別dynamic) ViewData：儲存Controller向view傳遞資料或變數 (型別ViewDataDictionary) 雖說ViewBag和ViewData看起來使用不同的物件,但從程式碼了解到其實ViewBag也是使用ViewData引用. 1234567891011121314151617181920212223242526272829303132public abstract class ControllerBase : IController&#123; public ControllerContext ControllerContext &#123; get; set; &#125; public TempDataDictionary TempData &#123; get &#123; if (ControllerContext != null &amp;&amp; ControllerContext.IsChildAction) &#123; return ControllerContext.ParentActionViewContext.TempData; &#125; if (_tempDataDictionary == null) &#123; _tempDataDictionary = new TempDataDictionary(); &#125; return _tempDataDictionary; &#125; set &#123; _tempDataDictionary = value; &#125; &#125; public dynamic ViewBag &#123; get &#123; if (_dynamicViewDataDictionary == null) &#123; _dynamicViewDataDictionary = new DynamicViewDataDictionary(() =&gt; ViewData); &#125; return _dynamicViewDataDictionary; &#125; &#125; public ViewDataDictionary ViewData &#123; get; set; &#125;&#125; SessionStateTempDataProvider 控制儲存TempData上面說到TempData字典集合生命週期除了當下請求, 導頁後仍可續存.原因是在SessionStateTempDataProvider將資料存在Session中 1controllerContext.HttpContext.Session["__ControllerTempData"] 可以透過上面程式碼取得當前的TempData字典集合物件. ControllerBase Excute方法ControllerBase這個類別繼承IController,前篇說到在HttpHandler ProcessRequest方法會透過反射找到一個符合Http請求IController介面物件.並呼叫其Execute方法 在Execute做了幾件事情. 初始化ControllerContext物件,對於RequestContext簡易封裝. ExecuteCore呼叫Hock方法(ExecuteCore是一個抽象方法提供繼承他的物件實做,預設是Controller類別) 123456789101112131415161718192021222324protected virtual void Execute(RequestContext requestContext)&#123; if (requestContext == null) &#123; throw new ArgumentNullException("requestContext"); &#125; if (requestContext.HttpContext == null) &#123; throw new ArgumentException(MvcResources.ControllerBase_CannotExecuteWithNullHttpContext, "requestContext"); &#125; VerifyExecuteCalledOnce(); Initialize(requestContext); using (ScopeStorage.CreateTransientScope()) &#123; ExecuteCore(); &#125;&#125;void IController.Execute(RequestContext requestContext)&#123; Execute(requestContext);&#125; Controller在專案中Controller是我們預設使用繼承控制器類別，此類別中定義了很多的輔助方法和屬性讓撰寫控制器變得簡單。Controller類別除了直接繼承ControllerBase之外,Controller還顯式實現IController和IAsyncController介面，跟ASP.NET MVC 四大篩選器（IAuthorizationFilter,IActionFilter、IResultFilter,IExceptionFilter）的4個介面。 123456789101112public abstract class Controller : ControllerBase, IActionFilter, IAuthenticationFilter, IAuthorizationFilter, IDisposable, IExceptionFilter, IResultFilter, IAsyncController, IAsyncManagerContainer&#123;&#125; ExecuteCore在Controller重載實做ExecuteCore方法. 主要透過GetActionName(RouteData)取得執行的Action名稱,並透過ActionInvoker取得要Invoker的ActionInvoker. PossiblyLoadTempData：建立載入TempData PossiblySaveTempData：儲存TempData的資料 123456789101112131415161718protected override void ExecuteCore()&#123; // If code in this method needs to be updated, please also check the BeginExecuteCore() and // EndExecuteCore() methods of AsyncController to see if that code also must be updated. PossiblyLoadTempData(); try &#123; string actionName = GetActionName(RouteData); if (!ActionInvoker.InvokeAction(ControllerContext, actionName)) &#123; HandleUnknownAction(actionName); &#125; &#125; finally &#123; PossiblySaveTempData(); &#125;&#125; ControllerContext第一次初始話ControllerContext利用建構子 1public ControllerContext(RequestContext requestContext, ControllerBase controller) 在ControllerBase.Initialize方法對於ControllerContext初始化,這個上下文資料封裝了許多此次請求的資料. 1234protected virtual void Initialize(RequestContext requestContext)&#123; ControllerContext = new ControllerContext(requestContext, this);&#125; 後面對於繼承ControllerContext的Context傳入第一次初始化ControllerContext物件,在建構子函數把傳入ControllerContext的RequestContext資料填入繼承ControllerContext物件中 下面是MVC有繼承ControllerContext類別 AuthorizationContext ExceptionContext AuthenticationChallengeContext ResultExecutedContext ViewContext ResultExecutingContext ControllerContext在原始碼中可以看到ControllerContext(ControllerContext controllerContext)很巧妙把自身類別當作建構子方法參數傳入. 12Controller = controllerContext.Controller;RequestContext = controllerContext.RequestContext; 主要是要把RequestContext值給填充,之後就可以利用RequestContext取得理面一些資料. 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ControllerContext&#123; internal const string ParentActionViewContextToken = "ParentActionViewContext"; private HttpContextBase _httpContext; private RequestContext _requestContext; private RouteData _routeData; // parameterless constructor used for mocking public ControllerContext() &#123; &#125; protected ControllerContext(ControllerContext controllerContext) &#123; if (controllerContext == null) &#123; throw new ArgumentNullException("controllerContext"); &#125; Controller = controllerContext.Controller; RequestContext = controllerContext.RequestContext; &#125; public ControllerContext(HttpContextBase httpContext, RouteData routeData, ControllerBase controller) : this(new RequestContext(httpContext, routeData), controller) &#123; &#125; public ControllerContext(RequestContext requestContext, ControllerBase controller) &#123; if (requestContext == null) &#123; throw new ArgumentNullException("requestContext"); &#125; if (controller == null) &#123; throw new ArgumentNullException("controller"); &#125; RequestContext = requestContext; Controller = controller; &#125; //....&#125; AuthorizationContext我們看一下Authorizationfilter用到的參數AuthorizationContext. 在InvokeAuthorizationFilters方法將AuthorizationContext初始化 1AuthorizationContext context = new AuthorizationContext(controllerContext, actionDescriptor); 其中傳入參數controllerContext是第一次透過ControllerBase.Initialize初始化Context. 1234567891011121314151617181920212223242526public class AuthorizationContext : ControllerContext&#123; // parameterless constructor used for mocking public AuthorizationContext() &#123; &#125; public AuthorizationContext(ControllerContext controllerContext) : base(controllerContext) &#123; &#125; public AuthorizationContext(ControllerContext controllerContext, ActionDescriptor actionDescriptor) : base(controllerContext) &#123; if (actionDescriptor == null) &#123; throw new ArgumentNullException("actionDescriptor"); &#125; ActionDescriptor = actionDescriptor; &#125; public virtual ActionDescriptor ActionDescriptor &#123; get; set; &#125; public ActionResult Result &#123; get; set; &#125;&#125; 之後再呼叫base(controllerContext)利用ControllerContext建構子把資料填充. 小結：Asp.net MVC對於為了方便我們使用控制器所以對於Controller進行許多資料封裝,讓我們只要繼承Controller就可以方便使用許多屬性. 下圖是Controller核心類別關係圖.Controller類別左右兩側有本次沒介紹到類別(之後會介紹到) 當我看到ControllerContext的設計時讓我驚艷的,因為他把MVC用到Context都關聯綁定到一個類別中. 因為在商業邏輯中會有許多Model類別,且這些類別資料存在一定的相關性,我覺得這個設計可以使用可以大大改善資料傳遞上的麻煩,讓程式寫起來更安全,簡單 之後我會把上面的UML圖慢慢畫出來,一步一步揭開Asp.net MVC面紗. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day12/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net MVC Controller是怎麼被建立 (第11天)]]></title>
    <url>%2FIthelp-day11%2F</url>
    <content type="text"><![CDATA[Agenda 前言 取得執行Controller ControllerBuilder IControllerFactory介面 ControllerFactory(DefaultControllerFactory.cs) 建立Controller的IControllerActivator 小結: 前言前篇介紹MVC使用HttpHandler是MvcHandler透過並MvcRouteHandler物件來返回. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. 大家介紹如何取得Controller執行物件 取得執行Controller在ProcessRequest方法是透過ProcessRequestInit取得執行controller物件,讓我們看看是這個方法如何controller物件. 12345678910111213141516171819202122232425262728293031private void ProcessRequestInit(HttpContextBase httpContext, out IController controller, out IControllerFactory factory)&#123; HttpContext currentContext = HttpContext.Current; if (currentContext != null) &#123; bool? isRequestValidationEnabled = ValidationUtility.IsValidationEnabled(currentContext); if (isRequestValidationEnabled == true) &#123; ValidationUtility.EnableDynamicValidation(currentContext); &#125; &#125; AddVersionHeader(httpContext); RemoveOptionalRoutingParameters(); // Get the controller type string controllerName = RequestContext.RouteData.GetRequiredString("controller"); // Instantiate the controller and call Execute factory = ControllerBuilder.GetControllerFactory(); controller = factory.CreateController(RequestContext, controllerName); if (controller == null) &#123; throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture, MvcResources.ControllerBuilder_FactoryReturnedNull, factory.GetType(), controllerName)); &#125;&#125; 從上面程式碼可以得知我們執行Controller物件實現於IController介面，並會呼叫IController.Execute方法. IController介面是同步的方式執行。為了支持非同步請求處理，IController介面非同步版本System.Web.Mvc.IAsyncController被定義出来。IAsyncController介面通過BeginExecute/EndExecute方法组合来完成。 12345678910public interface IController&#123; void Execute(RequestContext requestContext);&#125;public interface IAsyncController : IController&#123; IAsyncResult BeginExecute(RequestContext requestContext, AsyncCallback callback, object state); void EndExecute(IAsyncResult asyncResult);&#125; 透過RouteData.GetRequiredString取得執行Controller名稱，經由RouteValueDictionary查找之前註冊Url樣板並解析此次要使用Controller名稱 1234567891011121314public string GetRequiredString(string valueName)&#123; object obj; if (this.Values.TryGetValue(valueName, out obj)) &#123; string str = obj as string; if (!string.IsNullOrEmpty(str)) return str; &#125; throw new InvalidOperationException(string.Format((IFormatProvider) CultureInfo.CurrentUICulture, System.Web.SR.GetString("RouteData_RequiredValue"), new object[1] &#123; (object) valueName &#125;));&#125; ControllerBuilderControllerBuilder類別定義一個Current靜態只讀屬性現在返回ControllerBuilder物件是一個全域物件。SetControllerFactory方法重載用於註冊ControllerFactory類型或物件，而GetControllerFactory方法返回一個具體ControllerFactory物件。 我們透過GetControllerFactory取得返回Controller工廠. 123456789public class ControllerBuilder&#123; public IControllerFactory GetControllerFactory(); public void SetControllerFactory(Type controllerFactoryType); public void SetControllerFactory(IControllerFactory controllerFactory); IControllerFactory GetControllerFactory(); public HashSet&lt;string&gt; DefaultNamespaces &#123; get; &#125; public static ControllerBuilder Current &#123; get; &#125;&#125; GetControllerFactory透過private IResolver&lt;IControllerFactory&gt;取得要執行的ControllerFactory. 一般來說沒有設置就是使用DefaultControllerFactory工廠來取得Controller物件 123456789101112public IControllerFactory GetControllerFactory()&#123; return _serviceResolver.Current;&#125;internal ControllerBuilder(IResolver&lt;IControllerFactory&gt; serviceResolver)&#123;_serviceResolver = serviceResolver ?? new SingleServiceResolver&lt;IControllerFactory&gt;( () =&gt; _factoryThunk(), new DefaultControllerFactory &#123; ControllerBuilder = this &#125;, "ControllerBuilder.GetControllerFactory");&#125; IControllerFactory介面IControllerFactory介面有三個方法. CreateController取得Controller物件(工廠模式最重要方法) GetControllerSessionBehavior取得Session Default：使用預設ASP.NET Session狀態行為。 Required：使用完全的讀和寫Session狀態行為。 ReadOnly：使用只讀Session狀態。 Disabled：不使用Session狀態。 ReleaseController釋放使用資源 123456public interface IControllerFactory&#123; IController CreateController(RequestContext requestContext, string controllerName); SessionStateBehavior GetControllerSessionBehavior(RequestContext requestContext, string controllerName); void ReleaseController(IController controller);&#125; ControllerFactory(DefaultControllerFactory.cs)既然知道透過哪個工廠來產生Controller我們繼續追工廠是如何產生Controller物件 GetControllerType取得要執行Controller類型 GetControllerInstance取得Controller物件並返回使用 12345678910111213141516public virtual IController CreateController(RequestContext requestContext, string controllerName)&#123; if (requestContext == null) &#123; throw new ArgumentNullException("requestContext"); &#125; if (String.IsNullOrEmpty(controllerName) &amp;&amp; !requestContext.RouteData.HasDirectRouteMatch()) &#123; throw new ArgumentException(MvcResources.Common_NullOrEmpty, "controllerName"); &#125; Type controllerType = GetControllerType(requestContext, controllerName); IController controller = GetControllerInstance(requestContext, controllerType); return controller;&#125; GetControllerInstance通過反射（系統不會對建立的Controller進行快取 使用IControllerActivator(預設DefaultControllerActivator) 來建立Controller物件 12345678910111213141516171819202122protected internal virtual IController GetControllerInstance(RequestContext requestContext, Type controllerType)&#123; if (controllerType == null) &#123; throw new HttpException(404, String.Format( CultureInfo.CurrentCulture, MvcResources.DefaultControllerFactory_NoControllerFound, requestContext.HttpContext.Request.Path)); &#125; if (!typeof(IController).IsAssignableFrom(controllerType)) &#123; throw new ArgumentException( String.Format( CultureInfo.CurrentCulture, MvcResources.DefaultControllerFactory_TypeDoesNotSubclassControllerBase, controllerType), "controllerType"); &#125; //使用IControllerActivator(預設DefaultControllerActivator) 來建立Controller物件 return ControllerActivator.Create(requestContext, controllerType);&#125; 建立Controller的IControllerActivator上面說GetControllerInstance會透過一個ControllerActivator,而ControllerActivator預設其實是DefaultControllerActivator類別幫助我們建立Controller物件透過Create方法. 以下是DefaultControllerActivator程式碼 1234567891011121314151617181920212223242526272829303132333435363738private class DefaultControllerActivator : IControllerActivator&#123; private Func&lt;IDependencyResolver&gt; _resolverThunk; public DefaultControllerActivator() : this(null) &#123; &#125; public DefaultControllerActivator(IDependencyResolver resolver) &#123; if (resolver == null) &#123; _resolverThunk = () =&gt; DependencyResolver.Current; &#125; else &#123; _resolverThunk = () =&gt; resolver; &#125; &#125; public IController Create(RequestContext requestContext, Type controllerType) &#123; try &#123; return (IController)(_resolverThunk().GetService(controllerType) ?? Activator.CreateInstance(controllerType)); &#125; catch (Exception ex) &#123; throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture, MvcResources.DefaultControllerFactory_ErrorCreatingController, controllerType), ex); &#125; &#125;&#125; 能看到這邊依賴一個IDependencyResolver,這裡先埋個小伏筆後面幾篇會為各位解答. DefaultControllerActivator透過Activator.CreateInstance產生Controller物件,使用無建構子參數的Create方式 小結:今天我們學到如何取得Controller執行物件 透過一個IControllerFactory工廠物件取得Controller執行物件,對於外部提供可替換點. 利用RouteData.GetRequiredString取得執行的Controller名稱 DefaultControllerFactory透過反射方式動態建立物件. 工廠模式主要核心把如何使用物件跟如何建立物件中間解耦合，使用方不關心如何產生物件，只專注於此物件可執行的能力（介面） 下圖是本次介紹類別UML關係圖 MvcHandler是MVC的核心類別,借由ControllerBuilder創件者來取得產生Controller的工廠(預設使用DefaultControllerFactory)，並呼叫CreateController方法來產生一個Controller 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day11/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[透過MvcRouteHandler取得呼叫IHttphandler (第10天)]]></title>
    <url>%2FIthelp-day10%2F</url>
    <content type="text"><![CDATA[Agenda 前言 MVC取得使用HttpHandler (IHttpHandler) MVC呼叫的HttpHandler (MvcHandler) 小結 前言前一篇介紹路由封裝了Http請求路徑資訊可以讓我們找到相對應的Action和Controller並呼叫執行外，也可透過MapPageRoute來將請求教給.aspx實體檔案來處理請求. Route甚至可以讓我們自己客製化處理HttpHandler 在Route中建立處理客製化HttpHandler可謂很有彈性 本篇介紹Route物件建立MvcRouteHandler物件且如何取到IHttpHandler. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. MVC取得使用HttpHandler (IHttpHandler)之前說到我們透過MapRoute擴展方法加入一個Route物件給RouteCollection全域路由集合. 在Route使用的IRouteHandler介面是由MvcRouteHandler來實現 123456Route route = new Route(url, new MvcRouteHandler())&#123; Defaults = CreateRouteValueDictionaryUncached(defaults), Constraints = CreateRouteValueDictionaryUncached(constraints), DataTokens = new RouteValueDictionary()&#125;; IRouteHandler最重要的是IHttpHandler IRouteHandler.GetHttpHandler(RequestContext requestContext)會取得一個IHttpHandler物件. 1234567891011121314151617181920212223242526272829303132333435363738394041public class MvcRouteHandler : IRouteHandler&#123; private IControllerFactory _controllerFactory; public MvcRouteHandler() &#123; &#125; public MvcRouteHandler(IControllerFactory controllerFactory) &#123; _controllerFactory = controllerFactory; &#125; protected virtual IHttpHandler GetHttpHandler(RequestContext requestContext) &#123; //設置Session使用 requestContext.HttpContext.SetSessionStateBehavior(GetSessionStateBehavior(requestContext)); return new MvcHandler(requestContext); &#125; protected virtual SessionStateBehavior GetSessionStateBehavior(RequestContext requestContext) &#123; string controllerName = (string)requestContext.RouteData.Values["controller"]; if (String.IsNullOrWhiteSpace(controllerName)) &#123; throw new InvalidOperationException(MvcResources.MvcRouteHandler_RouteValuesHasNoController); &#125; IControllerFactory controllerFactory = _controllerFactory ?? ControllerBuilder.Current.GetControllerFactory(); return controllerFactory.GetControllerSessionBehavior(requestContext, controllerName); &#125; #region IRouteHandler Members IHttpHandler IRouteHandler.GetHttpHandler(RequestContext requestContext) &#123; return GetHttpHandler(requestContext); &#125; #endregion&#125; 上面程式碼可以看到Mvc使用IHttpHandler是MvcHandler MVC呼叫的HttpHandler (MvcHandler)MvcHandler類別中主要核心的程式碼做了幾件事情. 使用一個Adapter對於HttpContext物件把他轉成可以繼承於HttpContextBase的HttpContextWrapper類別. 透過ProcessRequestInit取得執行controller物件並且呼叫執行方法. 最後透過ReleaseController釋放之前使用過資源 12345678910111213141516171819202122protected virtual void ProcessRequest(HttpContext httpContext)&#123; HttpContextBase httpContextBase = new HttpContextWrapper(httpContext); ProcessRequest(httpContextBase);&#125;protected internal virtual void ProcessRequest(HttpContextBase httpContext)&#123; IController controller; IControllerFactory factory; //取得 控制器工廠(預設DefaultControllerFactory) 和 要執行的Controller ProcessRequestInit(httpContext, out controller, out factory); try &#123; controller.Execute(RequestContext); &#125; finally &#123; factory.ReleaseController(controller); &#125;&#125; 小結今天我們知道MVC使用HttpHandler是MvcHandler透過並MvcRouteHandler物件來返回. 下圖簡單展現MVC使用的HttpModule和HttpHandler關係 在UrlRoutingMoudule註冊事件. 取得符合Http請求Route物件 呼叫MvcRouteHandler取得MvcHandler物件 執行MvcHandler的ProcessReqeust方法 下面會陸續介紹MVC是如何取得Controller物件 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day10/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[進入MVC原始碼世界 Route & RouteTable 原始碼解析 (第9天)]]></title>
    <url>%2FIthelp-day9%2F</url>
    <content type="text"><![CDATA[Agenda 前言 介紹Route RouteTable.Routes MapRoute擴展方法 Route物件 MapPageRoute 擴展方法 在 Route中建立處理客製化HttpHandler 小結： 前言現在開始進入Asp.net MVC原始碼世界，我們從路由開始切入一步一步進入MVC核心. 我有做一個可以針對於Asp.net MVC Debugger的專案，只要下中斷點就可輕易進入Asp.net MVC原始碼. 如下面動畫 介紹Route每個HTTP請求MVC使用路由的目標是Controller和Action，不像ASP.NET Web Form處理物理文件(.aspx文件)，要執行Controller和Action名稱包含在HTTP請求中，ASP.NET MVC需要通過解析HTTP請求得到正確的Controller和Action的名稱。 使用Route比處理物理文件有以下幾個優勢： 靈活性：請求URL是對物理文件路徑，意味著如果物理文件的路徑發生了改變（比如改變了文件的目錄結構或者文件名），原來該文件連結將變得無效。 可讀性：在很多情況下，URL不僅僅需要能夠訪問正確的網絡資源，也需要具有很好的可讀性，最好的URL應該讓我們一眼就能看出針對它訪問的目標資源是什麼。請求地址與物理文件緊密綁定讓我們完全失去了定義高可讀性URL的機會。 SEO優化：對於網站開發來說，為了迎合搜索引擎檢索的規則，我們需要對URL進行有效的設計使之能易於被主流的引擎檢索收錄。如果URL完全與物理地址關聯，這失去了SEO優化的能力。 安全性：如接指向文件相對路徑無疑跟大家說你伺服器資料夾的結構，如果被有心人士（黑客）知道就可旁敲側擊攻擊您的伺服器． RouteTable.Routes在Global.cs檔案中，有一個RouteTable.Routes是RouteCollection類型的集合物件 我們通過RouteTable靜態屬性Routes得到一個全域的路由表，路由註冊的核心價值在此集合上添加路由設定。 1RouteConfig.RegisterRoutes(RouteTable.Routes); RouteCollection他是繼承Collection&lt;RouteBase&gt;的集合物件，可以對此集合添加一個繼承RouteBase物件. 在Mvc一般是透過MapRoute擴展方法來添加路由 123456789public static void RegisterRoutes(RouteCollection routes)&#123; routes.IgnoreRoute("&#123;resource&#125;.axd/&#123;*pathInfo&#125;"); routes.MapRoute( name: "Default", url: "&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;", defaults: new &#123; controller = "Home", action = "Index", id = UrlParameter.Optional &#125; );&#125; MapRoute擴展方法看一下MapRoute原始碼，這個方式是基於RouteCollection集合物件做的擴展方法，可看到最重要的部分是新增一個Route物件並加入集合中. 123456789101112131415161718192021public static Route MapRoute(this RouteCollection routes, string name, string url, object defaults, object constraints, string[] namespaces)&#123; // 判斷... Route route = new Route(url, new MvcRouteHandler()) &#123; Defaults = CreateRouteValueDictionaryUncached(defaults), Constraints = CreateRouteValueDictionaryUncached(constraints), DataTokens = new RouteValueDictionary() &#125;; ConstraintValidation.Validate(route); if ((namespaces != null) &amp;&amp; (namespaces.Length &gt; 0)) &#123; route.DataTokens[RouteDataTokenKeys.Namespaces] = namespaces; &#125; //加入註冊路由器 routes.Add(name, route); return route;&#125; Route物件Route類別是繼承於RouteBase(這也就是為什麼可以把Route物件加入RouteCollection集合中) 下面我刪減一些此次不會介紹到的程式碼. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Route : RouteBase &#123; private const string HttpMethodParameterName = "httpMethod"; private string _url; private ParsedRoute _parsedRoute; /// &lt;summary&gt; /// 使用指定的 URL 模式、預設參數值、條件約束、自訂值和處理常式類別，初始化 &lt;see cref="T:System.Web.Routing.Route" /&gt; 類別的新執行個體。 /// &lt;/summary&gt; /// &lt;param name="url"&gt;路由的 URL 模式。&lt;/param&gt; /// &lt;param name="defaults"&gt;URL 未包含所有參數時所要使用的值。&lt;/param&gt; /// &lt;param name="constraints"&gt;指定 URL 參數之有效值的規則運算式。&lt;/param&gt; /// &lt;param name="dataTokens"&gt; /// 傳遞給路由處理常式的自訂值，但不會用來判斷路由是否符合特定 URL 模式。 /// 這些值會傳遞至路由處理常式，以用來處理要求。 /// &lt;/param&gt; /// &lt;param name="routeHandler"&gt;處理路由要求的物件。&lt;/param&gt; public Route( string url, RouteValueDictionary defaults, RouteValueDictionary constraints, RouteValueDictionary dataTokens, IRouteHandler routeHandler) &#123; this.Url = url; this.Defaults = defaults; this.Constraints = constraints; this.DataTokens = dataTokens; this.RouteHandler = routeHandler; &#125; /// &lt;summary&gt;取得或設定運算式的字典，這些運算式指定 URL 參數的有效值。&lt;/summary&gt; public RouteValueDictionary Constraints &#123; get; set; &#125; /// &lt;summary&gt;取得或設定自訂值，這些自訂值會傳遞給路由處理常式，但不會用來判斷路由是否符合 URL 模式。&lt;/summary&gt; public RouteValueDictionary DataTokens &#123; get; set; &#125; /// &lt;summary&gt;取得或設定 URL 未包含所有參數時所要使用的值。&lt;/summary&gt; public RouteValueDictionary Defaults &#123; get; set; &#125; /// &lt;summary&gt;取得或設定處理路由要求的物件。&lt;/summary&gt; public IRouteHandler RouteHandler &#123; get; set; &#125; /// &lt;summary&gt;取得或設定路由的 URL 模式。&lt;/summary&gt; public string Url &#123; get &#123; return this._url ?? string.Empty; &#125; set &#123; this._parsedRoute = RouteParser.Parse(value); this._url = value; &#125; &#125; /// &lt;summary&gt;傳回所要求路由的相關資訊。&lt;/summary&gt; /// &lt;param name="httpContext"&gt;封裝 HTTP 要求相關資訊的物件。&lt;/param&gt; /// &lt;returns&gt;包含路由定義值的物件。&lt;/returns&gt; public override RouteData GetRouteData(HttpContextBase httpContext) &#123; RouteValueDictionary values = this._parsedRoute.Match(httpContext.Request.AppRelativeCurrentExecutionFilePath.Substring(2) + httpContext.Request.PathInfo, this.Defaults); if (values == null) return (RouteData) null; RouteData routeData = new RouteData((RouteBase) this, this.RouteHandler); if (!this.ProcessConstraints(httpContext, values, RouteDirection.IncomingRequest)) return (RouteData) null; foreach (KeyValuePair&lt;string, object&gt; keyValuePair in values) routeData.Values.Add(keyValuePair.Key, keyValuePair.Value); if (this.DataTokens != null) &#123; foreach (KeyValuePair&lt;string, object&gt; dataToken in this.DataTokens) routeData.DataTokens[dataToken.Key] = dataToken.Value; &#125; return routeData; &#125; &#125; 在Route類別中GetRouteData是個重要方法，藉由我們的路由設定去解析當前是否匹配到路由規則，如果有就回傳一個RouteData物件，否則回傳Null 上一篇有介紹UrlRoutingModule這個HttpModule會藉由RouteCollection.GetRouteData(context)動作取得一個RouteData並透過他拿到IHttpHander物件並給值到HttpContext.Handler 在裡面的實做是透過一個foreach去找尋匹配的Route物件，因為ADD路由是有順序性,所以在RegisterRoutes(RouteCollection routes)找尋路由會有第一個MapRoute到最後一個 Url這個屬性的set方法上做一個很有意思的動作，在設定值時除了賦值給_url字段,另外還將 設定template url Parse 取得一個ParsedRoute _parsedRoute物件. ParsedRoute將我們注冊的template url用/分割存起來方便日後判斷執行的Action和Contoller. MapPageRoute 擴展方法路由除了使用於取得調用Contoller和Action資訊外，我們還可以通過MapPageRoute註冊URL樣板和某種文件的配對關係. 範例在:Asp.net MVC Debugger 本次使用幾個參數 路由名稱 樣版URL 指向實體aspx檔案路徑 此路由是否找尋實體路徑 樣版URL預設參數 12345678routes.MapPageRoute( "PhysicalFile", "GetFile/&#123;Name&#125;", "~/PhysicalFile.aspx", true, new RouteValueDictionary() &#123; &#123; "Name","PhysicalFile"&#125; &#125;); 下圖是我們專案建立一個新的.aspx檔案 裡面內容很簡單只是印出一段文字 1Hello PhysicalFile.aspx 因為有加入MapPageRoute路由,在瀏覽器網址列輸入http:localhost:[your port]/GetFile，我們就可以將PhysicalFile.aspx檔案內容顯示出來. 在 Route中建立處理客製化HttpHandler在Route建構子中我們可以設定實現IRouteHandler物件,這個物件會有個方法可以返回IHttpHandler給asp.net請求使用. 12345678910111213141516171819202122232425public class MyHandler : IHttpHandler&#123; public bool IsReusable &#123; get &#123; return true; &#125; &#125; public void ProcessRequest(HttpContext context) &#123; context.Response.Write("Hello MyHandler!!"); &#125;&#125;public class MyHandlerRouter : IRouteHandler&#123; public IHttpHandler GetHttpHandler(RequestContext requestContext) &#123; return new MyHandler(); &#125;&#125; 我們可以建立MyHandlerRouter在GetHttpHandler返回一個MyHandler物件,之後把MyHandlerRouter當作參數傳入Route物件中 把Route加入全域路由集合中 1routes.Add(new Route("Customer",new MyHandlerRouter())); 在瀏覽器輸入 http://localhost:[your port]/Customer 我們就會執行我們自己客製化的HttpHandler 小結：路由封裝了Http請求路徑資訊可以讓我們找到相對應的Action和Controller並呼叫執行外，可以透過MapPageRoute來將請求教給.aspx實體檔案來處理請求. Route甚至可以讓我們自己客製化處理HttpHandler 如 在 Route中建立處理客製化HttpHandler可謂很有彈性 下篇介紹Route物件建立MvcRouteHandler物件如何取到IHttpHandler. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day9/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭密Mvc使用IHttpHandler by UrlRoutingModule-4.0 (第8天)]]></title>
    <url>%2FIthelp-day8%2F</url>
    <content type="text"><![CDATA[Agenda 前言： UrlRoutingModule-4.0 OnApplicationPostResolveRequestCache事件 PostResolveRequestCache方法 IRouteHandler取得執行HttpHandler RemapHandler設置HttpContext的HttpHandler 小結 前言：前面幾篇文章已經詳細分享解說Asp.net如何透過HttpApplication找到IHttpHandler並執行呼叫介面方法. 今天要跟大家分享上圖的最後一塊拼圖揭密並探索Asp.net MVC使用的IHttpHandler. UrlRoutingModule-4.0在標題已經透漏我們是透過UrlRoutingModule這個繼承IHttpModule的類別來取得IHttpHandler 有人可能會有疑問是我明明沒有註冊此HttpModule Asp.net怎麼知道的呢? 原因是這個Module是預設就載入 下圖是一般IIS預設載入的HttpModule可以看到UrlRoutingModule已經在裡面了. 另外我們也可以看applicationhost.config檔案,也可以看到UrlRoutingModule-4.0也已經在裡面了. 我們可以發現他是在System.Web.Routing這個命名空間下. 12345&lt;modules&gt; .... &lt;add name="ServiceModel-4.0" type="System.ServiceModel.Activation.ServiceHttpModule,System.ServiceModel.Activation,Version=4.0.0.0,Culture=neutral,PublicKeyToken=31bf3856ad364e35" preCondition="managedHandler,runtimeVersionv4.0" /&gt; &lt;add name="UrlRoutingModule-4.0" type="System.Web.Routing.UrlRoutingModule" preCondition="managedHandler,runtimeVersionv4.0" /&gt;&lt;/modules&gt; 此連結可以看到 UrlRoutingModule 原始碼 12345678910protected virtual void Init(HttpApplication application) &#123; // Check if this module has been already addded if (application.Context.Items[_contextKey] != null) &#123; return; // already added to the pipeline &#125; application.Context.Items[_contextKey] = _contextKey; application.PostResolveRequestCache += OnApplicationPostResolveRequestCache;&#125; 前面文章有說道Init方法會在HttpApplication呼叫InitInternal方法時被呼叫. 這這裡可看到application.PostResolveRequestCache多註冊一個OnApplicationPostResolveRequestCache事件. 讓我們來看看此事件做了什麼事情 OnApplicationPostResolveRequestCache事件OnApplicationPostResolveRequestCache方法中,利用 HttpContextWrapper轉接器模式把app.Context轉接成一個可接受HttpContextBase物件,並呼叫傳入PostResolveRequestCache方法中. 12345private void OnApplicationPostResolveRequestCache(object sender, EventArgs e) &#123; HttpApplication app = (HttpApplication)sender; HttpContextBase context = new HttpContextWrapper(app.Context); PostResolveRequestCache(context);&#125; PostResolveRequestCache方法123456789101112131415161718192021222324252627282930public virtual void PostResolveRequestCache(HttpContextBase context) &#123; // Match the incoming URL against the route table RouteData routeData = RouteCollection.GetRouteData(context); // Do nothing if no route found if (routeData == null) &#123; return; &#125; // If a route was found, get an IHttpHandler from the route's RouteHandler IRouteHandler routeHandler = routeData.RouteHandler; //... 判斷 error 程式碼 if (routeHandler is StopRoutingHandler) &#123; return; &#125; RequestContext requestContext = new RequestContext(context, routeData); // Dev10 766875 Adding RouteData to HttpContext context.Request.RequestContext = requestContext; IHttpHandler httpHandler = routeHandler.GetHttpHandler(requestContext); //... 判斷 error 程式碼 // Remap IIS7 to our handler context.RemapHandler(httpHandler);&#125; RouteCollection是一個全域路由集合,註冊使用路由(Asp.net Global.cs中我們很常看到使用). 對於此集合註冊路由,是MVC,WebApi能運行的關鍵喔 在MVC中我們透過MapRoute擴展方法來註冊路由,其實在這個擴展方法中會建立一個Route物件並加入RouteCollection集合中. Route物件會提供一個HttpHandler來給我們呼叫使用. 12345routes.MapRoute( name: "Default", url: "&#123;controller&#125;/&#123;action&#125;/&#123;id&#125;", defaults: new &#123; controller = "Home", action = "Index", id = UrlParameter.Optional &#125;); RouteCollection.GetRouteData(context)取得路由中匹配此次請求的路由資料，藉由此註冊進集合並繼承RouteBase抽象類別的物件 IRouteHandler取得執行HttpHandler在routeData會有一個重要的屬性RouteHandler是繼承於IRouteHandler 這個介面只有一個方法就是回傳IHttpHandler看到這基本上就可以知道MVC的IHttpHandler是呼叫RouteHandler.GetHttpHandler回傳的物件. 123public interface IRouteHandler &#123; IHttpHandler GetHttpHandler(RequestContext requestContext);&#125; 後面會對於此介面有更詳細介紹 RemapHandler設置HttpContext的HttpHandler在PostResolveRequestCache最後面幾段程式碼,是透過routeHandler.GetHttpHandler(requestContext)取得IHttpHandler，並將其設置給context 1234IHttpHandler httpHandler = routeHandler.GetHttpHandler(requestContext);// Remap IIS7 to our handlercontext.RemapHandler(httpHandler); 這邊說明一下RemapHandler作用,最主要是把傳入參數handler傳給_remapHandler欄位 1234567891011121314151617181920212223242526public void RemapHandler(IHttpHandler handler) &#123; EnsureHasNotTransitionedToWebSocket(); IIS7WorkerRequest wr = _wr as IIS7WorkerRequest; if (wr != null) &#123; // Remap handler not allowed after ResolveRequestCache notification if (_notificationContext.CurrentNotification &gt;= RequestNotification.MapRequestHandler) &#123; throw new InvalidOperationException(SR.GetString(SR.Invoke_before_pipeline_event, "HttpContext.RemapHandler", "HttpApplication.MapRequestHandler")); &#125; string handlerTypeName = null; string handlerName = null; if (handler != null) &#123; Type handlerType = handler.GetType(); handlerTypeName = handlerType.AssemblyQualifiedName; handlerName = handlerType.FullName; &#125; wr.SetRemapHandler(handlerTypeName, handlerName); &#125; _remapHandler = handler;&#125; _remapHandler就是RemapHandlerInstance屬性回傳的值 12345internal IHttpHandler RemapHandlerInstance &#123; get &#123; return _remapHandler; &#125;&#125; 我們之前有分享MapHandlerExecutionStep,MapHttpHandler會優先讀取存在context.RemapHandlerInstance中HttpHandler如果有物件就給CallHandlerExecutionStep呼叫使用. 這邊算是比較完整圓了上一篇埋的小伏筆. 小結今天談到我們了解到 MVC是透過UrlRoutingModule-4.0這個HttpModule取得HttpHandler MVC是在application.PostResolveRequestCache這個事件決定使用的HttpHandler 路由其實是Asp.net MVC呼叫的關鍵 因為在MapHandlerExecutionStep執行前已經決定context.RemapHandlerInstance所以就不會呼叫到config設定HttpHander物件 基本上Asp.net部分已經介紹完了,接下來會進入Asp.net MVC的世界. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day8/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net重要物件HttpApplication(三) 取得執行的IHttpHandler (第7天)]]></title>
    <url>%2FIthelp-day7%2F</url>
    <content type="text"><![CDATA[Agenda 前言 呼叫HttpAppliaction取得HttpHandler並呼叫 MapHandlerExecutionStep程式碼解說 CallHandlerExecutionStep程式碼解說 小結： 前言前面和大家分享StepManager是如何建立管道和依序呼叫IHttpModule註冊事件 查看原始碼好站 Reference Source 此文的程式碼比較多我會在原始碼上邊上說明相對應編號方便大家觀看 今天跟大家分享HttpAppliaction是如何找到要執行的IHttpHandler物件. 呼叫HttpAppliaction取得HttpHandler並呼叫在ApplicationStepManager的IExecutionStep中重要的實現類別有兩個 MapHandlerExecutionStep:找到執行IHttpHander CallHandlerExecutionStep MapHandlerExecutionStep程式碼解說前面說過IExecutionStep最核心就是要找到一個Execute方法 MapHandlerExecutionStep的Execute方法是為了找到一個要執行的HttpHander 每次請求都會呼叫HttpContext.Handler屬性. MapHttpHandler會依照下面權重來取得HttpHander物件. context.RemapHandlerInstance如果有物件就優先返回(很重要因為這就是Asp.net MVC使用的HttpHander物件) 透過IHttpHandlerFactory工廠來取得物件,依照我們在Config註冊的HttpHander對應資料 副檔名*.ashx泛型處理常式透過SimpleHandlerFactory 副檔名*.aspx泛型處理常式透過PageHandlerFactory 想知道更多可以查看applicationhost.config註冊表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859internal class MapHandlerExecutionStep : IExecutionStep &#123; void IExecutionStep.Execute() &#123; HttpContext context = _application.Context; HttpRequest request = context.Request; context.Handler = _application.MapHttpHandler( context, request.RequestType, request.FilePathObject, request.PhysicalPathInternal, false /*useAppConfig*/); &#125;&#125;internal IHttpHandler MapHttpHandler(HttpContext context, String requestType, VirtualPath path, String pathTranslated, bool useAppConfig) &#123; IHttpHandler handler = (context.ServerExecuteDepth == 0) ? context.RemapHandlerInstance : null; using (new ApplicationImpersonationContext()) &#123; // Use remap handler if possible if (handler != null)&#123; return handler; &#125; // Map new handler HttpHandlerAction mapping = GetHandlerMapping(context, requestType, path, useAppConfig); if (mapping == null) &#123; PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_NOT_FOUND); PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_FAILED); throw new HttpException(SR.GetString(SR.Http_handler_not_found_for_request_type, requestType)); &#125; // Get factory from the mapping IHttpHandlerFactory factory = GetFactory(mapping); // Get factory from the mapping try &#123; IHttpHandlerFactory2 factory2 = factory as IHttpHandlerFactory2; if (factory2 != null) &#123; handler = factory2.GetHandler(context, requestType, path, pathTranslated); &#125; else &#123; handler = factory.GetHandler(context, requestType, path.VirtualPathString, pathTranslated); &#125; &#125; catch (FileNotFoundException e) &#123; //...丟Exception &#125; // Remember for recycling if (_handlerRecycleList == null) _handlerRecycleList = new ArrayList(); _handlerRecycleList.Add(new HandlerWithFactory(handler, factory)); &#125; return handler;&#125; MapHandlerExecutionStep是為了找到我們要執行的HttpHandler物件. 123if (handler != null)&#123; return handler;&#125; 在一開始先判斷handler是否已經有值如果有就直接返回(這個很重要因為這是為什麼MVC,WebAPI可以運作且不用在Config設定配對IHttpHandlerFactory原因). 只需要在MapHandlerExecutionStep執行前將context.RemapHandlerInstance給一個HttpHandler物件即可. CallHandlerExecutionStep程式碼解說CallHandlerExecutionStep物件透過context.Handler可以找到要執行的HttpHandler,這邊也是優先判斷是否可執行異步請求. 異步呼叫beginProcessRequestDelegate方法(此方法將實現IHttpAsyncHandler物件封裝成一個Func&lt;T, AsyncCallback, object, IAsyncResult&gt;委派方法),之後再調用返回一個IAsyncResult物件(處理後結果最後呼叫EndProcessRequest方法). 同步呼叫ProcessRequest:判斷context.Handler不是IHttpAsyncHandler型別就值型同步動作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// execution step -- call HTTP handler (used to be a separate module)internal class CallHandlerExecutionStep : IExecutionStep &#123; private HttpApplication _application; private AsyncCallback _completionCallback; private IHttpAsyncHandler _handler; // per call private AsyncStepCompletionInfo _asyncStepCompletionInfo; // per call private bool _sync; // per call internal CallHandlerExecutionStep(HttpApplication app) &#123; _application = app; _completionCallback = new AsyncCallback(this.OnAsyncHandlerCompletion); &#125; //...其他方法 void IExecutionStep.Execute() &#123; HttpContext context = _application.Context; IHttpHandler handler = context.Handler; if (handler != null &amp;&amp; HttpRuntime.UseIntegratedPipeline) &#123; IIS7WorkerRequest wr = context.WorkerRequest as IIS7WorkerRequest; if (wr != null &amp;&amp; wr.IsHandlerExecutionDenied()) &#123; _sync = true; HttpException error = new HttpException(403, SR.GetString(SR.Handler_access_denied)); error.SetFormatter(new PageForbiddenErrorFormatter(context.Request.Path, SR.GetString(SR.Handler_access_denied))); throw error; &#125; &#125; if (handler == null) &#123; _sync = true; &#125; else if (handler is IHttpAsyncHandler) &#123; // asynchronous handler IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)handler; _sync = false; _handler = asyncHandler; var beginProcessRequestDelegate = AppVerifier.WrapBeginMethod&lt;HttpContext&gt;(_application, asyncHandler.BeginProcessRequest); _asyncStepCompletionInfo.Reset(); context.SyncContext.AllowVoidAsyncOperations(); IAsyncResult ar; try &#123; ar = beginProcessRequestDelegate(context, _completionCallback, null); &#125; catch &#123; // The asynchronous step has completed, so we should disallow further // async operations until the next step. context.SyncContext.ProhibitVoidAsyncOperations(); throw; &#125; bool operationCompleted; bool mustCallEndHandler; _asyncStepCompletionInfo.RegisterBeginUnwound(ar, out operationCompleted, out mustCallEndHandler); if (operationCompleted) &#123; _sync = true; _handler = null; // not to remember context.SyncContext.ProhibitVoidAsyncOperations(); try &#123; if (mustCallEndHandler) &#123; asyncHandler.EndProcessRequest(ar); &#125; _asyncStepCompletionInfo.ReportError(); &#125; finally &#123; SuppressPostEndRequestIfNecessary(context); context.Response.GenerateResponseHeadersForHandler(); &#125; &#125; &#125; else &#123; // synchronous handler _sync = true; context.SyncContext.SetSyncCaller(); try &#123; handler.ProcessRequest(context); &#125; finally &#123; context.SyncContext.ResetSyncCaller(); SuppressPostEndRequestIfNecessary(context); context.Response.GenerateResponseHeadersForHandler(); &#125; &#125; &#125;&#125; 小結：希望可以讓大家對於為什麼Asp.net為何可以針對IHttpModule擴充且為何最後都會請求一個IHttpHandler有更深入的了解. 微軟透過一系列的管道設計模式提供有高度擴展的系統對外提供一個IHttpHandler讓我們可以客製化擴充要執行的請求. 對於此次請求又有IHttpModule可對於HttpApplication事件做擴充(透過AOP編成方式). 今天之後我們會開始講解Asp.net MVC相關的原始程式碼. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day7/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net重要物件HttpApplication(二) 建置執行管道 (第6天)]]></title>
    <url>%2FIthelp-day6%2F</url>
    <content type="text"><![CDATA[Agenda 前言 ApplicationStepManager BuildSteps 建置Pipleline流程 CreateEventExecutionSteps 載入事件 HttpApplication事件集合 IExecutionStep介面 ResumeSteps方法呼叫IExecutionStep物件 HttpApplication的ExecuteStep 重要的兩個IExecutionStep 小結： 前言前面有提到InitInternal方法，是如何載入註冊HttpModule並呼叫Init方法，經典模式和管道模式比較. 查看原始碼好站 Reference Source此文的程式碼比較多我會在原始碼上邊上說明相對應編號方便大家觀看 今天跟大家介紹StepManager是如何建立管道和依序呼叫IHttpModule註冊事件 ApplicationStepManager這部分可說是Asp.net最核心部分，利用Event事件和AOP概念,讓Asp.net可以擁有高度的可擴展性. BuildSteps 建置Pipleline流程BuildSteps最主要透過CreateEventExecutionSteps方法，把所有Applicationevent註冊添加到steps集合中方便後面依照順序去呼叫使用. steps 最後把載入所有事件給 _execSteps 這裡就是我們熟知的管道事件介紹 Asp.Net支柱 IHttpMoudle &amp; IHttphandler 有介紹到 透過BuildSteps方法step by step把Asp.net執行事件依照順序註冊進去. 12345678910111213141516171819202122232425262728293031323334353637internal override void BuildSteps(WaitCallback stepCallback ) &#123; ArrayList steps = new ArrayList(); HttpApplication app = _application; steps.Add(new ValidateRequestExecutionStep(app)); steps.Add(new ValidatePathExecutionStep(app)); if (urlMappingsEnabled) steps.Add(new UrlMappingsExecutionStep(app)); app.CreateEventExecutionSteps(HttpApplication.EventBeginRequest, steps); app.CreateEventExecutionSteps(HttpApplication.EventAuthenticateRequest, steps); app.CreateEventExecutionSteps(HttpApplication.EventDefaultAuthentication, steps); app.CreateEventExecutionSteps(HttpApplication.EventPostAuthenticateRequest, steps); app.CreateEventExecutionSteps(HttpApplication.EventAuthorizeRequest, steps); app.CreateEventExecutionSteps(HttpApplication.EventPostAuthorizeRequest, steps); app.CreateEventExecutionSteps(HttpApplication.EventResolveRequestCache, steps); app.CreateEventExecutionSteps(HttpApplication.EventPostResolveRequestCache, steps); steps.Add(new MapHandlerExecutionStep(app)); // map handler app.CreateEventExecutionSteps(HttpApplication.EventPostMapRequestHandler, steps); app.CreateEventExecutionSteps(HttpApplication.EventAcquireRequestState, steps); app.CreateEventExecutionSteps(HttpApplication.EventPostAcquireRequestState, steps); app.CreateEventExecutionSteps(HttpApplication.EventPreRequestHandlerExecute, steps); steps.Add(app.CreateImplicitAsyncPreloadExecutionStep()); // implict async preload step steps.Add(new CallHandlerExecutionStep(app)); // execute handler app.CreateEventExecutionSteps(HttpApplication.EventPostRequestHandlerExecute, steps); app.CreateEventExecutionSteps(HttpApplication.EventReleaseRequestState, steps); app.CreateEventExecutionSteps(HttpApplication.EventPostReleaseRequestState, steps); steps.Add(new CallFilterExecutionStep(app)); // filtering app.CreateEventExecutionSteps(HttpApplication.EventUpdateRequestCache, steps); app.CreateEventExecutionSteps(HttpApplication.EventPostUpdateRequestCache, steps); _endRequestStepIndex = steps.Count; app.CreateEventExecutionSteps(HttpApplication.EventEndRequest, steps); steps.Add(new NoopExecutionStep()); // the last is always there _execSteps = new IExecutionStep[steps.Count]; steps.CopyTo(_execSteps);&#125; 如果在Web.Config設定urlMappingsEnabled就會實施UrlMappingsModule.UrlMappingRewritePath(UrlRerwite)MapHandlerExecutionStep：找尋匹配HttpHandler物件 CreateEventExecutionSteps 載入事件下面程式碼可以看到CreateEventExecutionSteps方法透過eventIndex去事件集合查找註冊事件,並把事件寫入ArrayList steps集合中. 12345678910111213141516171819private void CreateEventExecutionSteps(Object eventIndex, ArrayList steps) &#123; // async AsyncAppEventHandler asyncHandler = AsyncEvents[eventIndex]; if (asyncHandler != null) &#123; asyncHandler.CreateExecutionSteps(this, steps); &#125; // sync EventHandler handler = (EventHandler)Events[eventIndex]; if (handler != null) &#123; Delegate[] handlers = handler.GetInvocationList(); for (int i = 0; i &lt; handlers.Length; i++) &#123; steps.Add(new SyncEventExecutionStep(this, (EventHandler)handlers[i])); &#125; &#125;&#125; 為了建立管道最後可看到steps.CopyTo(_execSteps);把建立的管道Step複製到_execSteps集合中 12345678private IExecutionStep[] _execSteps;internal override void BuildSteps(WaitCallback stepCallback ) &#123; ArrayList steps = new ArrayList(); //.....其他程式碼 _execSteps = new IExecutionStep[steps.Count]; steps.CopyTo(_execSteps);&#125; steps最後把所有註冊事件Copy到ApplicationStepManager的private IExecutionStep[] _execSteps集合中提供ResumeSteps方法呼叫使用. HttpApplication事件集合這兩個欄位集合乘載我們註冊的Asp.net事件 EventHandlerList 同步使用事件. AsyncAppEventHandlersTable 非同步使用事件. 12345678910111213141516171819private EventHandlerList _events;protected EventHandlerList Events &#123; get &#123; if (_events == null) &#123; _events = new EventHandlerList(); &#125; return _events; &#125;&#125;private AsyncAppEventHandlersTable _asyncEvents;private AsyncAppEventHandlersTable AsyncEvents &#123; get &#123; if (_asyncEvents == null) _asyncEvents = new AsyncAppEventHandlersTable(); return _asyncEvents; &#125;&#125; 用其中一個事件舉例 PostMapRequestHandler提供擴充的事件註冊點，透過AddSyncEventHookup把事件加入集合中. object key:此事件識別資訊(每個事件都有自己的Object),如PostMapRequestHandler事件傳入EventPostMapRequestHandler物件. Delegate handler:使用者撰寫事件方法. RequestNotification notification:屬於哪種分群. 1234public event EventHandler PostMapRequestHandler &#123; add &#123; AddSyncEventHookup(EventPostMapRequestHandler, value, RequestNotification.MapRequestHandler, true); &#125; remove &#123; RemoveSyncEventHookup(EventPostMapRequestHandler, value, RequestNotification.MapRequestHandler); &#125;&#125; 其他10幾個事件使用方式大同小異,這裡就不一一介紹了 IExecutionStep介面IExecutionStep這個介面，裡面最重要的方法是void Execute();來執行注冊的事件方法. 123456// interface to represent one execution stepinternal interface IExecutionStep &#123; void Execute(); bool CompletedSynchronously &#123; get;&#125; bool IsCancellable &#123; get; &#125;&#125; 在BuildSteps方法中可以看到，全部事件轉成IExecutionStep介面放入_execSteps待被執行IExecutionStep集合列表. _execSteps是一個物件區域變數，提供internal override void ResumeSteps(Exception error)呼叫使用. ResumeSteps方法呼叫IExecutionStep物件ResumeSteps這個方法做了許多事情,我下面只保留ResumeSteps方法如何去呼叫IExecutionStep物件的Execute方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115private int _currentStepIndex; [System.Diagnostics.DebuggerStepperBoundaryAttribute]internal override void ResumeSteps(Exception error) &#123; bool appCompleted = false; bool stepCompletedSynchronously = true; HttpApplication app = _application; CountdownTask appInstanceConsumersCounter = app.ApplicationInstanceConsumersCounter; HttpContext context = app.Context; ThreadContext threadContext = null; AspNetSynchronizationContextBase syncContext = context.SyncContext; try &#123; using (syncContext.AcquireThreadLock()) &#123; try &#123; threadContext = app.OnThreadEnter(); &#125; catch (Exception e) &#123; if (error == null) error = e; &#125; try &#123; try &#123; for (; ; ) &#123; // record error if (syncContext.Error != null) &#123; error = syncContext.Error; syncContext.ClearError(); &#125; if (error != null) &#123; app.RecordError(error); error = null; &#125; // check for any outstanding async operations if (syncContext.PendingCompletion(_resumeStepsWaitCallback)) &#123; // wait until all pending async operations complete break; &#125; // advance to next step if (_currentStepIndex &lt; _endRequestStepIndex &amp;&amp; (context.Error != null || _requestCompleted)) &#123; // end request context.Response.FilterOutput(); _currentStepIndex = _endRequestStepIndex; &#125; else &#123; _currentStepIndex++; &#125; if (_currentStepIndex &gt;= _execSteps.Length) &#123; appCompleted = true; break; &#125; // execute the current step _numStepCalls++; // count all calls // enable launching async operations before each new step syncContext.Enable(); // call to execute current step catching thread abort exception error = app.ExecuteStep(_execSteps[_currentStepIndex], ref stepCompletedSynchronously); // unwind the stack in the async case if (!stepCompletedSynchronously) break; _numSyncStepCalls++; // count synchronous calls &#125; &#125; finally &#123; if (appCompleted) &#123; // need to raise OnRequestCompleted while within the ThreadContext so that things like User, CurrentCulture, etc. are available context.RaiseOnRequestCompleted(); &#125; if (threadContext != null) &#123; try &#123; threadContext.DisassociateFromCurrentThread(); &#125; catch &#123; &#125; &#125; &#125; &#125; catch &#123; // Protect against exception filters throw; &#125; &#125; // using if (appCompleted) &#123; context.RaiseOnPipelineCompleted(); context.Unroot(); app.AsyncResult.Complete((_numStepCalls == _numSyncStepCalls), null, null); app.ReleaseAppInstance(); &#125; &#125; finally &#123; if (appInstanceConsumersCounter != null) &#123; appInstanceConsumersCounter.MarkOperationCompleted(); // ResumeSteps call complete &#125; &#125;&#125; 上面程式碼最核心的片段在 1234567891011121314151617181920if (_currentStepIndex &lt; _endRequestStepIndex &amp;&amp; (context.Error != null || _requestCompleted)) &#123; context.Response.FilterOutput(); _currentStepIndex = _endRequestStepIndex;&#125;else &#123; _currentStepIndex++;&#125;if (_currentStepIndex &gt;= _execSteps.Length) &#123; appCompleted = true; break;&#125;// execute the current step_numStepCalls++; // enable launching async operations before each new stepsyncContext.Enable();// call to execute current step catching thread abort exceptionerror = app.ExecuteStep(_execSteps[_currentStepIndex], ref stepCompletedSynchronously); _currentStepIndex這個欄位表示取得當前需要跑事件Index(從之前IExecutionStep[]集合取得),每次執完都會_currentStepIndex++ 有一個無限迴圈for (; ; )一直在跑除非兩種情況才會終止迴圈. _currentStepIndex &gt;= _execSteps.Length代表全部事件都跑完了. 判斷context.Error != null執行得過程是否有出錯,如果有就終止繼續執行. 透過HttpApplication.ExecuteStep方法執行前面註冊的事件 bool appCompleted來判斷目前是否執行完全部事件. 只要還有事件就呼叫ExecuteStep,把當前事件傳入(_execSteps[_currentStepIndex]) HttpApplication的ExecuteStep這邊蠻有趣一件事情是ExecuteStep方法回傳一個Exception物件當作這次執行成功或失敗,而ExecuteStep執行過程是主要是呼叫ExecuteStepImpl方法來呼叫step.Execute(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677internal Exception ExecuteStep(IExecutionStep step, ref bool completedSynchronously) &#123; Exception error = null; try &#123; try &#123; if (step.IsCancellable) &#123; _context.BeginCancellablePeriod(); // request can be cancelled from this point try &#123; ExecuteStepImpl(step); &#125; finally &#123; _context.EndCancellablePeriod(); // request can be cancelled until this point &#125; _context.WaitForExceptionIfCancelled(); // wait outside of finally &#125; else &#123; ExecuteStepImpl(step); &#125; if (!step.CompletedSynchronously) &#123; completedSynchronously = false; return null; &#125; &#125; catch (Exception e) &#123; error = e; if (e is ThreadAbortException &amp;&amp; ((Thread.CurrentThread.ThreadState &amp; ThreadState.AbortRequested) == 0)) &#123; error = null; _stepManager.CompleteRequest(); &#125; &#125; &#125; catch (ThreadAbortException e) &#123; if (e.ExceptionState != null &amp;&amp; e.ExceptionState is CancelModuleException) &#123; CancelModuleException cancelException = (CancelModuleException)e.ExceptionState; if (cancelException.Timeout) &#123; // Timed out error = new HttpException(SR.GetString(SR.Request_timed_out), null, WebEventCodes.RuntimeErrorRequestAbort); PerfCounters.IncrementCounter(AppPerfCounter.REQUESTS_TIMED_OUT); &#125; else &#123; // Response.End error = null; _stepManager.CompleteRequest(); &#125; Thread.ResetAbort(); &#125; &#125; completedSynchronously = true; return error;&#125;private void ExecuteStepImpl(IExecutionStep step) &#123; if(_stepInvoker != null) &#123; bool stepCalled = false; _stepInvoker.Invoke(() =&gt; &#123; if (!stepCalled) &#123; stepCalled = true; step.Execute(); &#125; &#125;); if (!stepCalled) &#123; step.Execute(); &#125; &#125; else &#123; step.Execute(); &#125;&#125; 重要的兩個IExecutionStep MapHandlerExecutionStep:透過HttpApplication.MapHttpHandler方法取得使用HttpHandler(透過IHttpHandlerFactory和XML註冊表來完成) CallHandlerExecutionStep:取得使用HttpHandler依照非同步或同步HttpHandler執行相對應呼叫(先判斷是否非同步) 小結：今天我們了解到 Appliaction管道是如何被建立(透過BuildSteps方法)依照Asp.net順序註冊事件 所有事件被封裝到繼承IExecutionStep物件中 透過呼叫ResumeSteps方法來依序執行註冊事件. 下篇會跟大家詳細分享重要的兩個IExecutionStep物件 MapHandlerExecutionStep CallHandlerExecutionStep 微軟管道設計(透過事件)讓程式開發人員提供高擴展設計方式(AOP編成),值得讓我們思考且學習. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day6/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net重要物件HttpApplication(一) 初始化建立IHttpMoudule (第5天)]]></title>
    <url>%2FIthelp-day5%2F</url>
    <content type="text"><![CDATA[Agenda 前言： 初始化HttpApplication (InitInternal) 載入所有註冊HttpModule(InitModules方法) HttpModule添加Asp.net事件原理解析. 管道模式 vs 經典模式 取得執行HttpHandler物件 小結 前言：附上Asp.net執行請求流程圖. 上一篇文章分享HttpApplicationFactory.GetApplicationInstance方法返回一個HttpApplication給HttpRuntime來呼叫使用. 今天開始介紹HttpApplication這個很重要的類別,它可謂是我們Asp.net中很複雜但重要的類別 Global.cs是繼承HttpApplication類別,但為什麼需要繼承這個類別呢? 讓我們繼續看下去. 查看原始碼好站 Reference Source此文的程式碼比較多我會在原始碼上邊上說明相對應編號方便大家觀看 初始化HttpApplication (InitInternal)在GetNormalApplicationInstance返回一個HttpApplication物件前會呼叫初始化HttpApplication.InitInternal方法 這個方法主要做下面幾件事情 初始化HttpModule，讀取Host config或appconfig 註冊的HttpMoudle,並調用Init方法，使用AOP編成方式註冊使用事件 提供一個Hock給繼承Application物件來初始化設定使用 判斷要走管道模式還是經典模式 建置Pipleline流程 建立許多實現IExecutionStep接口的物件並添加到目前HttpApplication物驗的_execSteps集合中.從這裡我們可以看到HttpApplication是以異步的方式處理請求 HttpModule是在InitInternal方法中被讀取執行. 我們可以透過 HttpContext.ApplicationInstance.Modules ，得知目前所有載入HttpModule. 下面是InitInternal原始碼(核心動作有寫中文註解) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384internal void InitInternal(HttpContext context, HttpApplicationState state, MethodInfo[] handlers)&#123; // Remember state _state = state; PerfCounters.IncrementCounter(AppPerfCounter.PIPELINES); try &#123; try &#123; _initContext = context; _initContext.ApplicationInstance = this; context.ConfigurationPath = context.Request.ApplicationPathObject; using (new DisposableHttpContextWrapper(context)) &#123; // 1.初始化HttpModule. if (HttpRuntime.UseIntegratedPipeline) &#123; try &#123; context.HideRequestResponse = true; _hideRequestResponse = true; InitIntegratedModules(); &#125; finally &#123; context.HideRequestResponse = false; _hideRequestResponse = false; &#125; &#125; else &#123; InitModules(); &#125; // Hookup event handlers via reflection if (handlers != null) HookupEventHandlersForApplicationAndModules(handlers); // Initialization of the derived class _context = context; if (HttpRuntime.UseIntegratedPipeline &amp;&amp; _context != null) &#123; _context.HideRequestResponse = true; &#125; _hideRequestResponse = true; try &#123; //2.提供一個Hock給繼承Application物件來初始化設定使用 Init(); &#125; catch (Exception e) &#123; RecordError(e); &#125; &#125; if (HttpRuntime.UseIntegratedPipeline &amp;&amp; _context != null) &#123; _context.HideRequestResponse = false; &#125; _hideRequestResponse = false; _context = null; _resumeStepsWaitCallback= new WaitCallback(this.ResumeStepsWaitCallback); //3. 判斷要走管道模式還是經典模式 if (HttpRuntime.UseIntegratedPipeline) &#123; _stepManager = new PipelineStepManager(this); &#125; else &#123; _stepManager = new ApplicationStepManager(this); &#125; //4. 建置Pipleline流程 _stepManager.BuildSteps(_resumeStepsWaitCallback); &#125; finally &#123; _initInternalCompleted = true; // Reset config path context.ConfigurationPath = null; // don't hold on to the context _initContext.ApplicationInstance = null; _initContext = null; &#125; &#125; catch &#123; // Protect against exception filters throw; &#125;&#125; 載入所有註冊HttpModule(InitModules方法)這個方法讀取註冊的HttpModule並共同放在一起,在一起呼叫InitModulesCommon方法來呼叫所有Modules的Init方法 1234567891011121314151617181920212223private void InitModules() &#123; HttpModulesSection pconfig = RuntimeConfig.GetAppConfig().HttpModules; HttpModuleCollection moduleCollection = pconfig.CreateModules(); HttpModuleCollection dynamicModules = CreateDynamicModules(); moduleCollection.AppendCollection(dynamicModules); _moduleCollection = moduleCollection; InitModulesCommon();&#125;private void InitModulesCommon() &#123; int n = _moduleCollection.Count; for (int i = 0; i &lt; n; i++) &#123; _currentModuleCollectionKey = _moduleCollection.GetKey(i); _moduleCollection[i].Init(this); &#125; _currentModuleCollectionKey = null; InitAppLevelCulture();&#125; _moduleCollection[i].Init(this); 其中的this就是把HttpApplication物件本身傳入這也是為什麼我們繼承IHttpMoudel介面可以共同使用同一個HttpApplication物件. 1234567public interface IHttpModule&#123; void Init(HttpApplication context); void Dispose();&#125; 上面呼叫的就是void Init(HttpApplication context)方法. 如果要取得目前所註冊HttpModule可透過HttpApplication.Modules屬性 HttpModule添加Asp.net事件原理解析.我們在HttpModule上10多個事件作擴充在ASP.net是如何完成呢? 首先我們來看看事件方法原始碼. 發現每個事件都會呼叫AddSyncEventHookup方法來建立事件,此方法有幾個參數 object key:此事件識別資訊(每個事件都有自己的Object),如BeginRequest事件傳入EventBeginRequest物件. Delegate handler:使用者撰寫事件方法. RequestNotification notification:屬於哪種分群. 12345678910111213141516171819202122232425262728293031323334353637383940/// &lt;devdoc&gt;&lt;para&gt;[To be supplied.]&lt;/para&gt;&lt;/devdoc&gt;public event EventHandler BeginRequest &#123; add &#123; AddSyncEventHookup(EventBeginRequest, value, RequestNotification.BeginRequest); &#125; remove &#123; RemoveSyncEventHookup(EventBeginRequest, value, RequestNotification.BeginRequest); &#125;&#125;/// &lt;devdoc&gt;&lt;para&gt;[To be supplied.]&lt;/para&gt;&lt;/devdoc&gt;public event EventHandler AuthenticateRequest &#123; add &#123; AddSyncEventHookup(EventAuthenticateRequest, value, RequestNotification.AuthenticateRequest); &#125; remove &#123; RemoveSyncEventHookup(EventAuthenticateRequest, value, RequestNotification.AuthenticateRequest); &#125;&#125;// internal - for back-stop module onlyinternal event EventHandler DefaultAuthentication &#123; add &#123; AddSyncEventHookup(EventDefaultAuthentication, value, RequestNotification.AuthenticateRequest); &#125; remove &#123; RemoveSyncEventHookup(EventDefaultAuthentication, value, RequestNotification.AuthenticateRequest); &#125;&#125;//....private void AddSyncEventHookup(object key, Delegate handler, RequestNotification notification, bool isPostNotification = false) &#123; ThrowIfEventBindingDisallowed(); // add the event to the delegate invocation list // this keeps non-pipeline ASP.NET hosts working Events.AddHandler(key, handler); // For integrated pipeline mode, add events to the IExecutionStep containers only if // InitSpecial has completed and InitInternal has not completed. if (IsContainerInitalizationAllowed) &#123; // lookup the module index and add this notification PipelineModuleStepContainer container = GetModuleContainer(CurrentModuleCollectionKey); //WOS 1985878: HttpModule unsubscribing an event handler causes AV in Integrated Mode if (container != null) &#123; SyncEventExecutionStep step = new SyncEventExecutionStep(this, (EventHandler)handler); container.AddEvent(notification, isPostNotification, step); &#125; &#125;&#125; 上面AddSyncEventHookup傳入object key在Httpapplication物件在一開始就會建立下面這些靜態方法(當作每個事件Key) 123456789101112131415161718192021222324252627// event handlersprivate static readonly object EventDisposed = new object();private static readonly object EventErrorRecorded = new object();private static readonly object EventRequestCompleted = new object();private static readonly object EventPreSendRequestHeaders = new object();private static readonly object EventPreSendRequestContent = new object();private static readonly object EventBeginRequest = new object();private static readonly object EventAuthenticateRequest = new object();private static readonly object EventDefaultAuthentication = new object();private static readonly object EventPostAuthenticateRequest = new object();private static readonly object EventAuthorizeRequest = new object();private static readonly object EventPostAuthorizeRequest = new object();private static readonly object EventResolveRequestCache = new object();private static readonly object EventPostResolveRequestCache = new object();private static readonly object EventMapRequestHandler = new object();private static readonly object EventPostMapRequestHandler = new object();private static readonly object EventAcquireRequestState = new object();private static readonly object EventPostAcquireRequestState = new object();private static readonly object EventPreRequestHandlerExecute = new object();private static readonly object EventPostRequestHandlerExecute = new object();private static readonly object EventReleaseRequestState = new object();private static readonly object EventPostReleaseRequestState = new object();private static readonly object EventUpdateRequestCache = new object();private static readonly object EventPostUpdateRequestCache = new object();private static readonly object EventLogRequest = new object();private static readonly object EventPostLogRequest = new object();private static readonly object EventEndRequest = new object(); 最後把事件資訊添加到Events集合中,已便建立管道時使用. 1234567891011/// &lt;devdoc&gt;/// &lt;para&gt;[To be supplied.]&lt;/para&gt;/// &lt;/devdoc&gt;protected EventHandlerList Events &#123; get &#123; if (_events == null) &#123; _events = new EventHandlerList(); &#125; return _events; &#125;&#125; 透過上面機制就可以確保對於Events取得事件時順序. 管道模式 vs 經典模式下面兩張圖是管道模式和經典模式 經典模式 管道模式 圖片來源 除了執行流程不一樣跟一些差異外，他們最終還是為了要找到一個HttpHandler來執行. 取得執行HttpHandler物件如果有認真看原始碼的小夥伴,會發現HttpApplication的ProcessRequest目前是throw一個錯誤. 那他是怎麼找到使用HttpHandler物件並完成請求的呢? 123void IHttpHandler.ProcessRequest(HttpContext context) &#123; throw new HttpException(SR.GetString(SR.Sync_not_supported));&#125; 因為HttpRunTime是呼叫異步請求BeginProcessRequest方法. 這邊提一下 啟動吧!Asp.Net IsapiRunTime &amp; HttpRuntime會先判斷app物件是否實現IHttpAsyncHandler. HttpApplication有實現IHttpAsyncHandler介面.所以優先執行異步請求. 1234567891011if (app is IHttpAsyncHandler) &#123; // asynchronous handler IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)app; context.AsyncAppHandler = asyncHandler; asyncHandler.BeginProcessRequest(context, _handlerCompletionCallback, context);&#125;else &#123; // synchronous handler app.ProcessRequest(context); FinishRequest(context.WorkerRequest, context, null);&#125; 小結今天我們學到 HttpApplication去讀取所有註冊的HttpModule並呼叫他們的Init方法. 經典模式和管道模式除了執行流程不同最終目標還是找尋一個HttpHandler HttpRunTime是呼叫異步請求 了解HttpModule添加Asp.net事件原理解析 很多文章都會提到10多個事件（BeginRequest, EndRequest…..等） 下篇會介紹StepManager如何建立管道和如何呼叫事件並找尋HttpHandler來執行. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day5/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[掌控HttpApplication物件建立 - HttpApplicationFactory (第4天)]]></title>
    <url>%2FIthelp-day4%2F</url>
    <content type="text"><![CDATA[Agenda 前言： HttpApplication物件 取得使用 HttpApplication物件 (GetApplicationInstance) HttpApplicationFactory 初始化 (EnsureInited方法) Application_Start方法為什麼只會呼叫一次? (EnsureAppStartCalled) 返回一個 HttpApplication 物件 (GetNormalApplicationInstance) 小結 前言：附上Asp.net執行請求流程圖. 在前一篇我們說到HttpRunTime會透過GetApplicationInstance來取得一個IHttpHandler對象. 今天跟著原始碼來了解到底回傳一個什麼IHttpHandler物件給HttpRunTime使用. 查看原始碼好站 Reference Source HttpApplication物件HttpApplication是整個ASP.NET基礎的核心。一個HttpApplication物件在某個時刻只能處理一個請求,只有完成對某個請求處理後,該HttpApplication才能用於後續的請求的處理。 所以ASP.NET利用物件程序池機制來建立或者取得HttpApplication物件。具體來講,當第一個Http請求抵達的時候,ASP.NET會一次建立多個HttpApplication物件,並將其置於池中,選擇其中一個物件來處理該請求。 而如果程序池中沒有HttpApplication物件,Asp.net會建立新的HttpApplication物件處理請求 HttpApplication物件處理Http請求整個生命週期是一個相對複雜的過程,在該過程的不同階段會觸發相應的事件。我們可以註冊相應的事件(如同上一篇介紹事件表) 下圖就是模擬HttpApplication的ObjectPool樣子 取得使用 HttpApplication物件 (GetApplicationInstance)讓我們看看GetApplicationInstan方法做了什麼事情. 12345678910111213141516private static HttpApplicationFactory _theApplicationFactory = new HttpApplicationFactory();internal static IHttpHandler GetApplicationInstance(HttpContext context) &#123; if (_customApplication != null) return _customApplication; // Check to see if it's a debug auto-attach request if (context.Request.IsDebuggingRequest) return new HttpDebugHandler(); _theApplicationFactory.EnsureInited(); _theApplicationFactory.EnsureAppStartCalled(context); return _theApplicationFactory.GetNormalApplicationInstance(context);&#125; _theApplicationFactory是一個靜態物件 _theApplicationFactory呼叫三個方法EnsureInited,EnsureAppStartCalled,GetNormalApplicationInstance,讓我們一一來解析做了些什麼事情吧 HttpApplicationFactory 初始化 (EnsureInited方法)通過查找Init方法的代碼以及其中2行如下代碼裡的細節,我們可以得知,這2行代碼主要是從global.asax獲取內容,然後進行編譯。 HttpApplicationFactory.EnsureInited()方法檢查HttpApplicationFactory是否已經被初始化,如果沒有就呼叫HttpApplicationFactory.Init()進行初始化。 在Init()中,先獲取網站下global.asax文件完整路徑(透過GetApplicationFile方法),最後呼叫CompileApplication()方法對global.asax進行編譯. 在EnsureInited方法 12345678910111213141516171819202122232425262728293031private void EnsureInited() &#123; if (!_inited) &#123; lock (this) &#123; if (!_inited) &#123; Init(); _inited = true; &#125; &#125; &#125;&#125;private void CompileApplication() &#123; // Get the Application Type and AppState from the global file _theApplicationType = BuildManager.GetGlobalAsaxType(); BuildResultCompiledGlobalAsaxType result = BuildManager.GetGlobalAsaxBuildResult(); if (result != null) &#123; if (result.HasAppOrSessionObjects) &#123; GetAppStateByParsingGlobalAsax(); &#125; _fileDependencies = result.VirtualPathDependencies; &#125; if (_state == null) &#123; _state = new HttpApplicationState(); &#125; ReflectOnApplicationType();&#125; ReflectOnApplicationType方法取得目前特別事件方法,並添加到相對應的MethodInfo成員上 會透過以下三類方法名稱去取方法資訊 Application_OnStart or Application_Start Application_OnEnd or Application_End Session_OnEnd or Session_End 取得這些資訊會提供EnsureAppStartCalled去呼叫Application_OnStart方法 12345678910111213141516171819202122232425262728private void ReflectOnApplicationType() &#123; ArrayList handlers = new ArrayList(); MethodInfo[] methods; Debug.Trace("PipelineRuntime", "ReflectOnApplicationType"); // get this class methods methods = _theApplicationType.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static); foreach (MethodInfo m in methods) &#123; if (ReflectOnMethodInfoIfItLooksLikeEventHandler(m)) handlers.Add(m); &#125; // get base class private methods (GetMethods would not return those) Type baseType = _theApplicationType.BaseType; if (baseType != null &amp;&amp; baseType != typeof(HttpApplication)) &#123; methods = baseType.GetMethods(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static); foreach (MethodInfo m in methods) &#123; if (m.IsPrivate &amp;&amp; ReflectOnMethodInfoIfItLooksLikeEventHandler(m)) handlers.Add(m); &#125; &#125; // remember as an array _eventHandlerMethods = new MethodInfo[handlers.Count]; for (int i = 0; i &lt; _eventHandlerMethods.Length; i++) _eventHandlerMethods[i] = (MethodInfo)handlers[i];&#125; Application_Start方法為什麼只會呼叫一次? (EnsureAppStartCalled)HttpApplicationFactory.EnsureAppStartCalled方法建立一個HttpApplication物件並觸發Application_OnStart事件(執行Global.asax中的Application_Start(object sender, EventArgs e)) 在處理完事件Application_OnStart後HttpApplication物件會立即被回收掉,因為系統初始化只需要一次 但是其中GetSpecialApplicationInstance裡會對IIS7做一些特殊的事情這裡就不多提 1234567891011121314151617181920212223242526272829303132private void EnsureAppStartCalled(HttpContext context) &#123; if (!_appOnStartCalled) &#123; lock (this) &#123; if (!_appOnStartCalled) &#123; using (new DisposableHttpContextWrapper(context)) &#123; WebBaseEvent.RaiseSystemEvent(this, WebEventCodes.ApplicationStart); FireApplicationOnStart(context); &#125; _appOnStartCalled = true; &#125; &#125; &#125;&#125;private void FireApplicationOnStart(HttpContext context) &#123; if (_onStartMethod != null) &#123; HttpApplication app = GetSpecialApplicationInstance(); app.ProcessSpecialRequest( context, _onStartMethod, _onStartParamCount, this, EventArgs.Empty, null); RecycleSpecialApplicationInstance(app); &#125;&#125; 在處理完事件Application_OnStart呼叫RecycleSpecialApplicationInstance回收HttpApplication物件 返回一個 HttpApplication 物件 (GetNormalApplicationInstance)方法中主要做. 判斷_freeList集合中是否有可用HttpApplication物件(物件程序池中),如果沒有就利用HttpRuntime.CreateNonPublicInstance(_theApplicationType)透過反射建立一個新的HttpApplication返回(呼叫完IHttpHandler.ProcessRequst方法後會將這個物件存入_freeList中),最後將 12345678910111213141516171819private HttpApplication GetNormalApplicationInstance(HttpContext context) &#123; HttpApplication app = null; if (!_freeList.TryTake(out app)) &#123; // If ran out of instances, create a new one app = (HttpApplication)HttpRuntime.CreateNonPublicInstance(_theApplicationType); using (new ApplicationImpersonationContext()) &#123; app.InitInternal(context, _state, _eventHandlerMethods); &#125; &#125; if (AppSettings.UseTaskFriendlySynchronizationContext) &#123; // When this HttpApplication instance is no longer in use, recycle it. app.ApplicationInstanceConsumersCounter = new CountdownTask(1); // representing required call to HttpApplication.ReleaseAppInstance app.ApplicationInstanceConsumersCounter.Task.ContinueWith((_, o) =&gt; RecycleApplicationInstance((HttpApplication)o), app, TaskContinuationOptions.ExecuteSynchronously); &#125; return app;&#125; 所以最終我們是返回一個HttpApplication物件來使用. 小結今天我們學到 IHttpHandler GetApplicationInstance(HttpContext context)其實是返回一個HttpApplication物件. 在EnsureAppStartCalled方法中呼叫FireApplicationOnStart方法動態建立一個HttpApplication物件,呼叫完Application_OnStart事件就回收掉並使用一個flag布林值代表已經呼叫過. 這個工廠會有一個 _freeList 集合來存取之前用過的HttpApplication物件,如果集合中沒有適合的HttpApplication物件就會使用反射返回一個新的HttpApplication並將他初始化． 所以HttpRuntime呼叫的是HttpApplication物件的ProcessRequest方法 下篇會跟大家介紹HttpApplication類別成員詳細資訊 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day4/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[啟動吧!Asp.Net IsapiRunTime & HttpRuntime (第3天)]]></title>
    <url>%2FIthelp-day3%2F</url>
    <content type="text"><![CDATA[Agenda 前言: IIS 與 Asp net (W3SVC服務) IISAPIRuntime介面 IsapiRunTime.ProcessRequest HttpRuntime.ProcessRequestNoDemand ProcessRequestInternal 小結 前言:上一篇我們介紹HttpModule &amp; HttpHandler對於 今天正式進入.Net CLR處理Http請求的世界. 先附上Asp.net執行請求流程圖. 現在開始講解藍色區塊. 查看原始碼好站 Reference Source IIS 與 Asp net (W3SVC服務)World Wide Web Publishing Service（簡稱W3SVC）是一個Window Service. W3SVC在SvcHost.exe這個應用程式上被執行. W3SVC主要功能 HTTP請求的監聽 工作執行緒的管理以及配置管理 當檢測到某個HTTP Request後，先根據一個註冊表判斷請求的副檔名是否是靜態資源(比如.html,.img,.txt,.xml…)如果是則直接將文件內容以HTTP Response的形式返回。 如果是動態資源（比如.aspx,asp,php等等），則通過副檔名從IIS的Script Map找到相應ISAPI.dll IISAPIRuntime介面前面說到透過W3SVC服務 System.Web.Hosting.IISAPIRuntime這個介面是一個基於COM的Interface,ASP.NET ISAPI可以通過COM的方式調用實現該Interface的Class物件的ProcessRequest方法，從非託管環境進入了託管的環境。 12345678910111213141516[ComImport, Guid("08a2c56f-7c16-41c1-a8be-432917a1a2d1"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]public interface IISAPIRuntime &#123; void StartProcessing(); void StopProcessing(); [return: MarshalAs(UnmanagedType.I4)] int ProcessRequest( [In] IntPtr ecb, [In, MarshalAs(UnmanagedType.I4)] int useProcessModel); void DoGCCollect();&#125; 所以IISAPIRuntime.ProcessRequest是我們探討原始碼起始點. IsapiRunTime.ProcessRequest一開始會先呼叫IsapiRunTime的ProcessRequest方法來執行此次請求. 在CreateWorkerRequest會依據不同IIS版本建立不同ISAPIWorkerRequest物件,之後在呼叫Initialize方法把Http請求內容初次填入這個對象. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int ProcessRequest(IntPtr ecb, int iWRType) &#123; IntPtr pHttpCompletion = IntPtr.Zero; if (iWRType == WORKER_REQUEST_TYPE_IN_PROC_VERSION_2) &#123; pHttpCompletion = ecb; ecb = UnsafeNativeMethods.GetEcb(pHttpCompletion); &#125; ISAPIWorkerRequest wr = null; try &#123; bool useOOP = (iWRType == WORKER_REQUEST_TYPE_OOP); wr = ISAPIWorkerRequest.CreateWorkerRequest(ecb, useOOP); wr.Initialize(); String wrPath = wr.GetAppPathTranslated(); String adPath = HttpRuntime.AppDomainAppPathInternal; if (adPath == null || StringUtil.EqualsIgnoreCase(wrPath, adPath)) &#123; HttpRuntime.ProcessRequestNoDemand(wr); return 0; &#125; else &#123; // need to restart app domain HttpRuntime.ShutdownAppDomain(ApplicationShutdownReason.PhysicalApplicationPathChanged, SR.GetString(SR.Hosting_Phys_Path_Changed, adPath, wrPath)); return 1; &#125; &#125; catch(Exception e) &#123; try &#123; WebBaseEvent.RaiseRuntimeError(e, this); &#125; catch &#123;&#125; if (wr != null &amp;&amp; wr.Ecb == IntPtr.Zero) &#123; if (pHttpCompletion != IntPtr.Zero) &#123; UnsafeNativeMethods.SetDoneWithSessionCalled(pHttpCompletion); &#125; if (e is ThreadAbortException) &#123; Thread.ResetAbort(); &#125; return 0; &#125; throw; &#125;&#125; 這段程式碼有幾個重點: 把Http請求內文封裝到WorkerRequest物件中,方便日後使用. wr.Initialize()初始化WorkerRequest物件 呼叫HttpRuntime.ProcessRequestNoDemand方法並把剛剛初始化的WorkerRequest物件當作參數傳入. 其中參數ecb(Execution Control Block)是一個Unmanaged Pointer ISAPIRuntime不能直接調用ASP.NET ISAPI,所以通過一個ecb物件指標,ecb實現ISAPI和ISAPIRutime之間溝通. HttpRuntime.ProcessRequestNoDemand先來看看剛剛呼叫的HttpRuntime.ProcessRequestNoDemand方法. 這裡需要注意兩個重點. 判斷目前執行程序池是否已經超過負荷,如果是會把wr物件指向null 12if (rq != null) wr = rq.GetRequestToExecute(wr); 如果wr!=null(代表還有資源可以執行請求)就呼叫ProcessRequestNow方法會繼續呼叫ProcessRequestInternal方法. 123456789101112131415161718internal static void ProcessRequestNoDemand(HttpWorkerRequest wr) &#123; RequestQueue rq = _theRuntime._requestQueue; wr.UpdateInitialCounters(); if (rq != null) // could be null before first request wr = rq.GetRequestToExecute(wr); if (wr != null) &#123; CalculateWaitTimeAndUpdatePerfCounter(wr); wr.ResetStartTime(); ProcessRequestNow(wr); &#125;&#125;internal static void ProcessRequestNow(HttpWorkerRequest wr) &#123; _theRuntime.ProcessRequestInternal(wr);&#125; ProcessRequestInternal在HttpRuntime很重要的方法之一是ProcessRequestInternal 下面程式碼，我把ProcessRequestInternal方法中註解移除且只貼出我覺得重要的程式碼 此方法有做幾個事情: 如果Server很忙碌回傳wr.SendStatus(503, &quot;Server Too Busy&quot;); 利用HttpWorkerRequest物件封裝我們常常使用HttpContext 透過HttpApplicationFactory.GetApplicationInstance返回一個IHttpHandler物件 如果返回的IHttpHandler物件支援異步請求優先執行,不然就執行同步請求. 上面第3,4點最為重要,因為我們就可以很清楚了解到為什麼最後都會找到一個繼承IHttpHandler介面的物件來執行ProcessRequest方法. 因為Asp.net在HttpRunTime程式碼中倚賴一個IHttpHandler介面抽象才造就具有彈性的系統架構. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void ProcessRequestInternal(HttpWorkerRequest wr) &#123; HttpContext context; try &#123; //封裝我們常常使用`HttpContext` context = new HttpContext(wr, false /* initResponseWriter */); &#125; catch &#123; try &#123; wr.SendStatus(400, "Bad Request"); wr.SendKnownResponseHeader(HttpWorkerRequest.HeaderContentType, "text/html; charset=utf-8"); byte[] body = Encoding.ASCII.GetBytes("&lt;html&gt;&lt;body&gt;Bad Request&lt;/body&gt;&lt;/html&gt;"); wr.SendResponseFromMemory(body, body.Length); wr.FlushResponse(true); wr.EndOfRequest(); return; &#125; finally &#123; Interlocked.Decrement(ref _activeRequestCount); &#125; &#125; try &#123; try &#123; EnsureFirstRequestInit(context); &#125; catch &#123; if (!context.Request.IsDebuggingRequest) &#123; throw; &#125; &#125; context.Response.InitResponseWriter(); IHttpHandler app = HttpApplicationFactory.GetApplicationInstance(context); if (app == null) throw new HttpException(SR.GetString(SR.Unable_create_app_object)); if (EtwTrace.IsTraceEnabled(EtwTraceLevel.Verbose, EtwTraceFlags.Infrastructure)) EtwTrace.Trace(EtwTraceType.ETW_TYPE_START_HANDLER, context.WorkerRequest, app.GetType().FullName, "Start"); //如果返回的IHttpHandler物件支援異步請求優先執行,不然就執行同步請求. if (app is IHttpAsyncHandler) &#123; // asynchronous handler IHttpAsyncHandler asyncHandler = (IHttpAsyncHandler)app; context.AsyncAppHandler = asyncHandler; asyncHandler.BeginProcessRequest(context, _handlerCompletionCallback, context); &#125; else &#123; // synchronous handler app.ProcessRequest(context); FinishRequest(context.WorkerRequest, context, null); &#125; &#125; catch (Exception e) &#123; context.Response.InitResponseWriter(); FinishRequest(wr, context, e); &#125;&#125; 下面此這個方法執行時兩個小重點. ProcessRequestInternal方法初始化我們常用HttpContext物件,把Http內容封裝到這個類別中. 如果返回IHttpHandler物件支援異步請求優先執行,不然就執行同步請求. 小結今天我們學到 ISAPIRunTime.ProcessRequest方法 建立一個WorkerRequest物件把Http內容封裝到裡面,並呼叫 HttpRuntime.ProcessRequestNoDemand方法. HttpRuntime.ProcessRequestNoDemand方法 檢查目前是否有資源可以處理請求 封裝HttpContext並初始化內容資料 利用HttpApplicationFactory.GetApplicationInstance取得IHttpHanlder物件 呼叫IHttpHanlder ProcessRequest方法 下篇我們會來好好介紹HttpApplicationFactory這個工廠到底如何返回IHttpHanlder物件. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day3/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.Net支柱 IHttpMoudle & IHttphandler (第2天)]]></title>
    <url>%2FIthelp-day2%2F</url>
    <content type="text"><![CDATA[Agenda 前言： IHttpHandler和HttpModule關係 Asp.net_Application_Event生命週期 Event事件名稱： 事件方法說明： IHttpHandler IHttpModule 自己建立一個 IHttpHandler Web.Config註冊上面撰寫的IHttpHandler 自己建立一個 IHttpModule 建立一個類別實現IHttpModule Web.Config註冊上面撰寫的IHttpModule 程式碼 建立一個類別實現IHttpHander ApplicationHost.config 設定擋 IIS預設設定Module在哪邊? IIS IISExpress 小結 參考資料： 前言：上一篇文章我們有說 Asp.net 有兩個核心組件 IHttpMoudle &amp; IHttphandler Asp.net 是一個pipeline的模型，理解這些管道除了可以讓我們節省許多不必要的資源浪費也可讓我們程式架構更加有條理. 就像我們在Asp.net MVC如果要寫權限驗證程式碼,雖然可以寫在Controller的Action中 但更好做法是我可以寫一個類別繼承AuthorizeAttribute並override OnAuthorization方法並掛上此標籤. 更了解這些原理可以讓我們寫程式事半功倍. IHttpHandler和HttpModule關係Http請求像是一個旅客身上帶著行李拿著票來搭火車. HttpHandler 是火車的終點站. HttpModule 是火車中途停靠的各站. Asp.net_Application_Event生命週期我們已經知道Asp.net是一個請求處理響應的管道而這個管道中微軟有提供許多點可以讓我們進行客製化的擴充程式撰寫 事件可藉由IHttpModule來擴充註冊 Event事件名稱：官網列出可用事件很多，下面列出我有用過的幾個事件和其功用. BeginRequest AuthorizeRequest PostResolveRequestCache MapRequestHandler AcquireRequestState PreRequestHandlerExecute PostRequestHandlerExecute EndRequest 事件方法說明： BeginRequest: 已經啟動要求。如果要在要求前執行某個動作 (例如, 在每頁頁首顯示廣告橫幅), 請同步處理這個事件。 AuthorizeRequest: 您可以在內部使用這個事件, 以實作授權機制 (例如, 將存取控制清單 (ACL) 儲存在資料庫, 而非存入檔案系統)。您也可以覆寫這個事件, 但無此必要。 PostResolveRequestCache：當 ASP.NET 略過目前事件處理常式的執行並允許快取模組從快取中服務要求時發生。 MapRequestHandler：ASP.NET 基礎結構會使用事件來判斷目前要求的要求處理常式。 如需詳細資訊 AcquireRequestState: 工作階段狀態是擷取自狀態儲存區。如果要建置自已的狀態管理模組, 則可以同步處理這個事件, 以便從狀態儲存區擷取「工作階段」狀態。 PreRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之前產生。 在介於PreRequestHandlerExecute和PostRequestHandlerExecute事件之間會執行HttpHandler程式碼. PostRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之後產生。 EndRequest: 要求已完成。您可能想要建置偵錯模組, 以便收集要求的全部資訊, 然後再將資訊寫入網頁中。 IHttpHandler和IHttpModule關係如 Implementing HTTPHandler and HTTPModule in ASP.NET 文章提到 每個請求一定會通過所有被註冊的IHttpModule,而最終會執行一個IHttpHandler後進行返回. 我們常聽到的Asp.net Webform，MVC都是經過管道Module並執行相對應的Handler. 所以HttpHanlder 和 HttpMoudule 搭配使用達到更強大的功能. IHttpHandlerMSDN說明 您可以撰寫自訂的 HTTP 處理常式來處理特定的預先定義的任何 Common Language Specification (CLS) 標準的語言中的 HTTP 要求的類型。 可執行程式碼中定義HttpHandler類別，而不是傳統的 ASP 或 ASP.NET Web 網頁，這些特定的要求回應。 HTTP 處理常式提供您一種低層級的要求和回應服務的 IIS Web 伺服器互動，以及大部分 ISAPI 擴充程式類似，但使用簡單的程式設計模型提供的功能。 IHttpHandler是一個可以讓我們實現的介面裡面包含： 屬性: 1public bool IsReusable &#123; get; &#125; 取得值，指出另一個要求是否可以使用 IHttpHandler 執行個體。 方法: 1public void ProcessRequest(HttpContext context) 以實作 IHttpHandler 介面的自訂 HttpHandler 來啟用 HTTP Web 要求的處理。 IHttpModuleMSDN說明 Modules are called before and after the handler executes. Modules enable developers to intercept, participate in, or modify each individual request. Modules implement the IHttpModule interface, which is located in the System.Web namespace. 處理常式 (Handler) 在執行前後，會呼叫模組 (Module)。 模組可以讓開發人員攔截、參與或修改每個要求。 更印證了 如果把Http請求當作火車那 IHttpHandler是火車的終點 IHttpModule是沿路經過的站點 要查看有哪寫IHttpModule或IHttpHandler被註冊可以看applicationhost.config檔案 路徑：C:\Users[user]\Documents\IISExpress\config\applicationhost.config 自己建立一個 IHttpHandler在前面有說到每個Http請求的最終是為了給一個HttpHander來執行處理. 像我們常看到的 ASP.NET page (*.aspx) Web service (*.asmx) Generic Web (*.ashx) 甚至是MVC (MvcHandler)都是實現於IHttpHander介面 這邊介紹如果要如何建立自己HttpHander. Web.Config註冊上面撰寫的IHttpHandler我們要在Web.Config中設定我們撰寫的HttpHandler 這是一個範例: 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="HttpHandler_HttpModule.MyHttpHandler"/&gt; &lt;/handlers&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 把handlers加入在system.webServer結點中. 裡面有幾個Attribute verb：請求動作 GET,POST,PUT...如果是*代表全部請請動作都合用. path：請求那些副檔名會執行此HttpHandler type：註冊的HttpHandler類型. 其中最要注意的是type Attribute. 1&lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="(namespace).(classname)"/&gt; 最後我們就可以請求 http://xxxx/Mypage.cspx 來試試看我們的結果. 我們將請求*.cspx副檔名的所有請求都當作要透過CLR來執行. 自己建立一個 IHttpModule每個被註冊的HttpModule是Http請求必經之路. Asp.net MVC 是透過System.Web.Routing.UrlRoutingModule 這個HttpModule來完成切入的. 使用IHttpModule須完成幾個步驟: 建立一個類別實現IHttpModule Web.Config註冊上面撰寫的IHttpModule 建立一個類別實現IHttpModule這個範例會在頁面上顯示 IIS Pipeline Event的執行順序. public void Init(HttpApplication context) 把 HttpApplication 中的event做擴充. 1234567891011121314151617181920212223242526272829303132333435public class MyHttpModule:IHttpModule&#123; public void Init(HttpApplication context) &#123; context.BeginRequest += (sender, args) =&gt; ShowStep(sender, "BeginRequest"); context.AuthorizeRequest += (sender, args) =&gt; ShowStep(sender, "AuthorizeRequest"); context.PostResolveRequestCache += (sender, args) =&gt; ShowStep(sender, "PostResolveRequestCache"); context.MapRequestHandler += (sender, args) =&gt; ShowStep(sender, "MapRequestHandler"); context.AcquireRequestState += (sender, args) =&gt; ShowStep(sender, "AcquireRequestState"); context.PreRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PreRequestHandlerExecute"); //這中間執行IHttpHandler. context.PostRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PostRequestHandlerExecute"); context.EndRequest += (sender, args) =&gt; ShowStep(sender, "EndRequest"); context.PreSendRequestHeaders += (sender, args) =&gt; ShowStep(sender, "PreSendRequestHeaders"); &#125; private void ShowStep(object app,string eventName) &#123; var http = (HttpApplication)app; http.Response.Write($"Step &#123;eventName&#125;&lt;br/&gt;"); &#125; public void Dispose() &#123; &#125;&#125; Web.Config註冊上面撰寫的IHttpModule註冊方法和IHttpHander很類似,一樣在system.webServer節點下加入modules 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;modules&gt; &lt;add name="MyHttpModule" type="HttpHandler_HttpModule.MyHttpModule"/&gt; &lt;/modules&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 程式碼使用IHttpHandler須完成幾個步驟: 建立一個類別實現IHttpHander Web.Config註冊上面撰寫的IHttpHandler 建立一個類別實現IHttpHander繼承完IHttpHandler我們會實現兩個方法. ProcessRequest(HttpContext context) 執行此次請求動作. bool IsReusable { get; } 是否要將此次請求加入快取中重用. 123456789101112public class MyHttpHandler : IHttpHandler&#123; public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = "text/html"; context.Response.Write("==================&lt;br/&gt;"); context.Response.Write("Hello World&lt;br/&gt;"); context.Response.Write("==================&lt;br/&gt;"); &#125; public bool IsReusable &#123; get; &#125;&#125; ApplicationHost.config 設定擋前面有說到aspnet_isapi.dll會去判斷此次請求要怎麼處理,她會去讀取handlers註冊節點的對應表來判斷是否要透過CLR處理此次請求. IIS預設設定Module在哪邊?她是透過 ApplicationHost.config 來抓取，HttpHandler 和 HttpModule設定. 這邊分為兩個部分: IISIIS可借由HandlerMappings和Module來設置 HandlerMappings 可以看到有許多預設要處理的附檔名(.aspx,.svc)在裡面都可以看到. Module IIS預設幫忙載入許多Moudle我們自己客製化的Module也可以在這邊設定 IISExpress基本上IISExpress 全域 config 會放在這個路徑 C:\Users\%USERPROFILE%\Documents\IISExpress\config 如果VS版本高於2015以上執行Web專案時，會在每個專案上建立一個.vs資料夾並把ApplicationHost.config複製一份放到下面影片的路徑中 範例原始碼下載 小結今天我們學到 自己建立一個Httpmodule 自己建立一個Httphandler ApplicationHost.config設定擋和Httpmodule &amp; Httphandler關係且如何設定. 今天先丟一個問題給大家那，為什麼Asp.net可以依賴IHttphandler介面來完成請求這是怎麼實現的? 下篇我們會來回答上面的答案. 參考資料： HTTP Handlers and HTTP Modules Overview#Features) Implementing HTTPHandler and HTTPModule in ASP.NET 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day2/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(開賽)Http 請求 Asp.net IIS伺服器架構 (第1天)]]></title>
    <url>%2FIthelp-day1%2F</url>
    <content type="text"><![CDATA[Agenda 開賽前言： 為什麼想要選擇此主題 閱讀時建議事項 文章收穫 進入主題 瀏覽器請求IIS流程 如何辨別是否為靜態檔案? .Net CLR Httpmodule &amp; Httphandler 核心模組 W3WP應用程式 小結 開賽前言：三十篇文章架構基本遵循: 前言:前情提要，閱讀此文建議使用工具或知識. 標出大主題(大字體+錨點)之後在細項列出要說明的細節 小結：每篇都有一個小結快速總結今天重點 為什麼想要選擇此主題選擇這個主題主要原因是 沒有人整理一套較完整的Asp.net執行原始碼解析文章(從Http請求IIS Server,進入CLR前置動作),asp.net mvc原始碼解析 台灣大部分的文章都是分享如何使用，很少文章有介紹如何運作． 利用微軟開原後站在巨人肩膀上可以看更遠，理解MVC框架如何去設計具有一定的彈性. 了解核心運作流程，更好改善或擴充現有專案架構（讓系統變得更有條理） 閱讀時建議事項我在文章中會盡量寫出我看到精華部分,但此系列文可能對於MVC新手不太容易閱讀,因為MVC框架中運用到許多設計模式和OOP觀念(當初我在閱讀上也花了不少功夫) 個人覺得OOP有很重要一個點是盡量用物件和物件關聯，資料狀態轉移來了解程式碼. 簡白來說就是物件關聯和關係 文章收穫我希望大家在閱讀完所有文章後可以獲得 Http對於IIS Server請求如何導向Asp.net MVC執行 Asp.net MVC原始碼有基本了解和知道哪幾個重要類別,了解後能依照系統需要替換改寫. Asp.net MVC用到很多設計技巧(因為這是一個較大框架),希望大家能更了解設計模式如何運用在實戰中 閱讀第一個框架原始碼會花不少時間,了解一個大框架後在去看其他框架閱讀時間會越來越少 進入主題Asp.net基於.NET Framework框架所提供，開發Web應用程式的類別庫，封裝在System.Web.dll檔案中，提供使用者開發網頁，ASP.NET運行在安裝了.NET Framework的IIS(Internet Information Services)伺服器上 微軟大大近幾年也投入Open Source行列讓我們可以更方便來窺探，Asp.net運作原理. 這個連結 Reference Source 可以查看微軟核心的DLL程式碼(這個網站是我們第一階段追code的好朋友) Asp.net程式基本上是由IIS進行託管，介紹Asp.net MVC原始碼之前我們需要先了解Asp.net和IIS關係. 瀏覽器請求IIS流程Web基於Http協定，它是一個無狀態協定，每次請求都是新的且不會紀錄之前請求的東西下圖我畫出一個對於IIS請求基本會跑的流程圖. 基本分為兩個區塊 粉紅色是IIS Server領域 會有一個Http.sys的程式在監聽所有Http請求並交由W3WP.exe並透過aspnet_isapi來此次請求是否為靜態檔案. 藍色是.Net CLR領域由幾塊核心程式完成請求 ISAPIRunTime HttpRuntime HttpApplicationFactory HttpApplication 之後會陸續介紹他們. 請求靜態檔案透過路徑找尋靜態檔案並回傳. 請求非靜態檔案透過.Net CLR執行返回結果. 如何辨別是否為靜態檔案?如何辨別是否為靜態檔案,就需要談談HttpHandler的註冊表(後面有文章會說到) 基本上如果是請求Html,css,js…都會直接回傳不會在經過.Net CLR .Net CLR Httpmodule &amp; Httphandler 核心模組Asp.net所有應用程式都離不開兩個核心模組Httpmodule &amp; Httphandler且最終會找到一個繼承於IHttpHanlder物件來處理請求. 在網路上看到一個很好地比喻HttpModule &amp; HttpHandler Http請求像是一個旅客身上帶著行李拿著票來搭火車. HttpHandler 是火車的終點站. HttpModule 是火車中途停靠的各站. 這個比喻可以很清楚知道每個請求透過CLR就是要找到一個HttpHandler來執行. 圖片參考連結 W3WP應用程式當IIS在執行處理Http請求時工作管理員有一個w3wp應用程式在監聽. 此應用程式會依照aspnet_isapi模組來判斷此次請求是否走入.net CLR 小結今天我們了解到 瀏覽器請求IIS基本流程 Asp.net核心模組Httpmodule &amp; Httphandler IIS有一個Http.sys程式在監聽所有Http請求 IIS透過一個w3wp.exe初步過濾判斷如何執行此請求. 瀏覽器發出Http請求給IIS,IIS透過Http.sys來監聽請求並交給w3wp.exe這個應用程式來判斷是否要交由.net託管處理此次請求. 下篇我們會來詳細講述Httpmodule &amp; Httphandler 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Ithelp-day1/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>11th鐵人賽</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Asp.net-MVC</tag>
        <tag>SourceCode</tag>
        <tag>11th鐵人賽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net HttpHandler vs HttpModule 詳細解說.]]></title>
    <url>%2FHttpHandler-HttpModule%2F</url>
    <content type="text"><![CDATA[前言：Asp.net 是一個pipeline的模型 我覺得.Net Web工程師對於這個模型和IHttpHanlder,IHttpModule 要有基本的概念和理解. 理解這些管道除了可以讓我們節省許多不必要的資源浪費也可讓我們程式架構更加有條理. 就像我們在Asp.net MVC如果要寫權限驗證程式碼,雖然可以寫在Controller的Action中 但更好做法是我可以寫一個類別繼承AuthorizeAttribute並override OnAuthorization方法並掛上此標籤. 所以更了解這些原理可以讓我們寫程式事半功倍. Asp.net Application Event 生命週期前面我們知道Asp.net是一個請求處理響應的管道而這個管道中微軟有提供許多點可以讓我們進行客製化的擴充程式撰寫 事件可藉由IHttpModule來擴充註冊 Event事件名稱：官網列出可用事件很多，下面列出我有用過的幾個事件和其功用. BeginRequest AuthorizeRequest PostResolveRequestCache MapRequestHandler AcquireRequestState PreRequestHandlerExecute PostRequestHandlerExecute EndRequest 事件方法說明： BeginRequest: 已經啟動要求。如果要在要求前執行某個動作 (例如, 在每頁頁首顯示廣告橫幅), 請同步處理這個事件。 AuthorizeRequest: 您可以在內部使用這個事件, 以實作授權機制 (例如, 將存取控制清單 (ACL) 儲存在資料庫, 而非存入檔案系統)。您也可以覆寫這個事件, 但無此必要。 PostResolveRequestCache：當 ASP.NET 略過目前事件處理常式的執行並允許快取模組從快取中服務要求時發生。 MapRequestHandler：ASP.NET 基礎結構會使用事件來判斷目前要求的要求處理常式。 如需詳細資訊 AcquireRequestState: 工作階段狀態是擷取自狀態儲存區。如果要建置自已的狀態管理模組, 則可以同步處理這個事件, 以便從狀態儲存區擷取「工作階段」狀態。 PreRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之前產生。 在介於PreRequestHandlerExecute和PostRequestHandlerExecute事件之間會執行HttpHandler程式碼. PostRequestHandlerExecute: 這個事件會在執行 HTTP 處理常式之後產生。 EndRequest: 要求已完成。您可能想要建置偵錯模組, 以便收集要求的全部資訊, 然後再將資訊寫入網頁中。 IHttpHandler 和 IHttpModule 關係用一句話簡述IHttpHandler和IHttpModule 如果把Http請求當作火車那 IHttpHandler是火車的終點 IHttpModule是沿路經過的站點 IHttpHandler和IHttpModule關係如 Implementing HTTPHandler and HTTPModule in ASP.NET 文章提到 每個請求一定會通過所有被註冊的IHttpModule,而最終會執行一個IHttpHandler後進行返回. 我們常聽到的Asp.net Webform，MVC都是經過管道Module並執行相對應的Handler. 所以HttpHanlder 和 HttpMoudule 搭配使用達到更強大的功能. IHttpHandlerMSDN說明 您可以撰寫自訂的 HTTP 處理常式來處理特定的預先定義的任何 Common Language Specification (CLS) 標準的語言中的 HTTP 要求的類型。 可執行程式碼中定義HttpHandler類別，而不是傳統的 ASP 或 ASP.NET Web 網頁，這些特定的要求回應。 HTTP 處理常式提供您一種低層級的要求和回應服務的 IIS Web 伺服器互動，以及大部分 ISAPI 擴充程式類似，但使用簡單的程式設計模型提供的功能。 IHttpHandler是一個可以讓我們實現的介面裡面包含： 屬性: 1public bool IsReusable &#123; get; &#125; 取得值，指出另一個要求是否可以使用 IHttpHandler 執行個體。 方法: 1public void ProcessRequest(HttpContext context) 以實作 IHttpHandler 介面的自訂 HttpHandler 來啟用 HTTP Web 要求的處理。 IHttpModuleMSDN說明 Modules are called before and after the handler executes. Modules enable developers to intercept, participate in, or modify each individual request. Modules implement the IHttpModule interface, which is located in the System.Web namespace. 處理常式 (Handler) 在執行前後，會呼叫模組 (Module)。 模組可以讓開發人員攔截、參與或修改每個要求。 更印證了 如果把Http請求當作火車那 IHttpHandler是火車的終點 IHttpModule是沿路經過的站點 要查看有哪寫IHttpModule或IHttpHandler被註冊可以看applicationhost.config檔案 路徑：C:\Users[user]\Documents\IISExpress\config\applicationhost.config 自己建立一個 IHttpHandler在前面有說到每個Http請求的最終是為了給一個HttpHander來執行處理. 像我們常看到的 ASP.NET page (*.aspx) Web service (*.asmx) Generic Web (*.ashx) 甚至是MVC (MvcHandler)都是實現於IHttpHander介面 這邊介紹如果要如何建立自己HttpHander. 程式碼使用IHttpHandler須完成幾個步驟: 建立一個類別實現IHttpHander Web.Config註冊上面撰寫的IHttpHandler 建立一個類別實現IHttpHander繼承完IHttpHandler我們會實現兩個方法. ProcessRequest(HttpContext context) 執行此次請求動作. bool IsReusable { get; } 是否要將此次請求加入快取中重用. 123456789101112public class MyHttpHandler : IHttpHandler&#123; public void ProcessRequest(HttpContext context) &#123; context.Response.ContentType = "text/html"; context.Response.Write("==================&lt;br/&gt;"); context.Response.Write("Hello World&lt;br/&gt;"); context.Response.Write("==================&lt;br/&gt;"); &#125; public bool IsReusable &#123; get; &#125;&#125; Web.Config註冊上面撰寫的IHttpHandler我們要在Web.Config中設定我們撰寫的HttpHandler 這是一個範例: 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;handlers&gt; &lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="HttpHandler_HttpModule.MyHttpHandler"/&gt; &lt;/handlers&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 把handlers加入在system.webServer結點中. 裡面有幾個Attribute verb：請求動作 GET,POST,PUT...如果是*代表全部請請動作都合用. path：請求那些副檔名會執行此HttpHandler type：註冊的HttpHandler類型. 其中最要注意的是type Attribute. 1&lt;add verb="*" name="MyHttpHandler" path="*.cspx" type="(namespace).(classname)"/&gt; 最後我們就可以請求 http://xxxx/Mypage.cspx 來試試看我們的結果. 自己建立一個 IHttpModule每個被註冊的HttpModule是Http請求必經之路. Asp.net MVC 是透過System.Web.Routing.UrlRoutingModule 這個HttpModule來完成切入的. 使用IHttpModule須完成幾個步驟: 建立一個類別實現IHttpModule Web.Config註冊上面撰寫的IHttpModule 建立一個類別實現IHttpModule這個範例會在頁面上顯示 IIS Pipeline Event的執行順序. public void Init(HttpApplication context) 把 HttpApplication 中的event做擴充. 1234567891011121314151617181920212223242526272829303132333435public class MyHttpModule:IHttpModule&#123; public void Init(HttpApplication context) &#123; context.BeginRequest += (sender, args) =&gt; ShowStep(sender, "BeginRequest"); context.AuthorizeRequest += (sender, args) =&gt; ShowStep(sender, "AuthorizeRequest"); context.PostResolveRequestCache += (sender, args) =&gt; ShowStep(sender, "PostResolveRequestCache"); context.MapRequestHandler += (sender, args) =&gt; ShowStep(sender, "MapRequestHandler"); context.AcquireRequestState += (sender, args) =&gt; ShowStep(sender, "AcquireRequestState"); context.PreRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PreRequestHandlerExecute"); //這中間執行IHttpHandler. context.PostRequestHandlerExecute += (sender, args) =&gt; ShowStep(sender, "PostRequestHandlerExecute"); context.EndRequest += (sender, args) =&gt; ShowStep(sender, "EndRequest"); context.PreSendRequestHeaders += (sender, args) =&gt; ShowStep(sender, "PreSendRequestHeaders"); &#125; private void ShowStep(object app,string eventName) &#123; var http = (HttpApplication)app; http.Response.Write($"Step &#123;eventName&#125;&lt;br/&gt;"); &#125; public void Dispose() &#123; &#125;&#125; Web.Config註冊上面撰寫的IHttpModule註冊方法和IHttpHander很類似,一樣在system.webServer節點下加入modules 1234567&lt;configuration&gt; &lt;system.webServer&gt; &lt;modules&gt; &lt;add name="MyHttpModule" type="HttpHandler_HttpModule.MyHttpModule"/&gt; &lt;/modules&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 範例原始碼下載 參考資料： https://docs.microsoft.com/en-us/previous-versions/aspnet/bb398986(v=vs.100)#Features https://support.microsoft.com/zh-tw/help/307985/info-asp-net-http-modules-and-http-handlers-overview https://www.codeproject.com/Articles/335968/Implementing-HTTPHandler-and-HTTPModule-in-ASP-NET 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/HttpHandler-HttpModule/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Asp.net</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>IHttpHanlder</tag>
        <tag>IHttpModule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[State Pattern(狀態者模式)]]></title>
    <url>%2FStatusPattern%2F</url>
    <content type="text"><![CDATA[前言：狀態者模式 優勢在可將複雜的物件狀態條件,以物件方式來減少條件式的判斷程式 可由物件自身的狀態，決定之後的動作行為. 狀態者模式 說明：需求簡易流程如下 這是一個簡單的訂單流程圖 我們可看到從建立訂單開始-&gt;最後判斷成功或取消訂單 看似簡單但需要寫一定程度的判斷條件式,而且也要做一定程度的逆向流程防呆. 這裡先貼上 未使用狀態者模式的程式碼: PaymentContext.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class PaymentContext&#123; Product _Item &#123; get; set; &#125; PayStatus _status &#123; get; set; &#125; public PaymentContext(Product p) &#123; _Item = p; _status = PayStatus.Init; &#125; /// &lt;summary&gt; /// 設置狀態 /// &lt;/summary&gt; /// &lt;param name="status"&gt;&lt;/param&gt; public string SetStatus(PayStatus status) &#123; string result = $"修改成功&#123;status.ToString()&#125;"; switch (_status) &#123; case PayStatus.Init: if (status == PayStatus.Init) result = "請勿重新建立訂單"; else _status = status; break; case PayStatus.Success: result = "訂單成功請勿修改"; break; case PayStatus.Cancel: result = "訂單取消請勿修改"; break; case PayStatus.Processing: if (status == PayStatus.Init) result = "請勿重新建立訂單"; else _status = status; break; &#125; return result; &#125; /// &lt;summary&gt; /// 跑流程 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string RunProcess() &#123; switch (_status) &#123; case PayStatus.Init: _status = PayStatus.Processing; return "交易建立中..."; case PayStatus.Success: return "交易完成"; case PayStatus.Cancel: return "交易取消完成"; case PayStatus.Processing: if (_Item.Price &gt; 300) &#123; _status = PayStatus.Cancel; return "物件超過300元 交易取消中"; &#125; _status = PayStatus.Success; return "交易中請稍後"; &#125; return "不在狀態內"; &#125;&#125; 裡面有SetStatus 和 RunProcess 方法 RunProcess 方法 就是將商品一個往下一個流程推進 SetStatus 方法 可以改變商品狀態 上面類別中的程式碼 目前有點小複雜但還算簡單,但等日後需求越來越多 後人一直把程式碼寫入Switch case 或if ... else 中就會導致程式碼越來越複雜 這個情境我們可以嘗試使用 State Pattern(狀態者模式) 幫助我們將每個自身狀態封裝到物件裡面,由每個狀態來決定後面動作 我們可發現 每個流程都可以使用 RunningProcee 和 SetSatus 這兩個動作 就可開出一個抽象類別,裡面有這兩個抽象方法,給之後的狀態子類去實現. 1234567public abstract class PaymentSatusBase&#123; protected PaymentGate _gate; public abstract string Running(Product p); public abstract string SetSatus(PayStatus s);&#125; PaymentGate 是給外部呼叫端使用的類別,我們可比較上面之前PaymentContext類別可看到if....else 全部不見了, 因為狀態封裝到各個類別中了 1234567891011121314151617181920212223242526272829303132public class PaymentGate&#123; Product _product; internal PaymentSatusBase CurrnetProceess &#123; get; set; &#125; // 這裡擁有下個流程的引用 public PaymentGate(Product p) &#123; _product = p; CurrnetProceess = new InitSatus(this); &#125; internal PayStatus CurrnetStatus &#123; get; set; &#125; /// &lt;summary&gt; /// 設置狀態 /// &lt;/summary&gt; /// &lt;param name="status"&gt;&lt;/param&gt; public string SetStatus(PayStatus status) &#123; return CurrnetProceess.SetSatus(status); &#125; /// &lt;summary&gt; /// 跑流程 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public string RunProcess() &#123; return CurrnetProceess.Running(_product); &#125;&#125; 如何新建一個流程物件? 首先我們需要先取得當前使用者使用的 PaymentGate引用並傳入建構子當作參數 實現Running和SetStatus方法,並將此狀態的邏輯寫上 執行完後需要更改下個流程,可以將值賦予給CurrnetProceess 屬性 1234567891011121314151617181920212223242526272829public class ProcessSatus : PaymentSatusBase&#123; public ProcessSatus(PaymentGate g) &#123; _gate = g; &#125; public override string Running(Product p) &#123; string result = "交易中請稍後"; if (p.Price &gt; 300) &#123; result = "物件超過300元 交易取消中"; _gate.CurrnetProceess = new CancelSatus(_gate); &#125; else _gate.CurrnetProceess = new SuccessSatus(_gate); return result; &#125; public override string SetSatus(PayStatus s) &#123; string result = string.Empty; if (s == PayStatus.Init) result = "請勿重新建立訂單"; return result; &#125;&#125; 說明:以流程進行中為例子. 他會判斷商品使用超過300元,來決定下個流程 所以我們就把這個邏輯寫在此類中. 另外後面幾個流程比照辦理一一搬入類別中 12345678910111213141516171819202122232425262728293031323334353637383940public class CancelSatus : PaymentSatusBase&#123; public CancelSatus(PaymentGate g) &#123; _gate = g; &#125; public override string Running(Product p) &#123; return "交易取消完成"; &#125; public override string SetSatus(PayStatus s) &#123; string result = string.Empty; if (s == PayStatus.Init) result = "訂單取消請勿修改"; return result; &#125;&#125;public class SuccessSatus : PaymentSatusBase&#123; public SuccessSatus(PaymentGate g) &#123; _gate = g; &#125; public override string Running(Product p) &#123; return "交易完成"; &#125; public override string SetSatus(PayStatus s) &#123; string result = string.Empty; if (s == PayStatus.Init) result = "訂單成功請勿修改"; return result; &#125;&#125; 最後外部程式使用如下 12345678910Product p = new Product();p.Name = "電腦";p.Price = 300000;PaymentGate context = new PaymentGate(p);Console.WriteLine(context.RunProcess());Console.WriteLine(context.RunProcess());Console.WriteLine(context.RunProcess());context.SetStatus(PayStatus.Init);Console.WriteLine(context.RunProcess()); 程式碼放在github上 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/StatusPattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>StatePattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gaps and Islands problem (SQL) 連續範圍]]></title>
    <url>%2FSQL-Gaps-and-Islands-problem%2F</url>
    <content type="text"><![CDATA[前言：SO 發現蠻多人有遇到 Gaps and Islands problem count of last continuous inserted records based on date 之前有跟大家分享過 解決連續範圍的思路 [SQL連續範圍] 數字，日期連續範圍 今天針對發問者實際例子來一步步 解決問題… 提問出處:count of last continuous inserted records based on date 問題說明:提問者希望可以獲得最近一次連續日期的次數 例如: user_id | point | DateTime 1 | 10 | 18-08-2018 17:15 2 | 10 | 01-08-2018 17:15 1 | 10 | 21-08-2018 17:15 1 | 10 | 22-08-2018 17:15 2 | 10 | 26-08-2018 17:15 1 | 10 | 25-08-2018 17:15 2 | 10 | 27-08-2018 17:15 1 | 10 | 26-08-2018 17:15 1 | 10 | 27-08-2018 17:15 有6筆資料是user_id = 1 希望取得user_id = 1最後一次連續日期數量是3 因為 這三筆是最近連續日期 27-08-2018 26-08-2018 25-08-2018 解決思路整理:連續資料有個特性就是一組(連續範圍數值) - (基於某個條件順序產稱的數值) 結果是一樣的 user_id 分群 並加上編號 因為要基於日期找尋連續日期,所以使用一個小技巧 先找尋每個 user_id最小天數 (最大天數也可) ,之後使用datediff函數取得差一天數來當數值 我會使用sql-server來解說(因為支援window function) XD 範例說明:基於某個條件順序產稱的數值 :先在子查詢中取得每個user_id最小日期,以便後面使用datediff函數取得間隔天數(產生編號) 1MIN(DateTime) over(partition by user_id order by DateTime ) 連續範圍數值 : 我使用 Row_number 和 Window function 依照每個使用者給編號. 1Row_number() over(partition by user_id order by DateTime) 之後使用diffdate函數 並將兩值相減取得 1234567891011SELECT DateTime,datediff(day, MIN(DateTime) over(partition by user_id order by DateTime ),DateTime) - Row_number() over(partition by user_id order by DateTime)rnFROM Table1Where user_id = 1 | DateTime | rn ||----------------------|----|| 2018-08-18T17:15:00Z | -1 || 2018-08-21T17:15:00Z | 1 || 2018-08-22T17:15:00Z | 1 || 2018-08-25T17:15:00Z | 3 || 2018-08-26T17:15:00Z | 3 || 2018-08-27T17:15:00Z | 3 | 我們可以看到連續日期的分組已經出來了 有了這個連續編號 我們就可以直接取得我們要的結果了 123456789;with cte as ( SELECT DateTime,datediff(day, MIN(DateTime) over(partition by user_id order by DateTime ),DateTime) - Row_number() over(partition by user_id order by DateTime)rn FROM Table1 Where user_id = 1 )SELECT TOP 1 count(*) cntFROM ctegroup by rnORDER BY MAX(DateTime) desc 因為只要取得最近一筆連續日期資料 我們可以 ORDER BY MAX(DateTime)且使用TOP 1來取得最新一筆的連續數量 SQLFiddle 小結:使用window function後, 語法整個變得很簡單.(有興趣可以進SO連結看沒有使用window function的解法 露露長) 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/SQL-Gaps-and-Islands-problem/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MSSQL</tag>
        <tag>MySQL</tag>
        <tag>Postgresql</tag>
        <tag>SQL-Gaps-and-Islands-problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[發布自己的Nuget專案]]></title>
    <url>%2FDeploy-OwnNuget%2F</url>
    <content type="text"><![CDATA[前言：前陣子在被面試官說：我有電子發票開源專案，是否有上到Nuget上 我回答:沒有. 我就突然想到我也可以把我的專案放到Nuget上讓更多人方便使用 我就查詢資料去了解整個上板流程,並打成文章跟大家分享 下載Nuget Commandline Tool下載Nuget Commandline Tool 之後你會取得 nuget.exe 這個檔案 把它放到你要打包Nuget的專案資料夾中 之後打開cmd 並在專案資料夾打上 nuget spce 之後在你資料夾中會出現 xxxx.nuspec的XML檔案,這個檔案是描述你要打包的專案 123456789101112131415161718&lt;code class="language-xml"&gt;&lt;?xml version="1.0"?&gt;&lt;package &gt; &lt;metadata&gt; &lt;id&gt;&lt;/id&gt; &lt;version&gt;&lt;/version&gt; &lt;title&gt;&lt;/title&gt; &lt;authors&gt;&lt;/authors&gt; &lt;owners&gt;&lt;/owners&gt; &lt;licenseUrl&gt;&lt;/licenseUrl&gt; &lt;projectUrl&gt;&lt;/projectUrl&gt; &lt;iconUrl&gt;&lt;/iconUrl&gt; &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt; &lt;description&gt;This is a AOP framework&lt;/description&gt; &lt;releaseNotes&gt;Summary of changes made in this release of the package.&lt;/releaseNotes&gt; &lt;copyright&gt;Copyright 2018&lt;/copyright&gt; &lt;tags&gt;c# AOP&lt;/tags&gt; &lt;/metadata&gt;&lt;/package&gt; 必填欄位 ID：不區分大小寫的套件識別碼，在整個 nuget.org 或套件所在的任何組件庫中都必須是唯一的。 識別碼可能不包含對 URL 而言無效的空格或字元，而且通常會遵循 .NET 命名空間規則。 如需指導方針，請參閱選擇唯一的套件識別碼。 Version：套件版本，遵循 major.minor.patch 模式。 版本號碼可以包含預先發行版本的後置詞，如套件版本控制中所述。 Description：UI 顯示中的套件詳細描述。 Authors：以逗號分隔的套件作者清單，與 nuget.org 上的設定檔名稱相符。這些名稱會顯示在 nuget.org 的 NuGet 組件庫中，並用來交互參照相同作者的其他套件。 打包Nuget填完資料後就可以回到commandline 並打另一個指令nuget pack將專案打包成 xxx.nupkg 檔案 以提供上傳 之後申辦一個Nuget帳號,並產生一個API Key 產生完後在上面的選單選擇 Upload 按鈕 之後按下Browse按鈕並上傳你的 xxxx.nupkg檔案,上傳完畢後就按下Submit按鈕 將此專案提交上去 上傳完畢後Nuget他會審核你的專案,等審核完後大家就可以下載使用你的專案摟^^ 石頭已經打包專案這兩個是我已經發布的專案 AwesomeProxy.Net ElectronicInvoice_TW Note如果要查nuget指令可以打 nuget ? 參考連結：.nuspec 參考 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Deploy-OwnNuget/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Nuget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(AutoMapper)反射自動註冊AutoMapper Profile]]></title>
    <url>%2FAutoMapperInit%2F</url>
    <content type="text"><![CDATA[前言：AutoMapper 幫我我們方便管理物件跟物件之間屬性值格式轉換 模型轉換這裡有兩個類別 UserInfoModel 當作我們從DB撈取出來 模型資料 123456public class UserInfoModel&#123; public int RowId &#123; get; set; &#125; public string Name &#123; get; set; &#125; public int Age &#123; get; set; &#125;&#125; UserInfoViewModel 是呈現在UI或其他地方的模型 其中 Detail欄位由 UserInfoModel的 Name和 Age屬性組成的 1234public class UserInfoViewModel&#123; public string Detail &#123; get; set; &#125;&#125; 這時我們就會引用 AutoMapper 幫我們統一管理轉換模型上的問題 建立一個Profile設置UserInfoModel對於 UserInfoViewModel之前的欄位轉換 123456789public class UserInfoProfile : Profile&#123; public UserInfoProfile() &#123; CreateMap&lt;UserInfoModel, UserInfoViewModel&gt;() .ForMember(t =&gt; t.Detail, s =&gt; s.MapFrom(_ =&gt; $"DetailInfo:&#123;_.Name&#125; &#123;_.Age&#125;")); &#125;&#125; 而我們在註冊時會呼叫 AddProfile方法 1Mapper.Initialize(x =&gt; x.AddProfile&lt;UserInfoProfile&gt;()); 但每次新加Profile這邊都需要設置新的Profile，我們就會想有沒有方法可以讓他自動註冊？ 我們可以使用反射來完成 反射自動註冊AutoMapper Profile此程式我使用我的 ExtenionTool 1234567var profiles = Assembly.GetExecutingAssembly() .GetInstancesByAssembly&lt;Profile&gt;();foreach (var profile in profiles)&#123; Mapper.Initialize(x =&gt; x.AddProfile(profile));&#125; 上面程式碼很簡單清晰，呼叫 取得目前組件所有的 Profile物件實體並且加到Profile中，我們將上面程式碼在初始化執行一次 1234567public static IEnumerable&lt;TResult&gt; GetInstancesByAssembly&lt;TResult&gt;(this Assembly ass)&#123; return ass.GetTypes() .Where(x =&gt; typeof(TResult).IsAssignableFrom(x) &amp;&amp; x.IsNormalClass()) .Select(x =&gt; Activator.CreateInstance(x)) .Cast&lt;TResult&gt;();&#125; 核心程式使用Linq 動態取得你所需的類型並使用反射創建 之後我們就可以不用在手動把Profile加至AutoMapper容器中了 Source Code 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/AutoMapperInit/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Automapper</tag>
        <tag>Model</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[為什麼 Float和Double會有誤差 (浮點數儲存原理)]]></title>
    <url>%2FfloatVSDouble%2F</url>
    <content type="text"><![CDATA[前言：大家都知道float和double會有誤差 但原因是什麼呢? 今天就跟大家分享Float和Double會誤差的原因 一. 浮點數介紹 一開始先對於float和double做身家調查 浮點類型的範圍 類型 最小值 最大值 float 1.175494351 E – 38 3.402823466 E + 38 double 2.2250738585072014 E – 308 1.7976931348623158 E + 308 浮點類型 類型 有效數字 位元組數 float 6 – 7 4 double 15 – 16 8 二. 浮點數產生以float來說可以儲存4 byte = 32 bit 是說最多可以存32個 0 or 1 但 float 和 int都是 32 bit 使用方式卻完全不一樣 浮點數計算方式是由 IEEE 754 進位浮點數算術標準創立 他把浮點數分成三部分 Sign(符號), Exponent(指數), Mantissa(尾數) 來表示他的值** 表示方式 1111 1111 1111 1111 1111 1111 1111 1111 Sign(符號) 第1個 bit ​ (紅色) 0 = 正數 1 = 負數 Exponent(指數) 第2個 ~ 第9個 bit (藍色) 總共8 bit 最大值 255 (二進至值) 127 為中間值原點 Mantissa(尾數) 第10個 ~ 第32個 bit (棕色) 計算之後的尾數 到目前因該是有看沒有懂XD 等等帶個範例大家就會比較清楚了 三. 實例解說 後面看到 X 代表等待計算的值 12.5f 為例子 如何計算出 32 bit 如何儲存這個值? 判斷是正數還是負數決定Sign(符號) 因為12.5f是正數 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 計算Exponent(指數)​​ 將12.5f轉成二進制 12.5f = 1100.1 將數值底數變成 1&lt;底數&lt;2 1100.1​ = 1.1001 * 2 ^ 3 2^3 二的三次方就是 指數​要加的值 127 + 3 = 130 (1000 0010) *1011 1111 1XXX XXXX XXXX XXXX XXXX XXXX *0000 0001 1XXX XXXX XXXX XXXX XXXX XXXX *———————————————————————– *1100 0001 0XXX XXXX XXXX XXXX XXXX XXXX Mantissa(尾數)​ 計算​ 最後將 1.1001 小數點後的值 .1001追加到(指數​)後面 ​1100 0001 0000 0000 0000 0000 0000 0000 ​​ + 0000 0000 0100 1000 0000 0000 0000 0000 ​ ————————————————————— 0100 0001 0100 1000 0000 0000 0000 0000 所以我們可以得出 12.5f 在 32bit 中是 0100 0001 0100 1000 0000 0000 0000 0000 這裡有個工具 Float (IEEE754 Single precision 32-bit) 可以方便我們來驗算值是否正確 他很貼心幫我們列出 Sign(符號), Exponent(指數), Mantissa(尾數) 位置給我們對應 四,為什麼會不精準現在我們知道計算 Exponent(指數)​​ 需要將值轉成二進制 ,但如果是12.53f 轉成二進制會變成這樣1100.100000111100111....... 極限值就會和原本的值出現誤差 如圖 我們可以看到 12.53f 其實會變成 1.252999973297119140625E1 這就是float不準確的原因 float介紹完了 double和float概念一樣只是儲存空間更大而已^^ 小結因為為了節省空間浮點數 使用特別儲存方式來節省空間,有一好沒兩好這樣就少了精準度 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/floatVSDouble/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>float</tag>
        <tag>double</tag>
        <tag>number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediatorPattern(中介者模式)]]></title>
    <url>%2FMediator-Pattern%2F</url>
    <content type="text"><![CDATA[說明系統模塊存在很多複雜的耦合問題，很適合使用中介者模式來解耦合 在現實中如果組織有一定規模可能構通如下圖那般複雜 如果有一個人或組織負責幫大家協助溝通，就可解決上面複雜問題 這就是我們這次的核心中介者 中介者模式有幾個角色 AbstractMediator (抽像中介者)：定義中介者和各個同事者之間的通信的介面 ConcreteMediator (中介者)：知道每個同事物件，實現抽像中介者，負責協調和各個具體的同事的交互關係 AbstractColleague (抽象同事者)：定義同事者和中介者通信的接口 ConcreteColleague (同事者)：實現自己的業務，並且實現抽象方法，跟中介者進行通信 中介者模式特點是 中介者知道所有同事者物件，但同事者互相不知道對方存在需透過中介者傳遞訊息 如何傳遞和通知各個同事者由中介者內部決定 在裡面第二點是很重要的目標，把傳遞訊息的邏輯封裝在中介者裡面 程式碼1234567891011121314public class ProductManager&#123; public DBAdmin DbAdmin &#123; get; set; &#125; public Programer Programer &#123; get; set; &#125; internal void Send(string message, OriginReqBase req) &#123; //如果是DBAdmin傳遞訊息由Programer執行,反之 if (req.GetType() == typeof(DBAdmin)) Programer.DoProcess(message); else if(req.GetType() == typeof(Programer)) DbAdmin.DoProcess(message); &#125;&#125; 傳遞通知或訊息邏輯寫在Send方法裡面. 本次範例依照傳入的型別,如果是DBAdmin傳遞訊息由Programer執行,反之 1234567891011121314public abstract class OriginReqBase&#123; protected ProductManager _productManager; protected OriginReqBase(ProductManager productManager) &#123; _productManager = productManager; &#125; public virtual void Requirement(string message) &#123; _productManager.Send(message, this); &#125;&#125; OriginReqBase(抽象同事者) 因為每個角色 (ConcreteColleague) 都需要知道中介者存在，所以把參數設定在建構子上。 Requirement方法通知 PM 中介者將資料傳遞出去 12345678910111213141516171819202122232425public class Programer : OriginReqBase&#123; public void DoProcess(string message) &#123; Console.WriteLine($"Programer: &#123;message&#125;"); &#125; public Programer(ProductManager productManager) : base(productManager) &#123; &#125;&#125;public class DBAdmin : OriginReqBase&#123; public void DoProcess(string message) &#123; Console.WriteLine($"DBA:&#123;message&#125;"); &#125; public DBAdmin(ProductManager productManager) : base(productManager) &#123; &#125;&#125; DoProcess 方法 PM 中介者呼叫使用 1234567891011ProductManager pm = new ProductManager();DBAdmin DBA1 = new DBAdmin(pm); //DBA知道PM存在Programer RD1 = new Programer(pm); //RD知道PM存在pm.Programer = RD1; //PM知道DBApm.DbAdmin = DBA1; //PM知道RD//現在DBA和RD只需要傳訊息就可將訊息轉到需要知道的人RD1.Requirement("DB modify Requestment.");DBA1.Requirement("DB Process doing."); 有三大重點 DBA和RD(同事者) 知道PM(中介者)存在 PM(中介者)知道DBA和RD(同事者)存在 ㄋDBA和RD不用知道對方存在但卻可以互相傳遞訊息(因為PM已經幫助我們解耦合了) UML圖 (有標示相對應的角色關係) 我看來這個解耦合核心思想跟容器有點像，因為需要做溝通或通知時我們統一只需要轉交給中介者會幫助我們處理溝通事宜 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Mediator-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>MediatorPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己Blog系列(三) Hexo next theme 介紹]]></title>
    <url>%2Fhexo-blog-theme%2F</url>
    <content type="text"><![CDATA[前言：為何我會選用Hxeo來當作Blog框架? 有下面幾個原因: 因為建立於本地端，所以可以更方便離線進行編輯 使用 Markdown 語法撰寫Blog，更方便、通用、容易上手 搭配線上CICD工具部署於 Github 上，完全零成本 中文文件資源多 支援多樣不同樣板，可隨心所欲切換風格 開源社群活躍 基於NodeJs擁有豐富的差件 建立自己的Hexo安裝 Node.js首先先安裝 Node.js 官網下載安裝 安裝完後使用CMD node -v \npm -v 查看是否安裝成功. 安裝 Hexo-cli使用 npm 來安裝 hexo (須先安裝 Node.js) npm install hexo-cli -g 因為我們之前就有建立一個Code Blog Repository. 我們使用CMD 的 CD 命令進入此資料夾目錄中 在使用hexo cli幫助我們快速建立Blog相關檔案 hexo init blog # 初始化 blog npm install # 安裝相關套件 如果要把Hexo deploy到Github上面，需要先安裝 npm install hexo-deployer-git –save Hexo config.yml 設定說明Hexo 是使用yml檔案格式來當設定檔. hexo init blog # 初始化 blog 資料夾檔案結構如下圖： 當在Blog Code Repository 中建立完Hexo資料檔後會有一個_config.yml檔案,就是Hexo的設定檔案. 解說 config.yml 設定檔預設頁面：title: 石頭的coding之路 #網站標題 subtitle: description: 好點子沒價值，有價值的是把好點子實現 #網站描述 keywords: author: Daniel Shih #您的名字 language: zh-tw #語系 timezone: #時差 # Header menu: Home: / Archives: /archives About: /about.html Tags: /tags Categories: /categories 路由設定：# URL url: https://isdaniel.github.io/ #網站的網址 root: / #網站的根目錄 permalink: :year/:month/:day/:title/ permalink_defaults: 資料檔設定：# Directory source_dir: source #原始檔案資料夾，這個資料夾用於存放您的內容 預設值 source public_dir: public #使用Hexo g 產生靜態檔案資料夾名稱 tag_dir: tags #標籤資料夾名稱 archive_dir: archives #彙整資料夾名稱 category_dir: categories #分類資料夾名稱 code_dir: downloads/code i18n_dir: :lang #語言資料夾名稱 skip_render: 文章設定new_post_name: :title.md #新文章的檔案名稱 default_layout: post #預設佈局資料夾 titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: 配置index2 generatorindex2_generator: per_page: 10 order_by: -date include: - category Web exclude: - tag Hexo Hexo 時間格式# Date / Time format ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD #日期格式 time_format: HH:mm:ss #時間格式 Hexo 主題設定# Extensions theme: next #使用主題名稱, 設為 false 表示關閉主題功能 發佈資料設定# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git #發佈使用版控類別 使用git repo: https://github.com/isdaniel/isdaniel.github.io.git #發佈到哪個Repository branch: master #發佈使用的分支 社群資料設定：# Social Accounts instagram_url: https://www.instagram.com/dn_shih/ github_url: https://github.com/isdaniel email_url: dog830228@gmail.com 設定檔可以參考我的_config.yml檔案 或是也可以參考官網 Hexo推薦Theme [Next]Hexo有眾多Theme可以選擇，我們要切換使用的Theme只需要做幾個步驟. 在網路上尋到想要使用的Hexo Theme. 把資料檔放在/themes/資料夾目錄下. 這次想要跟大家介紹我使用的Next Theme，我會使用原因如下 擁有眾多開源者貢獻 畫面乾淨又整潔 在Hexo使用Next 我們把上面的Next Theme clone一份下來.https://github.com/theme-next/hexo-theme-next.git 在/themes/ 建立一個 next 資料夾並把Next Theme所有檔案copy進去. 修改Hexo _config.yml檔案，把theme改成next Hexo推薦插件下面是我推薦大家使用的Hexo插件，使用說明我就不一一跟大家解釋了網路上很多分享文. theme-next-reading-progress 閱讀進度. hexo-symbols-count-time 閱讀次數 hexo-generator-index2 頁面分類 hexo-related-popular-posts 熱門文章 hexo-addlink 在文章最末添加永久鏈接及版權聲明 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/hexo-blog-theme/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Blog</tag>
        <tag>Github</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沒有Source Code 如何修改程式??]]></title>
    <url>%2FNoSourceCode-ModifyCode%2F</url>
    <content type="text"><![CDATA[前言：某些專案因為歷史久遠沒有Source Code,但有個需求需要異動裡面的程式該怎麼辦?? 難道只能整個反組譯,查看程式碼翻一份做新的嗎? 不~~其實有辦法直接對於DLL進行修改 只需使用 Reflexil 搭配 ILSpy 或其他支援的反組譯​軟體 Reflexil 是一個組譯編輯器插件目前支援 Reflector, ILSpy 和 Telerik’s JustDecompile. 下載連結 Reflexil **Release 2.2 搭配 ILSpy version 3.2 前置動作，安裝Reflexil 下載下載 reflexil.for.ILSpy.2.2.bin.zip，不用下載AIO 作者有說 ILSpy version 3.2 (ILSpy 4 is not currently compatible with Reflexil, given the use of System.Reflection.Metadata, deprecating Mono.Cecil usage) ILSpy 4當前版本 ILSpy.2.2 並不支援 ILSpy 3.2 下載 下載完後就把全部的DLL放在同一個資料夾下,並開啟 ILSpy.exe 按下上方的齒輪UI 就可獲得下方藍色的Reflexil 修改框框. 組件修改需求目前組件 有個ClassA 類別,裡面有一個prop1屬性 型態是string, 我們希望在這新增另一個屬性 使用滑鼠右鍵點擊類別ClassA,我們可以看到很多方式可以注入新的程式碼 在這我們選擇inject property. 我們需要修改的是 Item Name (使用屬性的名稱) Property Type(使用屬性類別) 選擇完後按下OK,我們就會發現prop2新屬性會出現在ClassA中. 新增完後不代表已經將修改儲存!! 我們需要點選組件，之後再按下Save AS 把本次修改儲存 日後我們就可以使用新的屬性在我們程式中了!! 小結此插件還可以新增,插入許多東西時屬非常強大,有興趣的玩家可再自行深入琢磨. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/NoSourceCode-ModifyCode/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Reflection</tag>
        <tag>Decompile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[樣板模式(TemplatePattern)]]></title>
    <url>%2FTemplate-Pattern%2F</url>
    <content type="text"><![CDATA[前言：如果目前場景遇到一定流程階段，但流程內容依照邏輯或情境不同也有所不一樣. 這時可以考慮使用樣板模式(TemplatePattern) 生活舉例：因為十二年國教，所以基本上每個人都有上學的經驗 每天上學最少要經歷下面過程(我做一些簡化) 到學校=&gt;上午上課=&gt;吃午餐=&gt;下午上課=&gt;放學回家 可以看到不管是國小、國中、高中 至少都有上述的過程 但每個過程內容可能會依照年級階段不同，也有所不一樣 例如： 吃中餐：高中可能是吃便當，但國小是吃營養午餐，雖然都是吃飯但內容不一樣。 上午上課：都是教數學，但高中教微積分，國小教加減乘除。 重點:流程雖一樣但細部邏輯交由學校去實施實現 常見例子：我們常見的測試框架 MSTest,NUnit..... 都有樣板模式的思想。 一般來說測試框架都有生命週期，只是每個框架命名不一樣但核心原理差不多 SetUpClass (每個測試類別只都執行一次) SetUpUnitTest (每次執行測試方法時都執行一次) UnitTest (執行測試方法) 如下圖 (圖片來自網路上) 程式碼範例：此範例使用Console來模擬單元測試框架流程： 建立一個 UnitFlowBase 抽像類別依照Nunit生命週期來實現下面方法. OneTimeSetUp (每個測試類別只都執行一次) Dispose (每次執行測試方法時都執行一次) SetUp 每次執行TestCase前資料初始化 TearDown 每次執行TestCase後釋放資源 此抽象類別提供幾個Hock讓子類實做細節。 UnitFlowBase只提供框架 UnitTest對外提供一個void UnitTest(IEnumerable&lt;Func&lt;bool&gt;&gt; testCases)方法. 可以傳入要驗證動作一個IEnumerable&lt;Func&lt;bool&gt;&gt;型別. 123456789101112131415161718192021222324252627282930public abstract class UnitFlowBase&#123; protected virtual void OneTimeSetUp() &#123; &#125; protected virtual void Dispose() &#123; &#125; protected virtual void SetUp() &#123; &#125; protected virtual void TearDown() &#123; &#125; public void UnitTest(IEnumerable&lt;Func&lt;bool&gt;&gt; testCases) &#123; OneTimeSetUp(); foreach (var testCase in testCases) &#123; SetUp(); Console.WriteLine(testCase() ? "Assert Successful." : "Assert Fail."); TearDown(); &#125; Dispose(); &#125;&#125; 建立另一個類別UnitCounter重載SetUp,OneTimeSetUp方法. 123456789101112public class UnitCounter : UnitFlowBase&#123; protected override void SetUp() &#123; Console.WriteLine("Set up UnitCounter thing."); &#125; protected override void OneTimeSetUp() &#123; Console.WriteLine("OneTimeSetUp!!"); &#125;&#125; 呼叫實我們建立一個UnitCounter類別,並傳入一個IEnumerable&lt;Func&lt;bool&gt;&gt;的資料集合 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; UnitCounter unitCounter = new UnitCounter(); unitCounter.UnitTest(new List&lt;Func&lt;bool&gt;&gt;() &#123; ()=&gt;true, ()=&gt;false, ()=&gt;false, ()=&gt;true &#125;); Console.ReadKey(); &#125;&#125; 實際案例在我一個開源專案中ElectronicInvoice_TW,有使用到Template Method Pattern 因為在大平台傳送資料有些固定的流程,這個就很適合使用此Pattern. 參數需要按照字首排序. 參數製作簽章防偽造. 利用Http類別請求大平台. 對於每個API來說有一個變化是傳入參數,所以我就把它當作是此系列類別需要override方法. 而在ApiBase.cs是所有大平台API的Base類別在裡面有一個string ExecuteApi(TModel mode)方法提供給外部呼叫. 詳細資料可自行參閱我的原始碼. 小結:日後測試程式只需關注我們需要如何實現邏輯細解（重寫三個方法），核心流程順序就交由UnitFlowBase決定。 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Template-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>TemplatePattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle [CONNECT BY]]]></title>
    <url>%2FOracle-CONNECT-BY%2F</url>
    <content type="text"><![CDATA[之前有介紹 (SQL Server) CTE RECURSIVE (遞迴)製作月曆 在Oracle 有提供一個精簡的語法產生階層資料 CONNECT BY CONNECT BY 有幾個常用Key Word. LEVEL目前在樹節點第幾階層 START WITH 設定哪筆做為起始點開始樹 PRIOR用於指定父資料欄位 製造出的階層樹，概念如下 [圖來自Oracle] 範例一建立連續數字 1~10 &lt;code class=&quot;language-sql&quot;&gt;SELECT X + LEVEL FROM ( SELECT 0 X FROM DUAL ) CONNECT BY LEVEL &lt;= 10 此範例使用 LEVEL 在 CONNECT BY 上當條件 建立列值到LEVEL 大於等於 10 sqlfiddle 範例二建立日曆表 &lt;code class=&quot;language-sql&quot;&gt;SELECT startDt + LEVEL - 1 FROM ( SELECT sysdate endDt, (sysdate -10) startDt FROM DUAL )t1 CONNECT BY startDt - endDt + LEVEL &lt;= 0 一開始有兩個欄位 StartDt 起始時間(10天前) EndDt 最後時間(現在時間) 期望建立一個結果集從10天前日期到現在，一樣是使用LEVEL在當Offset的時間 範例三CONNECT BY 最強大的地方是在於建立階層表 樣本資料： CREATE TABLE HierarchyDemo ( PartNo INT, NAME VARCHAR2(16), ParentPartNo INT ); INSERT INTO HierarchyDemo VALUES(1,&apos;Boss&apos;,0); INSERT INTO HierarchyDemo VALUES(2,&apos;Jack&apos;,1); INSERT INTO HierarchyDemo VALUES(3,&apos;TOM&apos;,2); INSERT INTO HierarchyDemo VALUES(4,&apos;AMY&apos;,3); INSERT INTO HierarchyDemo VALUES(5,&apos;Daniel&apos;,2); SQL腳本： SELECT t1.*,LEVEL FROM HierarchyDemo t1 START WITH ParentPartNo = 0 CONNECT BY PRIOR PartNo = ParentPartNo START WITH ParentPartNo = 0 設置為起始點，開始找尋建立子階級 PRIOR PartNo 代表下一次由PartNo當作根結點 找尋 PartNo = ParentPartNo 的列 最後變成下圖 | PARTNO | NAME | PARENTPARTNO | LEVEL | |--------|--------|--------------|-------| | 1 | Boss | 0 | 1 | | 2 | Jack | 1 | 2 | | 3 | TOM | 2 | 3 | | 4 | AMY | 3 | 4 | | 5 | Daniel | 2 | 3 | 參考資料：Oracle Hierarchical Queries 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Oracle-CONNECT-BY/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ (三) Fanout 交換器]]></title>
    <url>%2FRabbitMQ-Fanout%2F</url>
    <content type="text"><![CDATA[前言：本篇範例使用Fanout 交換器 實現RabbitMQ 在RabbitMQ中有很重要兩個角色，Producer和Consumer，下面這個範例使用c# console來實現 Producer一開始我們宣告一個 ConnectionFactory 並設置RabbitMQ Server連接參數 UserName 使用者帳號 Password 使用者密碼 HostName 連接FQDN或IP RabbitMQ預設密碼是 guest //建立連接工廠 ConnectionFactory factory = new ConnectionFactory { UserName = &quot;guest&quot;, Password = &quot;guest&quot;, HostName = &quot;localhost&quot; }; 呼叫factory.CreateConnection 建立連接RabbitMQ連接物件，並呼叫 CreateModel方法建立一個channel Model using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { //建立一個Queue channel.QueueDeclare(queueName, false, false, false, null); //建立一個Exchange channel.ExchangeDeclare(exchangeName, ExchangeType.Fanout, false, false, null); channel.QueueBind(queueName,exchangeName,routeKey); Console.WriteLine(&quot;\nRabbitMQ連接成功,如需離開請按下Escape鍵&quot;); string input = string.Empty; do { input = Console.ReadLine(); var sendBytes = Encoding.UTF8.GetBytes(input); //發布訊息到RabbitMQ Server channel.BasicPublish(exchangeName, routeKey, null, sendBytes); } while (Console.ReadKey().Key != ConsoleKey.Escape); } 最後在使用 channel.BasicPublish方法 將訊息推送給指定交換器，因為是走tcp所以將訊息轉換成二進制流 Consumer前面建立連接都大同小異 ConnectionFactory factory = new ConnectionFactory { UserName = &quot;guest&quot;, Password = &quot;guest&quot;, HostName = &quot;localhost&quot; }; string exchangeName = &quot;exchangeFanout&quot;; string queueName = &quot;FanoutQueue&quot;; string routeKey = string.Empty; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { channel.QueueBind(queueName, exchangeName, routeKey); //綁定一個消費者 EventingBasicConsumer consumer = new EventingBasicConsumer(channel); //接收到消息事件 consumer.Received += (ch, ea) =&gt; { var message = Encoding.UTF8.GetString(ea.Body); Console.WriteLine($&quot;Queue:{queueName}收到資料： {message}&quot;); channel.BasicAck(ea.DeliveryTag, false); }; channel.BasicConsume(queueName, true, consumer); Console.ReadKey(); } 值得一提的是 EventingBasicConsumer這個類別有一個建構子函數，把 channel 物件傳入產生一個消費者 EventingBasicConsumer consumer = new EventingBasicConsumer(channel); 在呼叫 EventingBasicConsumer.Received綁定接收訊息事件， 第一個參數是channel物件本身 第二個參數是 Message(訊息) 資訊 裡面有一個Body欄位可取得 傳送的二進制流資料 Demo為了簡單演示範例 我讓使用者輸入一個數字來跑迴圈，Producer 會把數字傳給Exchange並平均分配給所有consumer 本次有兩個 consumer 等待接收資訊，我們可以看到Fanout交換器不用指定RouteKey且把訊息平均分配到consumer上 程式碼: using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { //建立一個Queue channel.QueueDeclare(queueName, false, false, false, null); //建立一個Exchange channel.ExchangeDeclare(exchangeName, ExchangeType.Fanout, false, false, null); channel.QueueBind(queueName,exchangeName,routeKey); Console.WriteLine(&quot;\nRabbitMQ連接成功,如需離開請按下Escape鍵&quot;); Console.WriteLine(&quot;請輸入要傳輸的次數&quot;); string input = Console.ReadLine(); int times = 0; int.TryParse(input, out times); for (int i = 1; i &lt;= times; i++) { var sendBytes = Encoding.UTF8.GetBytes(i.ToString()); //發布訊息到RabbitMQ Server channel.BasicPublish(exchangeName, routeKey, null, sendBytes); } Console.WriteLine(); } 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/RabbitMQ-Fanout/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>RabbitMQ</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(SQL Server)Dynamic pivot 動態樞紐分析]]></title>
    <url>%2FDynamic-pivot%2F</url>
    <content type="text"><![CDATA[前言：之前有和大家分享使用CASE WHEN 搭配聚合函數實現樞紐分析 但今天如果我們要轉換成行的列希望是動態依照目前資料庫的欄位要處理呢? 我們可以使用Dynamic pivot Dynamic pivot核心概念其實是把我們要使用的pivot SQL`語法動態產生出來 程式碼CREATE TABLE T( userName VARCHAR(100), Price int, Dt DATE ); INSERT INTO T VALUES (&apos;Tom&apos;,100,&apos;2017-01-01&apos;); INSERT INTO T VALUES (&apos;Amy&apos;,200,&apos;2017-01-02&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,1311,&apos;2017-01-03&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,122,&apos;2017-03-01&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,111,&apos;2017-04-01&apos;); INSERT INTO T VALUES (&apos;Amy&apos;,232,&apos;2017-05-01&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,2312,&apos;2017-05-02&apos;); INSERT INTO T VALUES (&apos;Tom&apos;,23,&apos;2017-05-03&apos;); DECLARE @cols AS NVARCHAR(MAX), @query AS NVARCHAR(MAX); SET @SQL = STUFF((SELECT distinct &apos;,SUM(CASE WHEN Dt = &apos;&apos;&apos;+ CAST(Dt AS VARCHAR(10)) +&apos;&apos;&apos; THEN Price ELSE 0 END) AS &apos; + QUOTENAME(Dt) FROM T FOR XML PATH(&apos;&apos;), TYPE).value(&apos;.&apos;, &apos;NVARCHAR(MAX)&apos;) ,1,1,&apos;&apos;); SET @query = &apos;SELECT userName,&apos;+@cols+&apos; FROM T GROUP BY userName&apos; ; EXECUTE sp_executesql @query 因為範例我們使用 SQL SERVER 所以使用 FOR XML PATH 語法將我們 CASE WHEN pivot SQL 語法產生並把他附值給 @cols 變數 SET @cols = STUFF((SELECT distinct &apos;,SUM(CASE WHEN Dt = &apos;&apos;&apos;+ CAST(Dt AS VARCHAR(10)) +&apos;&apos;&apos; THEN Price ELSE 0 END) AS &apos; + QUOTENAME(Dt) FROM T FOR XML PATH(&apos;&apos;), TYPE).value(&apos;.&apos;, &apos;NVARCHAR(MAX)&apos;) ,1,1,&apos;&apos;) 因為Dt行會有重複的值,所以 distinct 來過濾 會產生如下的SQL語法 ,SUM(CASE WHEN Dt = &apos;2017-01-01&apos; THEN Price ELSE 0 END) AS [2017-01-01],SUM(CASE WHEN Dt = &apos;2017-01-02&apos; THEN Price ELSE 0 END) AS [2017-01-02],SUM(CASE WHEN Dt = &apos;2017-01-03&apos; THEN Price ELSE 0 END) AS [2017-01-03],SUM(CASE WHEN Dt = &apos;2017-03-01&apos; THEN Price ELSE 0 END) AS [2017-03-01],SUM(CASE WHEN Dt = &apos;2017-04-01&apos; THEN Price ELSE 0 END) AS [2017-04-01],SUM(CASE WHEN Dt = &apos;2017-05-01&apos; THEN Price ELSE 0 END) AS [2017-05-01],SUM(CASE WHEN Dt = &apos;2017-05-02&apos; THEN Price ELSE 0 END) AS [2017-05-02],SUM(CASE WHEN Dt = &apos;2017-05-03&apos; THEN Price ELSE 0 END) AS [2017-05-03] 在使用 STUFF 將第一個 , 給移除掉 sqlfiddle 最後在把要使用的表和前面組的Pivot query串起來. SET @cols = STUFF((SELECT distinct &apos;,SUM(CASE WHEN Dt = &apos;&apos;&apos;+ CAST(Dt AS VARCHAR(10)) +&apos;&apos;&apos; THEN Price ELSE 0 END) AS &apos; + QUOTENAME(Dt) FROM T FOR XML PATH(&apos;&apos;), TYPE).value(&apos;.&apos;, &apos;NVARCHAR(MAX)&apos;) ,1,1,&apos;&apos;); SET @query = &apos;SELECT userName,&apos;+@cols+&apos; FROM T GROUP BY userName&apos; ; SELECT @query; 最後產生： SELECT userName, SUM(CASE WHEN Dt = &apos;2017-01-01&apos; THEN Price ELSE 0 END) AS [2017-01-01], SUM(CASE WHEN Dt = &apos;2017-01-02&apos; THEN Price ELSE 0 END) AS [2017-01-02], SUM(CASE WHEN Dt = &apos;2017-01-03&apos; THEN Price ELSE 0 END) AS [2017-01-03], SUM(CASE WHEN Dt = &apos;2017-03-01&apos; THEN Price ELSE 0 END) AS [2017-03-01], SUM(CASE WHEN Dt = &apos;2017-04-01&apos; THEN Price ELSE 0 END) AS [2017-04-01], SUM(CASE WHEN Dt = &apos;2017-05-01&apos; THEN Price ELSE 0 END) AS [2017-05-01], SUM(CASE WHEN Dt = &apos;2017-05-02&apos; THEN Price ELSE 0 END) AS [2017-05-02], SUM(CASE WHEN Dt = &apos;2017-05-03&apos; THEN Price ELSE 0 END) AS [2017-05-03] FROM T GROUP BY userName 有了上面CASE WHEN pivot SQL 語法,最後只需把剩下要用到Table sql語句給組出來在使用 EXECUTE sp_executesql 動態呼叫SQL語法 sqlfiddle 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Dynamic-pivot/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Dynamic-Pivot</tag>
        <tag>Pivot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autofac + Interceptors(AOP) 動態代理]]></title>
    <url>%2FAutofac-AOP%2F</url>
    <content type="text"><![CDATA[Autofac 是個IOC容器 不懂IOC 參考 我之前寫的IOC(控制反轉)，DI(依賴注入) 深入淺出~~ 小弟之前有一個開源框架【C#】 AOP輕型框架 AwesomeProxy.Net 介紹使用 裡面簡單介紹 AOP核心概念和如何實作! Autofac 有寫一個 Autofac.Extras.DynamicProxy 把AOP和IOC容器融合的框架 在Autofac使用AOP 需要實現下面幾個步驟 本次範例我們從資料庫中撈取時間資料出來，並使用Thread.Sleep(5000)作出延遲，判斷時間是否前後一致。 第一步（定義攔截器）：我們撰寫一個快取的攔截器繼承IInterceptor 介面，並實現Intercep方法 其中 IInvocation參數有許多有用的資料 Arguments：傳入方法中的參數 InvocationTarget ：被代理物件 MethodInvocationTarget：被代理物件的呼叫方法資訊 Proxy：代理物件 Method：代理的呼叫方法資訊 ReturnValue：呼叫方法的回傳值 這幾個欄位是我們比較常用的資訊 public class TimeInterceptor : IInterceptor { private ITimeService _timeService; public TimeInterceptor(ITimeService s) { _timeService = s; } public void Intercept(IInvocation invocation) { var time = CallContext.GetData(&quot;time&quot;)?.ToString(); if (time == null) { //如果沒有快取 執行呼叫Service invocation.Proceed(); CallContext.SetData(&quot;time&quot;, invocation.ReturnValue); } else { //如果有快取直接取值 invocation.ReturnValue = time; } } } 他使用到 TimeService 模擬從資料庫中撈取資料出來 public interface ITimeService { string GetTime(); } public class TimeService : ITimeService { public string GetTime() { return DateTime.Now.ToString(&quot;MM/dd/yyyy hh:mm:ss&quot;); } } 第二步（標記攔截器）：使用Intercept標籤並帶入要攔截類別型態． [Intercept(typeof(TimeInterceptor))] public class Person : IPerson { public string SaySomething() { return DateTime.Now.ToLongTimeString(); } } public interface IPerson { string SaySomething(); } 第三步（註冊攔截器到容器中）：這邊有兩個小細節 如果是註冊介面使用EnableInterfaceInterceptors，註冊一般類別使用EnableClassInterceptors 註冊攔截器入容器 因為這個範例使用所以我們要呼叫EnableInterfaceInterceptors var builder = new ContainerBuilder(); builder.RegisterType&lt;TimeInterceptor&gt;(); //註冊攔截器 builder.RegisterType&lt;Person&gt;() .As&lt;IPerson&gt;() .EnableInterfaceInterceptors(); //註冊時間Service builder.RegisterType&lt;TimeService&gt;().As&lt;ITimeService&gt;(); return builder.Build(); 原始碼連結 小結Autofac + DynamicProxy 有一個很大優勢，是可以把要注入的抽象動作一起注入攔截器中 例如本次範例我們將ITimeService使用建構子注入法，注入至TimeInterceptor攔截器中 讓系統和寫法擁有更多更多的彈性 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Autofac-AOP/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IOC</tag>
        <tag>Autofac</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autofac (IOC)容器介紹]]></title>
    <url>%2FAutofac-introduce%2F</url>
    <content type="text"><![CDATA[前言：市面上有許多IoC容器 Ninject,Unity…. 雖然容器眾多但要解決的問題和概念是一樣 今天使用Autofac 介紹一下IoC容器 不了解 IoC 概念可參考 我之前寫 IOC(控制反轉)，DI(依賴注入) 深入淺出~~ Autofac是一個 Ioc 容器眼尖的讀者會發現我把Ioc跟容器這兩個字使用兩個不同顏色 原因是Autofac這個框架其實做到兩個概念. IoC(Inversion of Control) 管理物件的容器 Autofac框架幫我們實現可以管理物件生命週期並提供依賴注入相對應的物件中 為何使用Autofac在我們專案中?我們先來看看在專案中常使用的撰寫方式,我們需要讀取使用者資料 透過UserDao來幫我們完成. public UserService { private UserDao _userDao = new UserDao(); public UserModel GetUserById(string Id){ return _userDao.GetUserById(Id); } } _userDao物件跟依賴UserService，導致兩個狀況 UserDao物件掌控於 UserService,假如有其他類別也使用UserDao物件各自掌控UserDao物件,這導致許多不必要的資源浪費. 日後要替換讀取 GetUserById方式(從db改讀成其他地方 如API) 需要異動全部有建立UserDao的類別 我們可以使用IoC容器解決上面兩個問題 使用Autofac 容器一般容器有多種注入方式：建構子注入，屬性注入，參數注入 按照以下四個步驟 簡單使用Autofac 建立ContainerBuilder物件 註冊型別(可限制創建物件生命週期) 建立IContainer 取得我們需要的物件. 此範例使用建構子注入方式 //1.建立ContainerBuilder物件 ContainerBuilder builder = new ContainerBuilder(); //2.註冊型別(可限制創建物件生命週期) builder.RegisterType&lt;UserDao&gt;().As&lt;IUser&gt;(); //3.建立IContainer IContainer container = builder.Build(); //4.使用IContainer取得我們需要的物件. IUser user = container.Resolve&lt;IUser&gt;(); 我們新建一個IUser來給UserDao繼承當作解耦合點(介面可利於日後替換使用) public interface IUser{ UserModel GetUserById(string Id); } public UserService { private IUser _userDao; public UserService(IUser userdao){ _userDao = userdao; } public UserModel GetUserById(string Id){ return _userDao.GetUserById(Id); } } 可能還感受不到IoC容器威力，因為目前依賴的複雜度還沒有太大 目前模組依賴關係 如下UML圖 模組複雜程度像下圖 如果沒有容器幫我們做物件控制管理,想想就覺得可怕 ** 上圖是我Inovce SDK框架的UML圖 其中我們可以發現 ApiBase這個抽象類別 依賴於 IConfig介面(日後可能依賴更多其他物件或介面) ContainerBuilder builder = new ContainerBuilder(); builder.RegisterType&lt;AppsettingConfig&gt;().As&lt;IConfig&gt;().InstancePerRequest(); builder.RegisterGeneric(typeof(ApiBase&lt;&gt;)).PropertiesAutowired(); builder.RegisterType&lt;InvoiceApiFactory&gt;().InstancePerRequest(); 如果使用Autofac我們可不用擔心這些 只需要將被依賴的物件,介面註冊到容器中，剩下配對注入動作容器都會幫我們達成 已上面的例子來說：我只需要用 InvoiceApiFactory產生繼承ApiBase&lt;&gt;物件，使用IConfig將會被容器自動注入其中。 Autofac 常用三種注射方式. Constructor injection Property injection Method injection constructor injection Property injection Method injection 小結：系統越來越複雜越能表現IoC容器的優勢，如果系統沒那麼複雜其實也不一定要使用他﹐看情境如何 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Autofac-introduce/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IOC</tag>
        <tag>Autofac</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[橋接模式(BridgePattern)]]></title>
    <url>%2FBridge-Pattern%2F</url>
    <content type="text"><![CDATA[前言：目的：如果有兩大類模組是多對多的組合，如本次Smaple Code. Nick和Addidas 包包都有紅、藍、黃….或其他顏色 就可能呈現下面6種組合 Nick(紅) Nick(藍) Nick(黃) Addidas(紅) Addidas(藍) Addidas(黃) 如果此建立類別的話 可能情況如下面的UNL圖 類別數量 = 顏色數量 * 包包品牌數量 這樣會有兩個問題 隨著品牌和顏色增多，包包類別數量急速增長 (X = m*n)個 顏色我們可看做一個抽象 不應當和包包合在一起 其中的第二點我覺得最重要 這時候就很適合帶入我們的主角BridgePattern 範例介紹關係變成下圖UML 我們可以看到BagBsae去引用ColorBase 可以看到我們所需的子類別變成五個而已,重點是類別關係變得更有條理了，顏色和包包分開可調整性更大。 OOP有一個很重要的設計觀念 盡量用組合取代繼承，因為繼承耦合性遠大於組合！ 因為子類別繼承父類別，子類別無條件都擁有protect已上的方法或成員資料.這就會造成一個耦合性(使用繼承須看情況)，而A類別對於B類別進行組合就可達到繼承效果但不造成像繼承般的強耦合. 我們的背包一樣可擁有多種顏色，但耦合度跟類別關係變得更清晰了。 程式碼解說建立 BagBase 類別並將 ColorBase 當建構傳入(因為Bag需要上顏色) public abstract class BagBase { protected ColorBase color{ get; set; } public BagBase(ColorBase color) { this.color = color; } public abstract void GetBag(); } public abstract class ColorBase { public abstract string Color(); } 這邊我只介紹一種顏色和包包來當作範例,因為其他概念都一樣 public class AdidasBag : BagBase { public AdidasBag(ColorBase color) : base(color) { } public override void GetBag() { Console.WriteLine($&quot;It is Addidas Bag,Color is {color.Color()}&quot;); } } class ColorBlue : ColorBase { public override string Color() { return &quot;Blue&quot;; } } 建立 AdidasBag類別重載GetBag方法 ColorBlue類別重載Color方法 因為BagBase要傳入顏色GetBag就可幫包包上色. 使用如下外面看起來很合理乾淨. class Program { static void Main(string[] args) { AdidasBag nick = new AdidasBag(new ColorBlue()); nick.GetBag(); Console.ReadKey(); } } 實際案例前陣子在做一個Unity2D遊戲，遇到一組遊戲邏輯 一個人物要移動有分兩種移動方式 自動移動 玩家手動點擊移動 因為是2D遊戲 有 上下左右 四個方位移動,四個方位配上兩個移動方式,人物會有不一樣的移動邏輯. 這邊我貼上部分程式碼 建立一個 RoadActionBase裡面有三個必要屬性需要給 上下左右 實現 ArrowType 2D人物移動箭頭方向 OffSetPos 移動距離 PlayerDirction 這是一個Unity2D座標屬性 public abstract class RoadActionBase{ protected int _level; public RoadActionBase() { _level = SenceParamter.RoadCount; } public abstract ArrowType ArrowType { get; } public abstract int OffSetPos { get; } public abstract Vector2 PlayerDirction { get; } } UpRoadAction類別對於往上時的狀態做給值 public class UpRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Up; } } public override int OffSetPos { get { return -_level; } } public override Vector2 PlayerDirction { get { return Vector2.up; } } } DownRoadAction類別對於往下時的狀態做給值 public class DownRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Down; } } public override int OffSetPos { get { return _level; } } public override Vector2 PlayerDirction { get { return Vector2.down; } } } RightRoadAction類別對於往右時的狀態做給值 public class RightRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Right; } } public override int OffSetPos { get { return 1; } } public override Vector2 PlayerDirction { get { return Vector2.right; } } } LeftRoadAction類別對於往左時的狀態做給值 public class LeftRoadAction : RoadActionBase { public override ArrowType ArrowType { get { return ArrowType.Left; } } public override int OffSetPos { get { return -1; } } public override Vector2 PlayerDirction { get { return Vector2.left; } } } 建立一個 MoveBase 並將 RoadActionBase當作建構子傳入(內部邏輯有寫注解). 重點在於一個 IsWalkNext方法 提供Hock給子類別做實現,因為手動和自動移動邏輯不一樣. /// &lt;summary&gt; /// 橋接模式 /// &lt;/summary&gt; public abstract class MoveBase { protected PlayerController _player; protected int _level; protected float _Scape; public RoadActionBase RoadAction { get; protected set; } public MoveBase(RoadActionBase roadAction) { _player = PlayerController.Instance; _level = SenceParamter.RoadCount; _Scape = SenceParamter.Scape + SenceParamter.RoadHeigh; RoadAction = roadAction; } public virtual void Move(RoadContext currentRoad, RoadContext nextRoad) { //取得下一個位置 Vector2 nextPos = nextRoad.transform.localPosition; if (IsWalkNext(currentRoad, nextRoad, _player.targetPos, nextPos)) { //將下一個資料塞給當前玩家 _player.targetPos = nextPos; _player.RoadContext = nextRoad; _player.moveDirction = RoadAction.PlayerDirction; currentRoad.SetIsWalk(true); //加入等待轉換的地方 ReloadRoadController.Instance.AddRoadContext(currentRoad); } } protected abstract bool IsWalkNext(RoadContext currentRoad, RoadContext nextRoad, Vector3 targetPos, Vector3 nextPos); } TouchMove 類別重載 IsWalkNext實現自己的邏輯 public class TouchMove : MoveBase { public TouchMove(RoadActionBase roadAction) : base(roadAction) { } /// &lt;summary&gt; /// 判斷是否可以 前往下一個目標 /// &lt;/summary&gt; /// &lt;param name=&quot;currentRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetPos&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextPos&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override bool IsWalkNext(RoadContext currentRoad, RoadContext nextRoad, Vector3 targetPos, Vector3 nextPos) { ArrowType arrowType = RoadAction.ArrowType; //1.下一個道路要可以進去 //2.當前道路要可以出來 //3.必須為四周的道路 return arrowType.CanWalk(currentRoad.CanWalkOut) &amp;&amp; arrowType.CanWalk(nextRoad.CanWalkIn) &amp;&amp; CanMoveNextPos(targetPos, nextPos); } private bool CanMoveNextPos(Vector3 targetPos, Vector3 nextPos) { return ((int)Vector2.Distance(targetPos, nextPos)) % ((int)_Scape) == 0; } } AutoMove 類別重載 IsWalkNext實現自己的邏輯 public class AutoMove : MoveBase { public AutoMove(RoadActionBase roadAction) : base(roadAction) { } /// &lt;summary&gt; /// 判斷是否可以 前往下一個目標 /// &lt;/summary&gt; /// &lt;param name=&quot;currentRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextRoad&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetPos&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;nextPos&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override bool IsWalkNext(RoadContext currentRoad, RoadContext nextRoad, Vector3 targetPos, Vector3 nextPos) { //1.下一個道路要可以進去 //2.當前道路要可以出來 //3.必須為四周的道路 //4.步數必須大於0 return currentRoad.CurrentArrow.CanWalk(nextRoad.CanWalkIn) &amp;&amp; currentRoad.CurrentArrow.CanWalk(currentRoad.CanWalkOut) &amp;&amp; CanMoveNextPos(targetPos, nextPos) &amp;&amp; !nextRoad.IsChangeState &amp;&amp; GameModel.Step &gt;0; } private bool CanMoveNextPos(Vector3 targetPos, Vector3 nextPos) { return ((int)Vector2.Distance(targetPos, nextPos)) % ((int)_Scape) == 0; } } 上面程式碼最主要是跟大家分享移動方式和方位的關係,上下左右值和方位式固定,將此配上不同的移動方式有不一樣的邏輯. SourceCode 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Bridge-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>DesignPattern</tag>
        <tag>BridgePattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己Blog系列(二) github Setting]]></title>
    <url>%2Fhexo-github-setting%2F</url>
    <content type="text"><![CDATA[在Github這邊要先建立兩個Repository Blog Code Blog Hosting Blog Code這個Repository是利用Hexo cli樣板來撰寫Blog. 像我目前使用的MyBlog 建立完自己的Code Repository後. 將他clone到自己電腦上面. 執行下面幾個步驟 打開此Repository資料夾 打開CMD並進入此資料夾 利用NodeJS NPM 打 npm install hexo -g 就會開始下載 執行完第三步後再打Hexo init指令,安裝看建立Hexo將檔案. Blog Hosting在建立另一個Repository來當html blog靜態託管使用. 就像石頭使用isdaniel.github.io 執行下面幾個步驟 建立一個Repository 名子要取為 [username].github.io，其中的[username]是您Github帳號. 進入此Repository中，並進入Setting 確認是否已經成功將此Repository Hosting在你的Github page上如果成功呈現此圖 我們可以嘗試在這個Hosting Repository建立一個index.html 在上面打Hello would並commit push 在訪問https://[username].github.io/應該就可以看到Hello Would文字. 建立自己Blog系列(一) 介紹 Github (hosting) + Hexo (Blog) + Appveyor(CICD) 建立自己Blog系列(三) Hexo next theme 介紹 建立自己Blog系列(四) Appveyor 介紹 yaml. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/hexo-github-setting/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Blog</tag>
        <tag>Github</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立自己Blog系列(一) 介紹 Github (hosting) + Hexo (Blog) + Appveyor(CICD)]]></title>
    <url>%2Fgithub-hexo-appveyor%2F</url>
    <content type="text"><![CDATA[前文：網路上已經有許多Blog託管平台 例如:Google Blog，痞客邦….為何我還要自己寫這篇跟大家分享? 因為上面提供的平台固然好用，但我並無法100%的去修改我想要的樣式或版面. 如果我想要有100%彈性修改我的Blog我就必須建立自己的網站. 但要給別人Hosting需要另外花一筆費用… 就有本次系列文 Github (hosting) + Hexo (Blog) + Appveyor(CICD)． 這個搭配有幾個優點： 完全免費 使用MarkDown撰寫Blog就是爽. 練習使用CICD線上工具. 撰寫發布流程大概如下圖 流程解說： 使用Hexo樣板撰寫MarkDown Blog 寫完後commit和push至Github Blog Code Repository Appveyor(CI)線上工具會偵測到我們有code commit並執行後續Blog佈版動作 使用Hexo-cli將MarkDown build成html靜態檔案(因為github page只能Hosting靜態頁面) Appveyor(CI) commit並push到hosting Repository. 此流程的優點是只需在Code Repository上撰寫完Blog並commit就可以自動發佈到github page上. GitHub (Hosting)GitHub並創建一個名為username.github.io Repository，其中username是您在GitHub上的用戶名（或組織名稱）。 例如我的Github帳戶是isdaniel 就建立一個Repository 叫isdaniel.github.io 只要裡面有版控Html靜態頁面Github page 就可幫我們進行託管. https://isdaniel.github.io/ 這個網站的進入點在此Repository的index.html頁面. Note : GitHub有個設定，就是每個專案的gh-pages分支可以通過user-domain /項目名來訪問。 詳細資料 Hexo (Blog)Hexo 是一個快速、簡單且強大的網誌框架。Hexo 使用 Markdown（或其他渲染引擎）解析您的文章，並在幾秒鐘內，透過漂亮的主題產生靜態檔案 透過Hexo-cli可以簡單速建立一個blog page,而且Hexo社群活躍且文件支援中文. Hexo提供豐富的插件程式來給使用者,甚至您如果懂Js css Html也可建立自己的Blog樣式或自行擴充. Appveyor(CICD)appveyor是一個支援Winodws&amp;Linux相關的持續部屬服務 目前免費使用，可透過Github綁定Repository快速建立一套屬於自己的CICD流程. 小結這篇跟大家簡單介紹一下會使用到的工具和撰寫blog佈署流程. 日後會有其他篇文章來詳細說明細節. 建立自己Blog系列(二) github Setting 建立自己Blog系列(三) Hexo next theme 介紹 建立自己Blog系列(四) Appveyor 介紹 yaml. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/github-hexo-appveyor/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Blog</tag>
        <tag>Github</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#)委託delegate,Func,Action 解說系列(三)]]></title>
    <url>%2Fc-func-3%2F</url>
    <content type="text"><![CDATA[前文：在Func和Action泛型委託中 有 In , Out 兩個關鍵字 那到底是神麼意思呢? 讓我們一起看下去…. //Action delegate public delegate void Action&lt;in T&gt;(T obj); //fun delegate public delegate TResult Func&lt;in T, out TResult&gt;(T arg); 上面程式碼我列出Action和Func 委派方法各其中一個重載 我們可以發現到泛型中有關鍵字 in 和 out 這是代表神麼意思呢? 讓我們繼續看下去….. 解說：分享前先探討一個問題 泛型是否可以父類別指向子類別 public interface IGeneric&lt;T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //無法執行父類只向子類別 因為泛型預設是Invariance b = a; Console.ReadKey(); } } 上面範例程式很清楚知道無法編譯，那我要怎麼處理和解決的？ 第一種解法 使用 AS : public interface IGeneric&lt;T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //使用AS來轉型 b = a as IGeneric&lt;object&gt;; Console.ReadKey(); } } 第二種解法 在interface的泛型中使用 Out (今天要介紹的主角) //這裡使用out將T 解釋為Covariance public interface IGeneric&lt;out T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //在上面的泛型用out b = a; Console.ReadKey(); } } 三個重要名詞 Covariance，Contravariance，InvarianceMSDN中有解釋 此關鍵字 泛型中的共變數和反變數 Covariance(共變數) ： MSDN說明：可讓您使用比原本指定更多衍生的類型。您可以將 IEnumerable (在 Visual Basic 中為 IEnumerable(Of Derived)) 的執行個體指派給 IEnumerable 類型的變數簡單說明：泛型支援父類指向子類別 [泛型中使用out ] (支援泛型介面或泛型委派)如下面的範例: 因IGeneric&lt;out T&gt;所以下面a付值給b就不需轉型 //這裡使用out將T 解釋為Covariance public interface IGeneric&lt;out T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public class A { } class Program { static void Main(string[] args) { IGeneric&lt;object&gt; b = new Base&lt;object&gt;(); IGeneric&lt;A&gt; a = new Base&lt;A&gt;(); //在上面的泛型用out b = a; Console.ReadKey(); } } Contravariance(反變數) MSDN說明：可讓您使用比原本所指定更泛型 (較少衍生) 的類型。您可以將 IEnumerable (在 Visual Basic 中為 IEnumerable(Of Base)) 的執行個體指派給IEnumerable 類型的變數。 簡單說明：可將父類物件引用賦予給子類別 [泛型中有in]如下範例： 因IComparer&lt;in T&gt; 所以子類可以取得父類的引用 //這裡使用in將T 解釋為Contravariance public interface IGeneric&lt;in T&gt; { } public class Base&lt;T&gt; : IGeneric&lt;T&gt; { } public abstract class Shape { public virtual double Area { get { return 0; } } } public class Square : Shape { private double r; public Square(double radius) { r = radius; } public double Radius { get { return r; } } public override double Area { get { return r * r; } } } public class Circle : Shape { private double r; public Circle(double radius) { r = radius; } public double Radius { get { return r; } } public override double Area { get { return Math.PI * r * r; } } } public class ShapeAreaComparer : IComparer&lt;Shape&gt; { int IComparer&lt;Shape&gt;.Compare(Shape a, Shape b) { if (a == null) return b == null ? 0 : -1; return b == null ? 1 : a.Area.CompareTo(b.Area); } } class Program { static void Main(string[] args) { //泛型[形狀類別(基類)] IGeneric&lt;Shape&gt; b = new Base&lt;Shape&gt;(); //泛型[圓形類別(子類)] IGeneric&lt;Circle&gt; a = new Base&lt;Circle&gt;(); //子類可以取得父類引用 a = b; Console.ReadKey(); } } Invariance 只能該類別指向該類別一般泛型預設就是這個 總結：Func 泛型委派的最後一個泛型類型參數會指定委派簽章中的傳回值類型 Covariance (共變數) (out 關鍵字) 泛型支援父類指向子類別 Contravariant (反變數) (in 關鍵字) 泛型子類可以取得父類的引用 Invariance 一般泛型預設就是這個 泛型中的共變數和反變數.aspx) out (generic modifier) (C# Reference) 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/c-func-3/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Delegate</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Func</tag>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#) 委託delegate,Func,Action 解說系列(二)]]></title>
    <url>%2Fc-func-2%2F</url>
    <content type="text"><![CDATA[前文：這個文章和大家分享解說 Func&lt;&gt;和Action&lt;&gt; 最後帶著大家來實現自己的Linq Where 先來看 Func&lt;&gt; ，Action&lt;&gt;原始定義 我們發現Func&lt;&gt; ，Action&lt;&gt; 其實本質就是委託 ，雖然有十幾個重載 但大同小異 public delegate TResult Func&lt;out TResult&gt;(); public delegate void Action&lt;in T&gt;(T obj); Func固定最後一個泛型參數為方法回傳值，其餘是傳入參數 public delegate TResult Func&lt;in T, out TResult&gt;(T arg); 解說Func：宣告一個Func&lt;Person,string&gt;委託 _thunkCheckAge_thunkCheckAge委託指向CheckAge方法執行_thunkCheckAge委託 (執行CheckAge方法) public class Person { public int Age { get; set; } public string Name { get; set; } } /// &lt;summary&gt; /// 年紀超過10歲算老人 /// &lt;/summary&gt; /// &lt;param name=&quot;person&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string CheckAge(Person person) { string result = &quot;年紀剛剛好&quot;; if (person.Age &gt;= 10) { result = &quot;老人&quot;; } return result; } static void Main(string[] args) { //Init一個Person物件 Person p = new Person() { Age = 10, Name = &quot;tom&quot; }; #region Func //宣告一個Func&lt;Person,string&gt;委託 _thunkCheckAge Func&lt;Person, string&gt; _thunkCheckAge; //_thunkCheckAge委託指向CheckAge方法 _thunkCheckAge = new Func&lt;Person, string&gt;(CheckAge); //執行_thunkCheckAge委託 (執行CheckAge方法) string result = _thunkCheckAge(p); //最後將結果顯示出來 Console.WriteLine(result); #endregion Console.ReadKey(); } 解說 Action：Action這個委託是Void，傳入參數型態是由泛型來決定 public delegate void Action&lt;in T&gt;(T obj); 宣告一個Action&lt;Person&gt;委託的 _thunkPerson物件將CallPersonInfo方法 賦予給_thunkPerson執行_thunkPerson (就是執行CallPersonInfo方法) public class Person { public int Age { get; set; } public string Name { get; set; } } static void Main(string[] args) { //宣告_thunkPerson為Action&lt;Person&gt;委託 //此Action傳入參數是Person由泛型來決定 Action&lt;Person&gt; _thunkPerson; //Init一個Person物件 Person p = new Person() { Age = 10, Name = &quot;tom&quot; }; //將CallPersonInfo方法 賦予給_thunkPerson _thunkPerson = new Action&lt;Person&gt;(CallPersonInfo); //執行_thunkPerson (就是執行CallPersonInfo方法) _thunkPerson(p); Console.ReadKey(); } public static void CallPersonInfo(Person person) { Console.WriteLine($&quot;Age:{person.Age} Name:{person.Name}&quot;); } 小總結：Action和Func差別是 Action是void不回傳值得委託 Func是有回傳值得委託 有了以上的基礎，我們就來實現我們自己的Linq Where 和 Linq Select 先來分析 Where 方法簽章 public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate) 分析：如果我要找一個大於10歲的人,撰寫一般Linq Where 如下在where中塞選此集合的條件，那我要怎麼自己實現呢？ 重點在於[執行塞選條件]這個動作 List&lt;Person&gt; pList = new List&lt;Person&gt;() { new Person() { Age=100,Name=&quot;daniel&quot;}, new Person() { Age=20,Name=&quot;Tom&quot; }, new Person() { Age = 10,Name = &quot;Amy&quot;}, new Person() { Age=5,Name = &quot;rjo&quot;} }; pList.Where(per =&gt; per.Age &gt; 10); 以下是實現自己的Where語法 有沒有很簡單! 重點在if(where(item)) 判斷物件是否符合條件，如符合就回傳此物件 public static class LinqExtension { /// &lt;summary&gt; /// 自訂一個Where /// &lt;/summary&gt; /// &lt;typeparam name=&quot;TSource&quot;&gt;&lt;/typeparam&gt; /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;where&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static IEnumerable&lt;TSource&gt; MyWhere&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source ,Func&lt;TSource, bool&gt; where) { foreach (var item in source) { if (where(item)) { yield return item; } } } } 總結：委託把不確定的動作，轉移給呼叫端來撰寫。 而不是寫死在程式中 上面的MyWhere挖了一個洞，關於判斷是否符合條件，給呼叫端實現 雖然在裡面一樣是一個一個判斷是否符合條件，符合再返回，但利用委託和泛型就可以對於任何條件和任何型別來做比較 大大提升了程式效率 原始碼範例 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/c-func-2/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Delegate</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Func</tag>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#)委託delegate,Func,Action 解說系列(一)]]></title>
    <url>%2Fc-func-1%2F</url>
    <content type="text"><![CDATA[前文：成為.Net高手Delegate 是必備武器之一 今天小弟和大家分享我所認知的Delegate 一開始我們先來看看Delegate到底是不是類別 範例解說：宣告一個 voidDelegate 委託 12345678public delegate void voidDelegate();static void Main(string[] args)&#123; Console.WriteLine($"delegate is class? &#123;typeof(voidDelegate).IsClass&#125;"); Console.ReadKey();&#125; 執行結果:Yes 委託是一個特別的類別 但委託物件方式很特別 他在宣告時必須傳入[建構子參數] 而建構子參數是[方法] 我們宣告一個委託 傳入兩個Int參數 回傳Int public delegate int calcInt(int arg1,int arg2); 使用如下 new 一個 calcInt 並傳入建構子參數 add方法 之後就可以把calcint當作方法來使用 123456789calcInt calcint = new calcInt(add);var result1 = calcint(5,5);Console.WriteLine(result1);//方法static int add(int a, int b)&#123; return a + b;&#125; 或是 使用.net提供的 語法糖 如下 1234calcInt calcint1 = (a,b) =&gt; &#123; return a + b; &#125;;var result2 = calcint1(5, 5);Console.WriteLine(result2);(a,b) =&gt; &#123; return a + b; &#125;; 編譯器會動態幫我們產生一個方法。 委託就這樣嗎?! 進階的用法第一 : 宣告一個類別[計算者]，建構子參數是一個泛行List在類別中宣告Calc委託，在Excute方法中我們直接回傳執行Calc結果 123456789101112131415public class Calculator&lt;T&gt; where T : struct&#123; public delegate T Calc(IList&lt;T&gt; list); IList&lt;T&gt; _container; public Calculator(IList&lt;T&gt; container) &#123; _container = container; &#125; public T Excute(Calc C) &#123; return C(_container); &#125;&#125; 使用方法如下：宣告一個物件Calculator傳入建構子參數List 重點:我們可以在Client端決定如何使用此方法 12345678910111213141516List&lt;int&gt; i_List = new List&lt;int&gt;()&#123; 1,3,5,7,9&#125;;Calculator&lt;int&gt; calculator = new Calculator&lt;int&gt;(i_List);int i_add = calculator.Excute((list) =&gt; list.Sum());int i_multi = calculator.Excute((list) =&gt;&#123; int totle = 1; foreach (var i in list) &#123; totle *= i; &#125; return totle;&#125;);Console.WriteLine($"add:&#123;i_add&#125; multi:&#123;i_multi&#125;"); 總結:如上面程式碼 我們可在Client中決定對List集合做操作(加,減,乘,除) ，而不是一開始就寫死在類別中，降低了類別方法和Client的耦合 Delegate可以把方法實作的權利移交給Clinet端 原始碼範例 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/c-func-1/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>Delegate</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Func</tag>
        <tag>Delegate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(C#)裝飾者模式(Decorator Pattern)]]></title>
    <url>%2FDecorator-Pattern%2F</url>
    <content type="text"><![CDATA[裝飾者模式是一個很精美且優雅的模式 本篇範例 文字內容-&gt;AES加密-&gt;Zip檔附加密碼-&gt;輸出儲存 情境有個需求要做 文字內容-&gt;壓縮zip(附上密碼)-&gt;輸出儲存又改成… 文字內容-&gt;AES加密-&gt;輸出儲存需求又改成…. 文字內容-&gt;AES加密-&gt;Zip檔附加密碼-&gt;輸出儲存 可發現需求一直在對於文字內容操作順序做變化,但他們核心離不開對於文字內容的操作 這種情境很適合來使用 [裝飾者模式] 裝飾者模式 有兩個主要角色 被裝飾物件(Decorated) &amp; 裝飾物件(Decorator) 被裝飾物件(Decorated)就像蛋糕的一樣, 裝飾物件(Decorator)就是上的水果,奶油,巧克力…等等裝飾物品 一般先有蛋糕被裝飾物件(Decorated),後再將裝飾物品加上去裝飾物件(Decorator) 被裝飾物件(Decorated)如下圖 蛋糕的原型 圖片來源 將物件有效的往上附加職責,不動到內部的程式碼, 在原來職責上附加額外的職責 裝飾者模式運作就像 俄羅斯娃娃一樣 一層包一層 圖片來源 第一步 先找尋他們共同裝飾東西,因為是讀寫檔案 所以我們可以對於Byte下手 先做出 讀 跟 寫 介面簽章當作裝飾動作的統一介面 123456public interface IProcess&#123; byte[] Read(string path); void Write(string writePath, byte[] buffer);&#125; 在創建一個 ProcessBase 給日後裝飾物品(Decorator)來繼承 12345678910111213141516public abstract class ProcessBase : IProcess&#123; /// &lt;summary&gt; /// 儲存被裝飾的物件 /// &lt;/summary&gt; protected IProcess _process; public abstract byte[] Read(string path); public abstract void Write(string writePath, byte[] buffer); public virtual void SetDecorated(IProcess process) &#123; _process = process; &#125;&#125; 有兩點特別說明 protected IProcess _process; 儲存被裝飾的物件由 SetDecorated 方法來設置被裝飾的物件 就像俄羅斯娃娃只包裹一個娃娃,不管被包裹娃娃之前包含哪些娃娃 第二步 創建被裝飾物品(Decorated) 因為是檔案我們直接使用 File.ReadAllBytes 讀 檔案 File.WriteAllBytes 寫 檔案 123456789101112131415/// &lt;summary&gt;/// 讀取檔案/// &lt;/summary&gt;public class FileProcess : IProcess&#123; public byte[] Read(string path) &#123; return File.ReadAllBytes(path); &#125; public void Write(string writePath, byte[] buffer) &#123; File.WriteAllBytes(writePath, buffer); &#125;&#125; 第三步 創建裝飾物品(Decorator) 這次主要裝飾物品有兩個 加壓解壓ZIP檔 加解密 加密裝飾器繼承ProcessBase並按照加解密重寫 Write和 read 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// &lt;summary&gt;/// Aes 加密裝飾器/// &lt;/summary&gt;public class AESCrypProcess : ProcessBase&#123; private AesCryptoServiceProvider aes; public string AESKey &#123; get; set; &#125; = "1776D8E110124E75"; public string AESIV &#123; get; set; &#125; = "B890E7F6BA01C273"; public AESCrypProcess() &#123; aes = new AesCryptoServiceProvider(); aes.Key = Encoding.UTF8.GetBytes(AESKey); aes.IV = Encoding.UTF8.GetBytes(AESIV); &#125; public override byte[] Read(string path) &#123; byte[] encryptBytes = _process.Read(path); return DecryptData(encryptBytes); &#125; /// &lt;summary&gt; /// 進行解密 /// &lt;/summary&gt; /// &lt;param name="encryptBytes"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private byte[] DecryptData(byte[] encryptBytes) &#123; byte[] outputBytes = null; using (MemoryStream memoryStream = new MemoryStream(encryptBytes)) &#123; using (CryptoStream decryptStream = new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Read)) &#123; MemoryStream outputStream = new MemoryStream(); decryptStream.CopyTo(outputStream); outputBytes = outputStream.ToArray(); &#125; &#125; return outputBytes; &#125; /// &lt;summary&gt; /// 裝飾者呼叫方法 /// &lt;/summary&gt; /// &lt;param name="path"&gt;&lt;/param&gt; /// &lt;param name="data"&gt;&lt;/param&gt; public override void Write(string path, byte[] data) &#123; byte[] outputBytes = EncryptData(data); _process.Write(path, outputBytes); &#125; private byte[] EncryptData(byte[] data) &#123; byte[] outputBytes = null; using (MemoryStream memoryStream = new MemoryStream()) &#123; using (CryptoStream encryptStream = new CryptoStream(memoryStream, aes.CreateEncryptor(), CryptoStreamMode.Write)) &#123; MemoryStream inputStream = new MemoryStream(data); inputStream.CopyTo(encryptStream); encryptStream.FlushFinalBlock(); outputBytes = memoryStream.ToArray(); &#125; &#125; return outputBytes; &#125;&#125; 這次讀寫zip使用 SharpZipLib 開源第三方插件 ZIP裝飾器繼承ProcessBase並按照加解密重寫 Write和 read 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/// &lt;summary&gt;/// 讀取Zip使用/// &lt;/summary&gt;public class ZipProcess : ProcessBase&#123; public string PassWord &#123; get; set; &#125; public string FileName &#123; get; set; &#125; public override byte[] Read(string path) &#123; byte[] buffer = _process.Read(path); return ZipReader(path, buffer); &#125; public override void Write(string writePath, byte[] data) &#123; byte[] buffer = ZipWriter(data); _process.Write(writePath, buffer); &#125; private byte[] ZipWriter(byte[] buffer) &#123; using (MemoryStream outputMemStream = new MemoryStream()) using (ZipOutputStream zipStream = new ZipOutputStream(outputMemStream)) using (MemoryStream memStreamIn = new MemoryStream(buffer)) &#123; zipStream.SetLevel(9); ZipEntry newEntry = new ZipEntry(FileName); newEntry.DateTime = DateTime.Now; zipStream.Password = PassWord; zipStream.PutNextEntry(newEntry); StreamUtils.Copy(memStreamIn, zipStream, new byte[4096]);//將zip流搬到memoryStream中 zipStream.CloseEntry(); zipStream.IsStreamOwner = false; zipStream.Close(); return outputMemStream.ToArray(); &#125; &#125; /// &lt;summary&gt; /// 讀取zip檔 /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;zip檔案byte&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private byte[] ZipReader(string filePath, byte[] buffer) &#123; byte[] zipBuffer = default(byte[]); using (MemoryStream memoryStream = new MemoryStream(buffer)) &#123; memoryStream.Seek(0, SeekOrigin.Begin); var zip = new ZipFile(memoryStream); zip.Password = PassWord; using (MemoryStream streamWriter = new MemoryStream()) &#123; byte[] bufferReader = new byte[4096]; var file = zip.GetEntry(FileName); //設置要去得的檔名 //如果有檔案 if (file != null) &#123; var zipStream = zip.GetInputStream(file); StreamUtils.Copy(zipStream, streamWriter, bufferReader); zipBuffer = streamWriter.ToArray(); &#125; &#125; &#125; return zipBuffer; &#125;&#125; 上面就把我們要用的裝飾物品 (備料) 準備完成 第四步 創建使用(開始擺盤) 創建一個 DecorateFactory 來當生產 裝飾產品的工廠 建構子傳入一個 被裝飾的物件(FileProcess) 之後可依照喜好一直疊加 裝飾物品(ZipProcess,AESCrypProcess…) 123456789101112131415161718192021public class DecorateFactory&#123; IProcess _original; public DecorateFactory(IProcess original) &#123; _original = original; &#125; public DecorateFactory SetProcess(ProcessBase process) &#123; process.SetDecorated(_original); _original = process; return this; &#125; public IProcess GetProcess() &#123; return _original; &#125;&#125; 裝飾者模式 裝飾的順序是很重要的 為了方便讀者閱讀 我使用小畫家畫出 讀寫順序 如下圖 使用就可很清晰來用 DecorateFactory來創建裝飾流程factroy.GetProcess(); 方法取得完成後的產品 在簡單呼叫讀和寫方法 1234567891011121314151617string filePath = @"C:\Users\daniel.shih\Desktop\test.zip";string content = $"你好 123456 12@()!@ &#123;Environment.NewLine&#125; fsfd嘻嘻哈哈!!";//設置初始化的被裝飾者DecorateFactory factroy = new DecorateFactory(new FileProcess());//設置裝飾的順序factroy.SetProcess(new AESCrypProcess()) .SetProcess(new ZipProcess() &#123; FileName = "1.txt",PassWord ="1234567"&#125;);IProcess process = factroy.GetProcess();byte[] data_buffer = Encoding.UTF8.GetBytes(content);process.Write(filePath, data_buffer);byte[] buffer = process.Read(filePath);Console.WriteLine(Encoding.UTF8.GetString(buffer)); 日後不管需求是改成 文字內容-&gt;壓縮zip(附上密碼)-&gt;輸出儲存 文字內容-&gt;AES加密-&gt;輸出儲存 文字內容-&gt;AES加密-&gt;Zip檔附加密碼-&gt;輸出儲存 還是….. 我們都不怕因為我們把各種操作封裝和多態 各個模組間都是獨立的很好映證 高內聚低耦合 的設計原則 小結: 裝飾者模式是一個很精美且優雅的模式 希望這篇文章可讓讀者對於此模式有更加了解 GitHub範例連結 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/Decorator-Pattern/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>DesignPattern</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Design-Pattern</tag>
        <tag>Decorator-Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【深入淺出】Base編碼 (Base64為例子)]]></title>
    <url>%2Fbase64-principle%2F</url>
    <content type="text"><![CDATA[Base家族以Base64最為出名，這邊會用Base64編碼來做介紹 寫網站應該都用過Base64但你對於他的原理了解嗎? 此篇和大家分享Base家族的秘密 用途：Base64主要用途是某些系統中只能使用ASCII字符，為了避免某些機器無法識別我們傳輸資料 Base64就是用來將非ASCII字符的數據轉換成ASCII字符的一種方法。 base64特別適合在http，mime協議下快速傳輸數據(例如我們常使用 Email) 它使用下面表中所使用的字符與編碼。 圖片連結 Base64 中的64其實是有含意的 他會把資料轉成 a~z (26) A~Z (26) 0~9 (10) + (1) / (1) 上面編碼成上面五種種類字元的資料 64就是把所以可用字元數量總合 64 = 26+26+10+1+1 原理：那Base64是怎麼將資料轉成a~z，A~Z，0~9，/，+的組合呢? 最終目標想要把資料轉成在Ascii Code 0 ~ 127 的字元 Base64 wiki說明 轉換的時候，將3位元組的資料，先後放入一個24位元的緩衝區中，先來的位元組占高位。資料不足3位元組的話，於緩衝區中剩下的位元用0補足。每次取出6位元，按照其值選擇ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字元作為編碼後的輸出，直到全部輸入資料轉換完成。 這邊有幾個重點 會把資料分割成每 3 byte (24bit) 為單位 資料不足3 byte的話，於緩衝區中剩下的bit用0補足 計算出來值依照下表索引轉換成Base64可用字元 直到全部輸入資料轉換完成 下面有個例子方便大家了解！ 實際例子：先來看看下面的例子： BC 用 Base64 轉成 QkM= 過程． 將字元轉換成二進制 B (66) = 0 1 0 0 0 0 1 0 C (67) = 0 1 0 0 0 0 1 1 資料不足3 byte的話，於緩衝區中剩下的bit用0補足，所以我們將第三個Byte資料用0補齊 最左邊數字為頭，用每組６bit來重新分組轉換後的資料. 將轉換後的資料依照Base64轉換表 轉換成Base64字元. Base64編碼 Q k M =範例來自於Wiki = 並不是`Base64的字元 而是代表補0使用的雖然Base64在最後常常會看到 = 或 == 結尾，那是因為遇到要補位的情況.如果字元剛剛好滿的狀態(3 bytes)就不會看到 = 符號 範例來自於Wiki 小結：Base64分享到這邊！ 其實Base家族除了64還有 Base32,Base16 .... 你也可以自行依照上面算法建立自己 Base 編碼. Base32 : a~z , 2~7 原理其實都是一樣的 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/base64-principle/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>WebDesign</tag>
        <tag>Base64</tag>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(SQL Server) CTE RECURSIVE (遞迴)製作月曆]]></title>
    <url>%2FCTE-RECURSIVE%2F</url>
    <content type="text"><![CDATA[如果要製作月報…但只有給起訖日 要產生出如下的列表 要怎麼辦… 第一個想到的解法 會使用 WHILE + [暫存表]迴圈遍歷 把每個月新增入暫存表中 程式碼如下: 123456789101112131415161718192021222324252627282930313233DECLARE @t TABLE( StartDate DATETIME, EndDate DATETIME);INSERT INTO @t ( StartDate, EndDate )VALUES ( '2017/01/01', -- StartDate - datetime '2018/01/01' -- EndDate - datetime );--宣告一個起始時間變數DECLARE @TempStartDate DATETIMEDECLARE @TempEndDate DATETIME--設置變數 最小時間(起始時間) 和 最大時間SELECT @TempStartDate = StartDate,@TempEndDate=EndDate FROM @tCREATE TABLE #TEMP(Dates DATETIME)WHILE(@TempStartDate &lt; @TempEndDate)BEGIN --將資料新增入暫存表 INSERT INTO #TEMP (Dates) VALUES (@TempStartDate) --每跑一次迴圈就加一個月 SELECT @TempStartDate = DATEADD(MONTH,1,@TempStartDate)END SELECT * FROM #TEMPDROP TABLE #TEMP 但這個解法雖然簡單..但程式碼又臭又長.. Q: 有沒有更好看的解法又可達成目的呢? ANS: 有!! 就是本次主角 CTE 遞迴 話不多說先貼上程式碼 123456789101112131415161718192021222324DECLARE @t TABLE( StartDate DATETIME, EndDate DATETIME);INSERT INTO @t ( StartDate, EndDate )VALUES ( '2017/01/01', -- StartDate - datetime '2018/01/01' -- EndDate - datetime );;WITH CTE (Dates,EndDate) AS( SELECT StartDate AS Dates,EndDate AS EndDate FROM @t UNION ALL --注意這邊使用 UNION ALL SELECT DATEADD(MONTH,1,Dates),EndDate FROM CTE WHERE DATEADD(MONTH,1,Dates) &lt; EndDate --判斷是否目前遞迴月份小於結束日期)SELECT CTE.DatesFROM CTE 接下來解說 CTE遞迴原理 : 可看到CTE中最主要執行四個步驟 取得初始結果集並(錨點結果集) T(0) 將T(0)結果集進行判斷是否滿足 DATEADD(MONTH,1,Dates) &lt; EndDate 不滿足繼續走,並產生T(1)結果集,依照此結果集繼續往下執行 在執行上面的2步驟 直到滿足條件 T(0),T(1)…..T(n) 傳回結果集。將之前所有產生結果集 UNION ALL。 使用CTE遞迴必須使用UNION ALL 最後CTE結果集就會呈現如下^^ 補充 oracle解法 同場加映!! 如果使用 oracle 可使用 connect by 很簡便取得日曆 123456789101112CREATE TABLE T( StartDate DATE, EndDate DATE);INSERT INTO T( StartDate, EndDate ) VALUES (date '2017-01-01',date '2018-01-01');select add_months(trunc(StartDate,'mm'),level - 1 ) "Date" from T connect by trunc(EndDate,'mm') &gt;= add_months(trunc(StartDate,'mm'),level) order by 1 http://sqlfiddle.com/#!4/75cd9/14 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/CTE-RECURSIVE/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Tsql</tag>
        <tag>MSSql</tag>
        <tag>CTE</tag>
        <tag>UNION ALL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【財政部查詢類電子發票API】框架解說 C#]]></title>
    <url>%2FInvoiceTW-Framework%2F</url>
    <content type="text"><![CDATA[小弟之前有分享過串接【財政部查詢類電子發票API】小框架使用文 使用文連結 快速使用財政部電子發票API 使用 C#串接文件下載 電子發票查詢API 1.4.4程式原始碼連結 這次想跟大家分享我做出此框架的歷程.. 框架目的：希望可以做出方便日後維護擴展的API。 串接API時發現他們有幾個共同之處 API請求參數名稱需降冪排列 請求參數最後會加上簽章 都有時間戳記 回應資料格式都是Json 都是使用Http (Get or Post) 我就想到可以使用 工廠模式來實作這系列產品 (工廠模式主要是切割產品的使用和生產) 產品解說因為他們都有共同的能力傳入一組參數回傳一串Json 我就先寫出一個API共同的介面簽章 IApiRunner這個介面為基礎來撰寫後面的程式碼 123456789101112/// &lt;summary&gt;/// 執行api的介面/// &lt;/summary&gt;public interface IApiRunner&#123; /// &lt;summary&gt; /// 執行api /// &lt;/summary&gt; /// &lt;param name="model"&gt;傳入的參數&lt;/param&gt; /// &lt;returns&gt;回傳資料&lt;/returns&gt; string ExcuteApi(object model);&#125; 我在中間多一個抽象泛型類別 ApiBase (用泛型是為了給子類決定傳入參數的Model)原因: 中間使用泛型抽象類別讓子類決定要傳入哪組參數 可以將一些共通的方法寫在裡面 子類別只需要知道要提供哪些動作，所以在ApiBase中提供兩個方法來override 請求URL 目前預設讀取Config (GetApiURL) 參數的組合 (SetParamter) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// 子類繼承提供參數/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;protected abstract string SetParamter(T model);/// &lt;summary&gt;/// 取得api的Url路徑/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;protected virtual string GetApiURL()&#123; string apiname = this.GetType().Name; if (!ConfigurationManager.AppSettings.AllKeys.Contains(apiname)) &#123; throw new Exception(string.Format("請確認Config的appsetting有無此參數 &#123;0&#125;", apiname)); &#125; return ConfigurationManager.AppSettings[apiname];&#125;/// &lt;summary&gt;/// 執行Api/// &lt;/summary&gt;/// &lt;param name="model"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public virtual string ExcuteApi(object model)&#123; //建立所需參數 string result = string.Empty; string postData = string.Empty; string posturl = GetApiURL(); var data = ObjectToModel(model); //取得加密後的參數 postData = GetInvoiceParamter(SetParamter(data)); try &#123; ServicePointManager.ServerCertificateValidationCallback = HttpTool.ValidateServerCertificate; result = HttpTool.HttpPost(posturl, postData); &#125; catch (Exception ex) &#123; result = GetSysErrorMsg(); &#125; return result;&#125; 目前產品部分已經建構好了。 工廠解說工廠部分這次我選擇使用【反射方式來實現工廠】 工廠類別 MoblieInvoiceApiFactroy 其實最主要是使用GetInstance方法12345678910111213141516/// &lt;summary&gt;/// 提供api的工廠/// Model和Api命名要相關/// 例如:testModel 對 testApi/// &lt;/summary&gt;/// &lt;param name="model"&gt;Model參數&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static IApiRunner GetInstace(object model)&#123; if (model == null) throw new ArgumentNullException("不能傳空的參數"); string modelName = model.GetType().Name; return (IApiRunner)Activator.CreateInstance (GetInstanceType(model), null);&#125; 其中我把決定使用哪個組API的決定權交給Model並寫在標籤上(Attirbute)在執行時他可獲取此參數Model所註冊參數的型別，來動態產生產品 123456789101112131415/// &lt;summary&gt;/// 反射取得綁定Model上綁定的API型別/// &lt;/summary&gt;/// &lt;param name="model"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static Type GetInstanceType(object model)&#123; var modelType = model.GetType(); var attr = modelType.GetCustomAttribute(typeof(ApiTypeAttribute)) as ApiTypeAttribute; if (attr != null) &#123; return GetApiType(attr); &#125; throw new Exception("Model尚未賦予ApiTypeAttribute");&#125; EX:查詢中獎號碼API Model 可以很清楚知道這個Model隸屬於哪個API 12345[ApiType(ApiType = typeof(QryWinningListApi), MockApiType = typeof(QryWinningListMockApi))]public class QryWinningListModel&#123; public string invTerm &#123; get; set; &#125;&#125; 值得一提的是它有多一個MockApiType 為什麼會有這個?原因：如果財政部伺服器連不到我們可以改成假資料或是模擬資料(讀取資料庫或是其他方式)。 以上就是此框架的解說 外部只需要呼叫工廠的GetInstance方法並傳入參數Model就會回傳相對應的產品API類別這樣就降低執行和產生產品的耦合度，因為外部不是直接強耦合於Api類別而是透過工廠日後如需增加API產品只需擴展新的類別 符合OCP(開放封閉原則)已經達到目的：希望可以做出方便日後維護擴展的API。 Ps:這次我除了使用 工廠模式,也有用到樣板模式,代理模式 剩下兩個模式讓大家來找看看吧^^ 一般來說很少只用一個模式就可以解決一個問題的，通常都是配合使用 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/InvoiceTW-Framework/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>SourceCode</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Design-Pattern</tag>
        <tag>Open-Source</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C#】 AOP輕型框架 AwesomeProxy.Net 介紹使用]]></title>
    <url>%2FAwesomeProxy-Net%2F</url>
    <content type="text"><![CDATA[今天和大家分享AwesomeProxy.Net小弟開源AOP輕型框架 簡單介紹 AOP (Aspect-Oriented Programming)AOP 是 OOP(物件導向)一個變化程式撰寫思想。（非取代OOP而是擴充） 導入AOP幫助： 可幫我們分離核心邏輯跟非核心邏輯代碼，很好降低模組間耦合性，已便日後擴充。 非核心邏輯代碼像：(日誌記錄，性能統計，安全控制，事務處理，異常處理等代碼從業務邏輯代碼中劃分出來) 例如下圖： 原本寫法把寫日誌相關程式寫入，業務邏輯方法中。導致此方法非單一職則。我們可以把程式重構改寫成(右圖)，將寫日誌方法抽離出來更有效達成模組化。 經典例子: Asp.Net MVC中Contoller，Action過濾器(FilterAttribute) AwesomeProxy.Net介紹：AwesomeProxy.Net 主要是攔截方法處理 方法執行前 方法執行後 方法異常 How to Use: 使用方法類似於Asp.Net MVC中Contoller，Action過濾器 撰寫一個標籤(Attribute) 標記攔截動作 123456789101112131415161718public class CacheAttribute : AopBaseAttribute&#123; public string CacheName &#123; get; set; &#125; public override void OnExcuting(ExcuteingContext context) &#123; object cacheObj = CallContext.GetData(CacheName); if (cacheObj != null) &#123; context.Result = cacheObj; &#125; &#125; public override void OnExcuted(ExcutedContext context) &#123; CallContext.SetData(CacheName, context.Result); &#125;&#125; 將要被攔截類別繼承於MarshalByRefObject類別 12345678public class CacheService : MarshalByRefObject&#123; [Cache] public string GetCacheDate() &#123; return DateTime.Now.ToString("yyyy/MM/dd hh:mm:ss"); &#125;&#125; 由ProxyFactory.GetProxyInstance 動態產生被代理類別1CacheService cache = ProxyFactory.GetProxyInstance&lt;CacheService&gt;(); 4.直接呼叫方法就可執行標籤上的攔截動作12CacheService cache = ProxyFactory.GetProxyInstance&lt;CacheService&gt;();Console.WriteLine(cache.GetCacheDate()); Simple Code： 撰寫Log 權限驗證 快取 Unit Test 結果 小結：使用 AwesomeProxy.Net 和ASP.Net MVC註冊Contoller或Action過濾器一樣AOP核心思想就是代理模式。 本篇只先介紹如何使用，後續有時間會再補充代理模式細節！ 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/AwesomeProxy-Net/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>AOP</tag>
        <tag>Asp.net</tag>
        <tag>Design-Pattern</tag>
        <tag>Open-Source</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C#】我們來土砲一個 Asp.net Session (Session核心原理)]]></title>
    <url>%2Fown-session%2F</url>
    <content type="text"><![CDATA[我們在寫網站一定會使用到 Session今天就跟大家分享自製微型 Asp.net Session 分析Session-&gt;實作Session-&gt;使用Session 在實作之前您必須先了解甚麼是Session網路上一大堆介紹Session文章在此我就不多介紹或可以點進之前小弟的介紹文來簡單了解 SessionID.cookie,Session傻傻分不清楚?? 簡單說明：Http協議是一個無狀態協議。 核心是 請求=&gt;處理=&gt;回應 每次請求都是獨立不會記住上一次做了甚麼Session可以幫我們把資料存在Server記憶體，方便我們下次請求使用上網連線眾多使用者，Server怎麼知道哪份資料,屬於哪個使用者的? 這就要依靠 SessonIDSessionID就像使用者的號碼牌，可以到Server拿相對應的資料 分析： 使用者請求頁面時會攜帶該網域下Cookies。 Asp.net接收到並使用Key為SessionID的Cookie，使用Cookie的Value來SessionPool中查找屬於使用者的Session。如果是第一次請求或是沒有SessionID 會幫他產生一個新的並加入回應的Cookie中 取得Session物件後就可以在程式中使用。 分析如下圖： 我們作出幾個核心來完成模擬Session: SessionPool來存放目前所有Session SessionObject (支援快取在系統記憶體中)模擬HttpContext封裝Session 實作：我要簡單呈現就選擇使用輕便 [泛型處理常式] ApplicationContext 模擬HttpContext封裝SessionPool創建一個靜態的SessionPool物件，因為程式都共用此SessionPool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// &lt;summary&gt;/// 請求上下文/// &lt;/summary&gt;public class ApplicationContext&#123; /// &lt;summary&gt; /// 存在Cookie中的SessionID /// &lt;/summary&gt; private readonly string MySessionID = "MySessionID"; public HttpRequest Request &#123; get; private set; &#125; public HttpResponse Respone &#123; get; private set; &#125; public ApplicationContext(HttpContext context) &#123; Respone = context.Response; Request = context.Request; &#125; private static SessionPool _container = new SessionPool(); public SessionObject Session &#123; get &#123; return GetSessionObj(); &#125; &#125; /// &lt;summary&gt; /// 從SessionPool中取得Session對象 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private SessionObject GetSessionObj() &#123; Guid sessionGuid; HttpCookie CookieSessionID = Request.Cookies[MySessionID]; //如果沒有MySessionID的cookie，做一個新的 if (CookieSessionID == null) &#123; sessionGuid = Guid.NewGuid(); HttpCookie cookie = new HttpCookie(MySessionID, sessionGuid.ToString()) &#123; Expires = DateTime.Now.AddDays(60) &#125;; Respone.Cookies.Add(cookie); &#125; else &#123; sessionGuid = Guid.Parse(CookieSessionID.Value); &#125; return _container[sessionGuid]; &#125;&#125; CacheDictionary 負責快取 使用一個 Dictionary 來對Session存取物件設置快取 12345/// &lt;summary&gt;/// 掌管物件存活時間的集合/// &lt;/summary&gt;private readonly Dictionary&lt;string, CancellationTokenSource&gt; _expireContaner = new Dictionary&lt;string, CancellationTokenSource&gt;(); 在Task.Delay可以讓物件存放在工作執行緒中 等Delay時間到就呼叫 ContinueWith 將物件消毀 1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 設置快取對象/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;/// &lt;param name="key"&gt;&lt;/param&gt;/// &lt;param name="create"&gt;&lt;/param&gt;/// &lt;param name="expireIn"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T Set&lt;T&gt;(string key, Func&lt;T&gt; create, TimeSpan expireIn)&#123; //如果此Key被使用 將原本的內容移除 if (_expireTasks.ContainsKey(key)) &#123; _expireTasks[key].Cancel(); _expireTasks.Remove(key); &#125; var expirationTokenSource = new CancellationTokenSource(); var expirationToken = expirationTokenSource.Token; //物件快取 Task.Delay(expireIn, expirationToken).ContinueWith(_ =&gt; Expire(key), expirationToken); _expireTasks[key] = expirationTokenSource; return (T)(this[key] = create());&#125; SeesionPool 存放所有Session取Session會判斷此Guid是否有對應的Session物件，沒有會幫她創建一個放在池子中 12345678910111213141516171819202122232425/// &lt;summary&gt;/// 存放所有Session池子/// &lt;/summary&gt;public class SessionPool&#123; private Dictionary&lt;Guid, SessionObject&gt; _SessionContain = new Dictionary&lt;Guid, SessionObject&gt;(); public SessionObject this[Guid index] &#123; get &#123; SessionObject obj; if (_SessionContain.TryGetValue(index, out obj)) &#123; return obj; &#125; else &#123; obj = new SessionObject(); _SessionContain.Add(index, obj); &#125; return obj; &#125; &#125;&#125; SessionObject 控制讀取時的值 (一般我們所使用的Session) 1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// Session物件/// &lt;/summary&gt;public class SessionObject&#123; private CacheDictionary cache = new CacheDictionary(); public object this[string index] &#123; get &#123; return GetObj(index); &#125; set &#123; SetCache(index, value); &#125; &#125; private void SetCache(string key, object value) &#123; cache.Set(key, () =&gt; value); &#125; private object GetObj(string key) &#123; return cache.GetOrDefault(key, () =&gt; default(object)); &#125;&#125; 使用： 在建構子中創建一個 ApplicationContext 之後,即可Asp.net那樣來使用Session 1234567891011121314151617private ApplicationContext app;public SessionHanlder()&#123; app = new ApplicationContext(HttpContext.Current);&#125;public void ProcessRequest(HttpContext context)&#123; if (null == app.Session["Time"]) &#123; app.Session["Time"] = $"Hello &#123;DateTime.Now.ToString("yyyy-MM-dd hh-mm-ss")&#125;"; &#125; context.Response.Write(app.Session["Time"]); context.Response.ContentType = "text/plain";&#125; 上面程式是簡單模擬Session核心作用的程式 但並未處理多執行緒並發讀寫…等等問題，所以建議別再實際專案中使用XD!! 專案使用 VS2015 GitHub原始碼 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/own-session/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>SourceCode</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五分鐘快速了解 [傳址，傳參考，傳址]]]></title>
    <url>%2Fref-address%2F</url>
    <content type="text"><![CDATA[傳址，傳參考，傳址 是基本但重要的概念。此概念在很多語言都通用 我使用Gif動畫檔 快速帶領大家了解 傳址，傳參考，傳址 傳值(Call By Value) 顧名思義 是把值傳到 另一個記憶體位置的值上 傳址 (Call By Adress) 是把記憶體位置傳到 另一個記憶體位置的值上 補充:嚴格來說(Call By Adress)是不正統的說法,其實傳址也是傳值但傳的是記憶體位置 傳參考(Call By Reference) 是把記憶體位置傳到 移到另一個記憶體位置上 (可看作同一個物件) 在C#廣義來說 基本型別 Struct (int,double,float,byte …) 可看作 傳值 一般型別 Class (自訂Class ,SqlConnection….) 可看作 傳址 更精確來說是傳Stack的值(指向Heap的記憶體位置) 在C#中並沒傳參考，只有傳值和傳址 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/ref-address/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Memory</tag>
        <tag>call by value</tag>
        <tag>call by adress</tag>
        <tag>call by reference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net使用快取 (二)]]></title>
    <url>%2Fcache-asp-net-2%2F</url>
    <content type="text"><![CDATA[Asp.net使用快取 (一) 向大家簡單介紹 快取是什麼 為何要使用快取 使用簡單HttpRuntime.Cache使用快取機制 這篇是分享把快取程式碼變得更有彈性 第二篇大綱 提出介面,提高可替換性 使用泛型改寫快取 讀取方式 使用擴充方法改寫快取 提出介面,提高可替換性情境: 目前有個專案使用 HttpRuntime.Cache 物件 在記憶體快取中除了使用 Asp.Net 中HttpRuntime.Cache類別外還有很多解決方案.例如使用Memcache,Redis… 如果我們原本使用HttpRuntime.Cache類別但之後要轉成其他快取方式怎麼辦? 1234567891011121314151617public class HomeController : Controller&#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; public ActionResult Index() &#123; string cacheData = cacheContainer.Get("data") as string; if (cacheData==null) &#123; cacheContainer.Insert("test1", DateTime.Now.ToShortDateString()); &#125; return View(cacheData); &#125;&#125; 雖然使用不同快取方式,但記得我上篇的重點快取會有兩個動作,讀和寫,所以最基本就會有讀和寫這兩個動作 OOP有個很重要的觀念 多個類有重複動作考慮提出父類別 為了方便了解我把HttpRuntime.Cache封裝成一個類別 12345678910public class NetCache &#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; public object GetCacheObject(string key) &#123; return cacheContainer.Get(key); &#125; public void SetCache(string key,object obj) &#123; cacheContainer.Insert(key, obj); &#125;&#125; 這邊有另一個Memcache快取Class 12345678910111213141516public class MemeryCache &#123; private ObjectCache _cache = MemoryCache.Default; public object GetCacheObject(string key) &#123; return _cache[cacheKey]; &#125; public void SetCache(string key, object obj) &#123; var policy = new CacheItemPolicy(); policy.RemovedCallback = OnFileContentsCacheRemove; // 設定快取時間2分鐘 policy.AbsoluteExpiration = DateTimeOffset.Now.Minute(2); _cache.Set(cacheKey, fileContents, policy); &#125;&#125; 先不關注這兩個物件裡面細節,我們可以發現他們都有 GetCacheObject 方法和SetCache 方法 這時我們就可以適時提出介面(interface),當作這兩個類別的合約 123456public interface ICache &#123; void Set(string key,object obj); object Get(string key);&#125; 之後將他們兩個類別實現 ICache 介面 1234567891011121314151617181920212223242526272829public class MemeryCache : ICache&#123; private ObjectCache _cache = MemoryCache.Default; public object Get(string key) &#123; return _cache[cacheKey]; &#125; public void Set(string key, object obj) &#123; var policy = new CacheItemPolicy(); policy.RemovedCallback = OnFileContentsCacheRemove; // 設定快取時間2分鐘 policy.AbsoluteExpiration = DateTimeOffset.Now.Minute(2); _cache.Set(cacheKey, fileContents, policy); &#125;&#125;public class NetCache : ICache&#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; public object Get(string key) &#123; return cacheContainer.Get(key); &#125; public void Set(string key,object obj) &#123; cacheContainer.Insert(key, obj); &#125;&#125; 提出介面有甚麼好處? 我們可以把前面程式碼改成IOC依賴注入的方式,不要在程式碼寫死使用HttpRuntime.Cache,由IOC容器幫我們把物件注入程式碼中. Note:我使用建構子注入法 12345678910111213141516171819202122public class HomeController : Controller&#123; //不用寫死使用 HttpRuntime.Cache //System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; ICache cacheContainer; public HomeController(ICache Container)&#123; cacheContainer = Container; &#125; public ActionResult Index() &#123; string cacheData = cacheContainer.Get("data") as string; if (cacheData==null) &#123; cacheContainer.Insert("test1", DateTime.Now.ToShortDateString()); &#125; return View(cacheData); &#125;&#125; ICache 變成快取程式碼的潤滑劑.可讓程式變得更有彈性 使用泛型改寫快取 讀取方式我在StackOverFlow解答的方式就是第二種 其中最主要的技巧就是把Get方法返回的Object改成使用泛型 123456789101112131415161718 public T GetOrSetCache&lt;T&gt; (string key,T obj, int cacheTime) where T:class,new()&#123; System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache; T cacheObj = cacheContainer.Get(key) as T; if (cacheObj == null) &#123; cacheContainer.Insert(key, obj, null, DateTime.Now.AddMinutes(cacheTime), System.Web.Caching.Cache.NoSlidingExpiration); cacheObj = obj; &#125; return cacheObj;&#125; 讓我們在使用時可以變成 123var data = DateTime.Now.ToShortDateString();int numberOfMinutes = 3;data = GetOrSetCache("name1",data,numberOfMinutes ); 我們只需要呼叫GetOrSetCache方法,這個方法把GetCache和SetCache封裝起來了 使用擴充方法改寫快取.Net有提供一個很方便的機制 擴充方法,這個機制幫我們解決一個很重要的問題.我們可以擴充已經封裝但沒有原始碼的類別, 在這段程式碼中,使用Func&lt;TObj&gt; 可以使用lambda 表達式,讓程式碼更簡潔有力!! 123456789101112131415public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key, int cacheTime) where TObj : class&#123; Cache cacheContainer = HttpRuntime.Cache; //get cache Object var obj = cacheContainer.Get(key) as TObj; //if there isn't cache object add this object to cache if (obj == null) &#123; obj = selector(); cacheContainer.Insert(key, obj); &#125; return obj;&#125; 我們使用時如下 變更簡潔動作更漂亮 12int numberOfMinutes = 3;data = GetOrSetCache(()=&gt; DateTime.Now.ToShortDateString(),"name1",data,numberOfMinutes ); 同場加映: 擴展方法和介面搭配使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class WebDefaultCache : ICache&#123; Cache cacheContainer = HttpRuntime.Cache; public object Get(string key) &#123; return cacheContainer.Get(key); &#125; public void Set(string key, object obj) &#123; cacheContainer.Insert(key, obj); &#125;&#125;public interface ICache&#123; void Set(string key, object obj); object Get(string key);&#125;public static class InfrastructureExtension&#123; public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key) where TObj : class &#123; return GetOrSetCache(selector, key,10); &#125; public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key, int cacheTime) where TObj : class &#123; return GetOrSetCache(selector, key, cacheTime, new WebDefaultCache()); &#125; public static TObj GetOrSetCache&lt;TObj&gt;(this Func&lt;TObj&gt; selector, string key, int cacheTime, ICache cacheContainer) where TObj : class &#123; //get cache Object var obj = cacheContainer.Get(key) as TObj; //if there isn't cache object add this object to cache if (obj == null) &#123; obj = selector(); cacheContainer.Set(key, obj); &#125; return obj; &#125;&#125; 雖然在使用上和第三種一樣但我們多了使用方法重載多傳一個參數ICache介面 可以讓我們在寫程式時決定要使用哪種cache方式,不用改快去那邊程式碼. 同場加映程式碼我放在我自己常用的ExtenionTool專案中 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/cache-asp-net-2/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp.net使用快取 (一)]]></title>
    <url>%2Fcache-asp-net-1%2F</url>
    <content type="text"><![CDATA[最近回答SQL Server data caching in ASP.NET問題,且有人問我有關快取的問題. 所以小弟打算寫兩篇文章簡單分享我知道的快取 目錄:第一篇 為何要使用快取 快取操作 Asp.Net中使用快取 by HttpRuntime.Cache 第二篇 提出介面,提高可替換性 使用泛型改寫快取 讀取方式 使用擴充方法改寫快取 正文快取機制很重要,但有些觀念可能要先釐清楚 為何要使用快取在使用一個東西前,使用的原因很重要. 如果某些資料常常使用,但卻不常改變我們會把資料存在某個空間中(常常會存記憶體,因為記憶體速度快),方便日後讀取使用. 快取操作一般使用快取會有兩個動作,讀和寫如果是存在記憶體中一般會有期限,因為記憶體資源很寶貴不能一直占用. 寫入 通常有一個Key,跟要存入物件就像我們把東西存入保險箱,會拿到一個鑰匙 來取東西 讀取 讀取就是依照Key讀取我們存入的物件 就像我們要拿保險箱裡的東西需要的鑰匙 Asp.Net中使用快取 by HttpRuntime.Cache 在Asp.net中 有一個靜態物件 HttpRuntime.Cache 可以很方便使用快取 存入快取可以呼叫 Insert 方法 他有多個重載 可以使用最簡單的 Insert(string [key],object [value]) 如下面範例 123System.Web.Caching.Cache cacheContainer = HttpRuntime.Cache;string data = "";cacheContainer.Insert("test1", data); 讀取快取資料 呼叫 Get 傳入Key值即可獲得 Note:如果快取容器沒有此物件會回傳NULL 1string cacheData = cacheContainer.Get("data") as string; 小結:這篇簡單介紹快取 下篇會將目前程式碼做改進,變得更優美彈性 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/cache-asp-net-1/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Asp.net</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JsonConvert.SerializeObject 呼叫 object.Equals 問題探討]]></title>
    <url>%2FJsonConvert-SerializeObject%2F</url>
    <content type="text"><![CDATA[最近在 StackOverFlow 解答一個很有趣的問題Json.Net / Newtonsoft: Using JsonConvert.SerializeObject results in weird .Equals calls - why? 問題簡述是：使用Newtonsoft.Json.JsonConvert.SerializeObject方法 來把物件轉成JSON資料時,為什麼會呼叫物件的Equals 方法 且傳入的object obj類型不是此類別類型,而是屬性的類型 以下是發問者提供的程式碼: 1234567891011121314151617181920public class JsonTestClass&#123; public string Name &#123; get; set; &#125; public List&lt;int&gt; MyIntList &#123; get; set; &#125; public override bool Equals(object obj) &#123; if (obj == null) return false; JsonTestClass jtc = (JsonTestClass)obj; return true; &#125;&#125;JsonTestClass c = new JsonTestClass();c.Name = "test";c.MyIntList = new List&lt;int&gt;();c.MyIntList.Add(1);string json = JsonConvert.SerializeObject(c, new JsonSerializerSettings() &#123; TypeNameHandling = TypeNameHandling.All &#125;); 問題解析：看到問題後我就直接去看Json.net原始碼 一探到底原因出在哪邊. 後面發現當我們在呼叫JsonConvert.SerializeObject方法,會執行一個 private bool CheckForCircularReference私有方法. 123bool exists = (Serializer._equalityComparer != null) ? _serializeStack.Contains(value, Serializer._equalityComparer) : _serializeStack.Contains(value); ### 重點： 這個方法主要用意是判斷目前序列化JSON物件是否有重複引用本身,方法中有段程式碼使用到 List&lt;T&gt;.Contains. 當我們在呼叫List&lt;T&gt;.Contains時 預設EqualityComparer&lt;T&gt;.Default 進行比較來進行判斷是否存在集合中. 要寫客製化比較方式有兩種 在.net中每個類別都繼承於Object, Object 中有object.Equals 所以可以重寫object.Equals方法. 將此類別實現 IEquatable&lt;T&gt; 並重寫你要的比較方式. 所以會呼叫object.Equals是因為上段程式碼 補充說明：什麼是判斷目前序列化JSON物件是否有重複引用本身? 以下的範例是private bool CheckForCircularReference想要防止的問題 123456789101112public class JsonTestClass&#123; public string Name &#123; get; set; &#125; public List&lt;int&gt; MyIntList &#123; get; set; &#125; public JsonTestClass Test&#123;get;set;&#125;&#125;JsonTestClass c = new JsonTestClass();c.Name = "test";c.Test = c;string json = JsonConvert.SerializeObject (c, new JsonSerializerSettings() &#123; TypeNameHandling = TypeNameHandling.All &#125;); 我們可以看到c.Test = c; 將自己本身付值給 public JsonTestClass Test{get;set;} 這個屬性. 我們執行上面程式碼會得到此錯誤 Self referencing loop detected for property ‘Test’ with type ‘Program+JsonTestClass’. Path ‘’. 是因為他要防止重複引用本身導致無限迴圈解析JSON. Note預設值類型的比較是比較值.預設參考類別比較的是地址. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/JsonConvert-SerializeObject/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Json.net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC(控制反轉)，DI(依賴注入) 深入淺出~~]]></title>
    <url>%2Fioc-di%2F</url>
    <content type="text"><![CDATA[IOC是一個oop重要的程式設計思想。 學一個技術或思想前我們先了解，這個技術或思想為我們解決怎樣問題。 Ioc—Inversion of Control 控制反轉控制反轉是一個設計思想 ，把對於某個物件的控制權移轉給第三方容器 簡單解釋A物件程式內部需要使用B物件 A,B物件中有依賴的成份 控制反轉是把原本A對B控制權移交給第三方容器 降低A對B物件的耦合性，讓雙方都倚賴第三方容器。 反轉概念如下圖 我們可發現有兩點差異 使用者原本直接耦合於A，但使用IoC容器使用者就直接對容器而不是A 至於A關連於誰由容器決定原本A直接控制於B,C，但透過一個IoC容器我們控制權反轉給了容器 IoC經典實現對象設計法則 好萊塢法則：“別找我們，我們找你”系統中模組建議依賴抽象，因為各個模組間不需要知道對方太多細節（實作），知道越多耦合越強。DI—Dependency Injection 依賴注入 把被依賴物件注入被動接收物件中 案例解釋：小明是個愛乾淨的人，但他工作時常加班導致 學一個技術或思想前我們必須先了解，這個技術或思想可為我們解決什麼問題。 Ioc(Inversion of Control)控制反轉 控制反轉是一個設計思想 簡單解釋 A物件程式內部需要使用B物件 A,B物件中有依賴的成份 控制反轉把原本A對B直接控制權移交給由第三方容器 降低A對B物件的耦合程度，並讓雙方都倚賴抽象。 IoC經典實現對象設計法則 好萊塢法則：“別找我們，我們找你” 系統中模組建議依賴抽象，因為各個模組間不需要知道對方太多細節（實作），知道越多耦合越強。 DI—Dependency Injection 依賴注入 把被依賴物件注入被動接收物件中 案例解釋： 小明是個愛乾淨的人，但他工作時常加班導致房間雜亂，他不能忍受此狀況，所以小明去找一個清潔阿姨每天幫忙他打掃家裡 哪天阿姨哪天有事不能打掃，小明就必須要再去找人來幫忙打掃，由此可知小明耦合阿姨 如果今天是…. 小明把他要的條件給「打掃仲介公司」，仲介公司幫他尋找有沒有符合小明需求的打掃阿姨，假如今天A阿姨請假了，仲介公司會自動找另一個符合需求B阿姨幫忙打掃… 原本小明需耦合於打掃阿姨，現在被「仲介公司」做了控制反轉讓「仲介公司」來提供打掃阿姨。 小明不用管是否今天有人會來打掃，「仲介公司」會幫小明找到一個掃地阿姨。 「仲介公司」可看作 依賴注入容器 「小明」可看作 被動接收物件 「打掃阿姨」可看作 被依賴物件 在使用IOC容器前需先了解雙方的依賴關係(誰依賴誰?) 上述還有一個很重要的觀念是，依賴和被接收對象要倚賴抽象。 範例使用：VS2015 IOC容器：AutoFac 下面範例來說明上面的例子 小明自己依賴於掃地阿姨依賴程式碼寫在小明類別內部日後要更改只能動內部程式碼。 12345678910111213/// &lt;summary&gt;/// 小明直接依賴 Aunt 不是依賴抽象/// 日後要改必須動內部/// &lt;/summary&gt;public class Mine&#123; public Aunt aunt = new Aunt(); public void Room() &#123; aunt.Swapping(); &#125;&#125; 呼叫使用時 12Mine mine = new Mine();mine.Room(); 小明找仲介公司 仲介公司(Ioc容器) 在仲介公司內註冊需求，讓仲介公司日後幫你找人（註冊的類別） 123456789101112131415/// &lt;summary&gt;/// 仲介公司/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private static IContainer MiddleCompany()&#123; ContainerBuilder builder = new ContainerBuilder(); //在仲介公司裡寫需求人申請單 builder.RegisterType&lt;MineWithMiddle&gt;(); //小明所需打掃阿姨需求 builder.RegisterType&lt;Aunt&gt;().As&lt;ISwapable&gt;(); return builder.Build();&#125; 使用起來 12345IContainer middleCompany = MiddleCompany();//仲介公司(IOC AutoFac)自動幫小明注入一個打掃阿姨MineWithMiddle mineWithMiddle = middleCompany.Resolve&lt;MineWithMiddle&gt;();mineWithMiddle.Room(); 總結： 雖然上面程式碼執行結果一樣，但內部結構和日後擴展性卻截然不同 重點：系統中模組建議依賴抽象，因為各個模組間不需要知道對方太多細節（實作），知道越多耦合越強。 像網頁瀏覽器和伺服器是依賴Http協議，用戶端不管是手機.電腦,平板，伺服器端php,asp.net,java都可互相交信，依賴Http協議共用的合約 範例原始碼 參考連結 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/ioc-di/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>IOC</tag>
        <tag>Autofac</tag>
        <tag>Design-Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沒有Source Code 如何修改程式??]]></title>
    <url>%2Fmodify-sourcecode%2F</url>
    <content type="text"><![CDATA[某些專案因為歷史久遠沒有Source Code,但有個需求需要異動裡面的程式該怎麼辦?? 難道只能整個反組譯,查看程式碼翻一份做新的嗎? 不~~其實有辦法直接對於DLL進行修改 只需使用 Reflexil 搭配 ILSpy 或其他支援的反組譯軟體 Reflexil 是一個組譯編輯器插件目前支援 Reflector, ILSpy 和 Telerik’s JustDecompile. 下載連結 Reflexil Release 2.2 搭配 ILSpy version 3.2 前置動作，安裝Reflexil 下載下載 reflexil.for.ILSpy.2.2.bin.zip，不用下載AIO 作者有說 ILSpy version 3.2 (ILSpy 4 is not currently compatible with Reflexil, given the use of System.Reflection.Metadata, deprecating Mono.Cecil usage)ILSpy 4 當前版本 ILSpy.2.2 並不支援 ILSpy 3.2 下載 下載完後就把全部的DLL放在同一個資料夾下,並開啟 ILSpy.exe 按下上方的齒輪UI 就可獲得下方藍色的Reflexil 修改框框. 組件修改需求 目前組件 有個ClassA 類別,裡面有一個prop1屬性 型態是string, 我們希望在這新增另一個屬性 使用滑鼠右鍵點擊類別ClassA,我們可以看到很多方式可以注入新的程式碼 在這我們選擇inject property. 我們需要修改的是 Item Name (使用屬性的名稱) Property Type(使用屬性類別) 選擇完後按下OK,我們就會發現prop2新屬性會出現在ClassA中. 新增完後不代表已經將修改儲存!! 我們需要點選組件，之後再按下Save AS 把本次修改儲存 日後我們就可以使用新的屬性在我們程式中了!! 小結此插件還可以新增,插入許多東西時屬非常強大,有興趣的玩家可再自行深入琢磨. 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/modify-sourcecode/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Reflection</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[淺談-編碼(encoding) vs 加解密 vs 雜湊(Hash)]]></title>
    <url>%2Fhash-encoding%2F</url>
    <content type="text"><![CDATA[這一邊有三筆資料 U2FsdGVkX19FJsgVyam+Gh2EwmGs4BEJjJJsWxCXHWw84gp3uHvozWsHY8gfAx0C VG9kYXkgaXMgYSBnb29kIERheQ== 046a484a529ecfc7693753ee65802b5cfcafd548252d0e5f1bca845ad2208b91 這三個東西看起來都是亂碼，但所代表含意完全不一樣 這邊會跟大家分享這三個東西特性和差異性 此文同步發布 Blog [淺談] 編碼(encoding) vs 加解密 vs 雜湊(Hash) 前言：會想分享這篇文章是因為蠻多人把 編碼(encoding) 加解密 雜湊(Hash) 這三個東西搞混，尤其是把編碼當作加密….這是非常危險的事情. 編碼!= 加密 兩個是完全不一樣的東西 編碼!= 加密 兩個是完全不一樣的東西 編碼!= 加密 兩個是完全不一樣的東西 很重要所以要說三次XD! 編碼說明：這邊用Base64編碼來介紹，我們可以看到下圖資料轉換是雙向的． Hello Daniel =&gt; SGVsbG8gRGFuaWVs 如果我們想要把SGVsbG8gRGFuaWVs 變回 Hello Daniel 只需進行Base64解碼即可 編碼是將原本的資料經過一個運算轉換成另一組資料,如果要還原成原本資料解碼 用途：在網路傳輸會使用到編碼主要是資料在傳輸時有些特殊字元,有特殊用途(ex:Http 傳參數 &amp;….) 這時就可使用編碼將資料轉換成不會衝突到字串. 如果想要了解 Base64 原理和演算法的話可以看我另一篇【深入淺出】Base編碼 (Base64為例子) 加解密說明：這邊以AES來介紹，我們可以看到下圖資料轉換是雙向，但會透過一個Key來做轉換(這邊是和編碼最大的差別) 要還原成原始資料我們只能透過一樣的Key才可以達成，就像一個寶相只有唯一一把鑰匙可以打開一樣． 這邊補充一個簡單加密法(凱薩算法)，他是使用字元位移的數字來當作Key 如果位移數量是1 ABCD =&gt; BCDE 如圖 用途：加密可以確保資料的安全性（只有相同的Key才可還原成原本資料）很適合用在機密資料且須要還原使用 雜湊(Hash)說明：這裡用Sha256來當作範例 Hash有幾個特點 不管資料量多大經過SHA256運算字串長度都是一樣的 SHA256的原因是運算完的資料大小一定是 256 bit 她是一個不可逆的算法所以我們可以看到箭頭是單向. 相同的值用SHA運算過後值都是一樣的 一定會有小夥伴好奇,運算完都是固定長度 那會不會出現一個情況,原始資料不一樣但算完Hash結果是一樣的 會 這個我們稱之為雜湊碰撞 這個機率很小 用途：一般我們可以把使用者密碼經Hash運算存入資料庫中,當作使用唯一識別碼(像指紋)下次使用者登入用運一樣的Hash算法 再將值拿來比較辨識使用者合法性. 小結：對於這邊有一個簡單的比較表格 編碼(encoding) 加解密 雜湊(Hash) 加解密和編碼最常被大家誤會搞錯地方是以為使用Base64編碼就很安全(但有心人事取得你的資料只要知道你使用編碼就可以還原成原始資料) 如果要確保資料隱密性時可以使用加解密而不是編碼 所以別再把Base64編碼當作加密工具來使用. 這是很危險低 此文作者：Daniel Shih(石頭)此文地址： https://isdaniel.github.io/hash-encoding/ 版權聲明：本博客所有文章除特別聲明外，均採用 CC BY-NC-SA 3.0 TW 許可協議。轉載請註明出處！]]></content>
      <categories>
        <category>WebDesign</category>
      </categories>
      <tags>
        <tag>Base64</tag>
        <tag>Encoding</tag>
        <tag>AES</tag>
        <tag>SHA256</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
</search>
